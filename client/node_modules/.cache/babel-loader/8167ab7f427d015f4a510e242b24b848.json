{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(require(\"@firebase/app\")) : \"function\" == typeof define && define.amd ? define([\"@firebase/app\"], e) : e((t = t || self).firebase);\n}(this, function (Zd) {\n  \"use strict\";\n\n  try {\n    (function () {\n      Zd = Zd && Zd.hasOwnProperty(\"default\") ? Zd.default : Zd;\n\n      var r = function (t, e) {\n        return (r = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (t, e) {\n          t.__proto__ = e;\n        } || function (t, e) {\n          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);\n        })(t, e);\n      };\n\n      function t(t, e) {\n        function n() {\n          this.constructor = t;\n        }\n\n        r(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n());\n      }\n\n      var o,\n          e,\n          l = function () {\n        return (l = Object.assign || function (t) {\n          for (var e, n = 1, r = arguments.length; n < r; n++) for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);\n\n          return t;\n        }).apply(this, arguments);\n      };\n\n      function p(o, a, s, u) {\n        return new (s = s || Promise)(function (t, e) {\n          function n(t) {\n            try {\n              i(u.next(t));\n            } catch (t) {\n              e(t);\n            }\n          }\n\n          function r(t) {\n            try {\n              i(u.throw(t));\n            } catch (t) {\n              e(t);\n            }\n          }\n\n          function i(e) {\n            e.done ? t(e.value) : new s(function (t) {\n              t(e.value);\n            }).then(n, r);\n          }\n\n          i((u = u.apply(o, a || [])).next());\n        });\n      }\n\n      function m(n, r) {\n        var i,\n            o,\n            a,\n            t,\n            s = {\n          label: 0,\n          sent: function () {\n            if (1 & a[0]) throw a[1];\n            return a[1];\n          },\n          trys: [],\n          ops: []\n        };\n        return t = {\n          next: e(0),\n          throw: e(1),\n          return: e(2)\n        }, \"function\" == typeof Symbol && (t[Symbol.iterator] = function () {\n          return this;\n        }), t;\n\n        function e(e) {\n          return function (t) {\n            return function (e) {\n              if (i) throw new TypeError(\"Generator is already executing.\");\n\n              for (; s;) try {\n                if (i = 1, o && (a = 2 & e[0] ? o.return : e[0] ? o.throw || ((a = o.return) && a.call(o), 0) : o.next) && !(a = a.call(o, e[1])).done) return a;\n\n                switch (o = 0, a && (e = [2 & e[0], a.value]), e[0]) {\n                  case 0:\n                  case 1:\n                    a = e;\n                    break;\n\n                  case 4:\n                    return s.label++, {\n                      value: e[1],\n                      done: !1\n                    };\n\n                  case 5:\n                    s.label++, o = e[1], e = [0];\n                    continue;\n\n                  case 7:\n                    e = s.ops.pop(), s.trys.pop();\n                    continue;\n\n                  default:\n                    if (!(a = 0 < (a = s.trys).length && a[a.length - 1]) && (6 === e[0] || 2 === e[0])) {\n                      s = 0;\n                      continue;\n                    }\n\n                    if (3 === e[0] && (!a || e[1] > a[0] && e[1] < a[3])) {\n                      s.label = e[1];\n                      break;\n                    }\n\n                    if (6 === e[0] && s.label < a[1]) {\n                      s.label = a[1], a = e;\n                      break;\n                    }\n\n                    if (a && s.label < a[2]) {\n                      s.label = a[2], s.ops.push(e);\n                      break;\n                    }\n\n                    a[2] && s.ops.pop(), s.trys.pop();\n                    continue;\n                }\n\n                e = r.call(n, s);\n              } catch (t) {\n                e = [6, t], o = 0;\n              } finally {\n                i = a = 0;\n              }\n\n              if (5 & e[0]) throw e[1];\n              return {\n                value: e[0] ? e[1] : void 0,\n                done: !0\n              };\n            }([e, t]);\n          };\n        }\n      }\n\n      function a() {\n        for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;\n\n        var r = Array(t),\n            i = 0;\n\n        for (e = 0; e < n; e++) for (var o = arguments[e], a = 0, s = o.length; a < s; a++, i++) r[i] = o[a];\n\n        return r;\n      }\n\n      function s() {\n        for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;\n\n        var r = Array(t),\n            i = 0;\n\n        for (e = 0; e < n; e++) for (var o = arguments[e], a = 0, s = o.length; a < s; a++, i++) r[i] = o[a];\n\n        return r;\n      }\n\n      (e = o = o || {})[e.DEBUG = 0] = \"DEBUG\", e[e.VERBOSE = 1] = \"VERBOSE\", e[e.INFO = 2] = \"INFO\", e[e.WARN = 3] = \"WARN\", e[e.ERROR = 4] = \"ERROR\", e[e.SILENT = 5] = \"SILENT\";\n\n      function n(t, e) {\n        for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];\n\n        if (!(e < t.logLevel)) {\n          var i = new Date().toISOString();\n\n          switch (e) {\n            case o.DEBUG:\n            case o.VERBOSE:\n              console.log.apply(console, s([\"[\" + i + \"]  \" + t.name + \":\"], n));\n              break;\n\n            case o.INFO:\n              console.info.apply(console, s([\"[\" + i + \"]  \" + t.name + \":\"], n));\n              break;\n\n            case o.WARN:\n              console.warn.apply(console, s([\"[\" + i + \"]  \" + t.name + \":\"], n));\n              break;\n\n            case o.ERROR:\n              console.error.apply(console, s([\"[\" + i + \"]  \" + t.name + \":\"], n));\n              break;\n\n            default:\n              throw new Error(\"Attempted to log a message with an invalid logType (value: \" + e + \")\");\n          }\n        }\n      }\n\n      var i = o.INFO,\n          u = (Object.defineProperty(c.prototype, \"logLevel\", {\n        get: function () {\n          return this._logLevel;\n        },\n        set: function (t) {\n          if (!(t in o)) throw new TypeError(\"Invalid value assigned to `logLevel`\");\n          this._logLevel = t;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(c.prototype, \"logHandler\", {\n        get: function () {\n          return this._logHandler;\n        },\n        set: function (t) {\n          if (\"function\" != typeof t) throw new TypeError(\"Value assigned to `logHandler` must be a function\");\n          this._logHandler = t;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), c.prototype.debug = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        this._logHandler.apply(this, s([this, o.DEBUG], t));\n      }, c.prototype.log = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        this._logHandler.apply(this, s([this, o.VERBOSE], t));\n      }, c.prototype.info = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        this._logHandler.apply(this, s([this, o.INFO], t));\n      }, c.prototype.warn = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        this._logHandler.apply(this, s([this, o.WARN], t));\n      }, c.prototype.error = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        this._logHandler.apply(this, s([this, o.ERROR], t));\n      }, c);\n\n      function c(t) {\n        this.name = t, this._logLevel = i, this._logHandler = n;\n      }\n\n      function h() {\n        return \"undefined\" != typeof navigator && \"string\" == typeof navigator.userAgent ? navigator.userAgent : \"\";\n      }\n\n      var f,\n          d = (t(y, f = Error), y);\n\n      function y(t, e) {\n        var n = f.call(this, e) || this;\n        return n.code = t, n.name = \"FirebaseError\", Object.setPrototypeOf(n, y.prototype), Error.captureStackTrace && Error.captureStackTrace(n, g.prototype.create), n;\n      }\n\n      var g = (v.prototype.create = function (t) {\n        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n        for (var r = e[0] || {}, i = this.service + \"/\" + t, o = this.errors[t], a = o ? function (t, r) {\n          return t.replace(b, function (t, e) {\n            var n = r[e];\n            return null != n ? n.toString() : \"<\" + e + \"?>\";\n          });\n        }(o, r) : \"Error\", s = this.serviceName + \": \" + a + \" (\" + i + \").\", u = new d(i, s), c = 0, h = Object.keys(r); c < h.length; c++) {\n          var l = h[c];\n          \"_\" !== l.slice(-1) && (l in u && console.warn('Overwriting FirebaseError base field \"' + l + '\" can cause unexpected behavior.'), u[l] = r[l]);\n        }\n\n        return u;\n      }, v);\n\n      function v(t, e, n) {\n        this.service = t, this.serviceName = e, this.errors = n;\n      }\n\n      var b = /\\{\\$([^}]+)}/g,\n          w = (T.prototype.setInstantiationMode = function (t) {\n        return this.instantiationMode = t, this;\n      }, T.prototype.setMultipleInstances = function (t) {\n        return this.multipleInstances = t, this;\n      }, T.prototype.setServiceProps = function (t) {\n        return this.serviceProps = t, this;\n      }, T);\n\n      function T(t, e, n) {\n        this.name = t, this.instanceFactory = e, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = \"LAZY\";\n      }\n\n      var S,\n          E = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {},\n          I = I || {},\n          C = E;\n\n      function D(t) {\n        return \"string\" == typeof t;\n      }\n\n      function N(t) {\n        return \"number\" == typeof t;\n      }\n\n      function A(t, e) {\n        t = t.split(\".\"), e = e || C;\n\n        for (var n = 0; n < t.length; n++) if (null == (e = e[t[n]])) return null;\n\n        return e;\n      }\n\n      function k() {}\n\n      function R(t) {\n        var e = typeof t;\n\n        if (\"object\" == e) {\n          if (!t) return \"null\";\n          if (t instanceof Array) return \"array\";\n          if (t instanceof Object) return e;\n          var n = Object.prototype.toString.call(t);\n          if (\"[object Window]\" == n) return \"object\";\n          if (\"[object Array]\" == n || \"number\" == typeof t.length && void 0 !== t.splice && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable(\"splice\")) return \"array\";\n          if (\"[object Function]\" == n || void 0 !== t.call && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable(\"call\")) return \"function\";\n        } else if (\"function\" == e && void 0 === t.call) return \"object\";\n\n        return e;\n      }\n\n      function M(t) {\n        return \"array\" == R(t);\n      }\n\n      function _(t) {\n        var e = R(t);\n        return \"array\" == e || \"object\" == e && \"number\" == typeof t.length;\n      }\n\n      function L(t) {\n        var e = typeof t;\n        return \"object\" == e && null != t || \"function\" == e;\n      }\n\n      var O = \"closure_uid_\" + (1e9 * Math.random() >>> 0),\n          P = 0;\n\n      function x(t, e, n) {\n        return t.call.apply(t.bind, arguments);\n      }\n\n      function F(e, n, t) {\n        if (!e) throw Error();\n\n        if (2 < arguments.length) {\n          var r = Array.prototype.slice.call(arguments, 2);\n          return function () {\n            var t = Array.prototype.slice.call(arguments);\n            return Array.prototype.unshift.apply(t, r), e.apply(n, t);\n          };\n        }\n\n        return function () {\n          return e.apply(n, arguments);\n        };\n      }\n\n      function q(t, e, n) {\n        return (q = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf(\"native code\") ? x : F).apply(null, arguments);\n      }\n\n      function V(e, t) {\n        var n = Array.prototype.slice.call(arguments, 1);\n        return function () {\n          var t = n.slice();\n          return t.push.apply(t, arguments), e.apply(this, t);\n        };\n      }\n\n      var B = Date.now || function () {\n        return +new Date();\n      };\n\n      function U(t, o) {\n        function e() {}\n\n        e.prototype = o.prototype, t.N = o.prototype, t.prototype = new e(), (t.prototype.constructor = t).xb = function (t, e, n) {\n          for (var r = Array(arguments.length - 2), i = 2; i < arguments.length; i++) r[i - 2] = arguments[i];\n\n          return o.prototype[e].apply(t, r);\n        };\n      }\n\n      function K() {\n        this.j = this.j, this.i = this.i;\n      }\n\n      K.prototype.j = !1, K.prototype.la = function () {\n        if (!this.j && (this.j = !0, this.G(), 0)) this[O] || (this[O] = ++P);\n      }, K.prototype.G = function () {\n        if (this.i) for (; this.i.length;) this.i.shift()();\n      };\n      var Q = Array.prototype.indexOf ? function (t, e) {\n        return Array.prototype.indexOf.call(t, e, void 0);\n      } : function (t, e) {\n        if (D(t)) return D(e) && 1 == e.length ? t.indexOf(e, 0) : -1;\n\n        for (var n = 0; n < t.length; n++) if (n in t && t[n] === e) return n;\n\n        return -1;\n      },\n          j = Array.prototype.forEach ? function (t, e, n) {\n        Array.prototype.forEach.call(t, e, n);\n      } : function (t, e, n) {\n        for (var r = t.length, i = D(t) ? t.split(\"\") : t, o = 0; o < r; o++) o in i && e.call(n, i[o], o, t);\n      };\n\n      function G(t) {\n        return Array.prototype.concat.apply([], arguments);\n      }\n\n      function W(t) {\n        var e = t.length;\n\n        if (0 < e) {\n          for (var n = Array(e), r = 0; r < e; r++) n[r] = t[r];\n\n          return n;\n        }\n\n        return [];\n      }\n\n      function z(t) {\n        return /^[\\s\\xa0]*$/.test(t);\n      }\n\n      var H,\n          Y = String.prototype.trim ? function (t) {\n        return t.trim();\n      } : function (t) {\n        return /^[\\s\\xa0]*([\\s\\S]*?)[\\s\\xa0]*$/.exec(t)[1];\n      };\n\n      function J(t, e) {\n        return -1 != t.indexOf(e);\n      }\n\n      function X(t, e) {\n        return t < e ? -1 : e < t ? 1 : 0;\n      }\n\n      t: {\n        var Z = C.navigator;\n\n        if (Z) {\n          var $ = Z.userAgent;\n\n          if ($) {\n            H = $;\n            break t;\n          }\n        }\n\n        H = \"\";\n      }\n\n      function tt(t, e, n) {\n        for (var r in t) e.call(n, t[r], r, t);\n      }\n\n      function et(t) {\n        var e,\n            n = {};\n\n        for (e in t) n[e] = t[e];\n\n        return n;\n      }\n\n      var nt = \"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\n\n      function rt(t, e) {\n        for (var n, r, i = 1; i < arguments.length; i++) {\n          for (n in r = arguments[i]) t[n] = r[n];\n\n          for (var o = 0; o < nt.length; o++) n = nt[o], Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n        }\n      }\n\n      function it(t) {\n        return it[\" \"](t), t;\n      }\n\n      it[\" \"] = k;\n      var ot,\n          at,\n          st = J(H, \"Opera\"),\n          ut = J(H, \"Trident\") || J(H, \"MSIE\"),\n          ct = J(H, \"Edge\"),\n          ht = ct || ut,\n          lt = J(H, \"Gecko\") && !(J(H.toLowerCase(), \"webkit\") && !J(H, \"Edge\")) && !(J(H, \"Trident\") || J(H, \"MSIE\")) && !J(H, \"Edge\"),\n          ft = J(H.toLowerCase(), \"webkit\") && !J(H, \"Edge\");\n\n      function pt() {\n        var t = C.document;\n        return t ? t.documentMode : void 0;\n      }\n\n      t: {\n        var dt = \"\",\n            mt = (at = H, lt ? /rv:([^\\);]+)(\\)|;)/.exec(at) : ct ? /Edge\\/([\\d\\.]+)/.exec(at) : ut ? /\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(at) : ft ? /WebKit\\/(\\S+)/.exec(at) : st ? /(?:Version)[ \\/]?(\\S+)/.exec(at) : void 0);\n\n        if (mt && (dt = mt ? mt[1] : \"\"), ut) {\n          var yt = pt();\n\n          if (null != yt && yt > parseFloat(dt)) {\n            ot = String(yt);\n            break t;\n          }\n        }\n\n        ot = dt;\n      }\n\n      var gt,\n          vt = {};\n\n      function bt(s) {\n        return function (t, e) {\n          var n = vt;\n          return Object.prototype.hasOwnProperty.call(n, t) ? n[t] : n[t] = e(t);\n        }(s, function () {\n          for (var t = 0, e = Y(String(ot)).split(\".\"), n = Y(String(s)).split(\".\"), r = Math.max(e.length, n.length), i = 0; 0 == t && i < r; i++) {\n            var o = e[i] || \"\",\n                a = n[i] || \"\";\n\n            do {\n              if (o = /(\\d*)(\\D*)(.*)/.exec(o) || [\"\", \"\", \"\", \"\"], a = /(\\d*)(\\D*)(.*)/.exec(a) || [\"\", \"\", \"\", \"\"], 0 == o[0].length && 0 == a[0].length) break;\n              t = X(0 == o[1].length ? 0 : parseInt(o[1], 10), 0 == a[1].length ? 0 : parseInt(a[1], 10)) || X(0 == o[2].length, 0 == a[2].length) || X(o[2], a[2]), o = o[3], a = a[3];\n            } while (0 == t);\n          }\n\n          return 0 <= t;\n        });\n      }\n\n      var wt = C.document;\n      gt = wt && ut ? pt() || (\"CSS1Compat\" == wt.compatMode ? parseInt(ot, 10) : 5) : void 0;\n\n      var Tt = !ut || 9 <= Number(gt),\n          St = ut && !bt(\"9\"),\n          Et = function () {\n        if (!C.addEventListener || !Object.defineProperty) return !1;\n        var t = !1,\n            e = Object.defineProperty({}, \"passive\", {\n          get: function () {\n            t = !0;\n          }\n        });\n\n        try {\n          C.addEventListener(\"test\", k, e), C.removeEventListener(\"test\", k, e);\n        } catch (t) {}\n\n        return t;\n      }();\n\n      function It(t, e) {\n        this.type = t, this.a = this.target = e, this.Ia = !0;\n      }\n\n      function Ct(t, e) {\n        if (It.call(this, t ? t.type : \"\"), this.relatedTarget = this.a = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = \"\", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.pointerId = 0, this.pointerType = \"\", this.c = null, t) {\n          var n = this.type = t.type,\n              r = t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : null;\n\n          if (this.target = t.target || t.srcElement, this.a = e, e = t.relatedTarget) {\n            if (lt) {\n              t: {\n                try {\n                  it(e.nodeName);\n                  var i = !0;\n                  break t;\n                } catch (t) {}\n\n                i = !1;\n              }\n\n              i || (e = null);\n            }\n          } else \"mouseover\" == n ? e = t.fromElement : \"mouseout\" == n && (e = t.toElement);\n\n          this.relatedTarget = e, r ? (this.clientX = void 0 !== r.clientX ? r.clientX : r.pageX, this.clientY = void 0 !== r.clientY ? r.clientY : r.pageY, this.screenX = r.screenX || 0, this.screenY = r.screenY || 0) : (this.clientX = void 0 !== t.clientX ? t.clientX : t.pageX, this.clientY = void 0 !== t.clientY ? t.clientY : t.pageY, this.screenX = t.screenX || 0, this.screenY = t.screenY || 0), this.button = t.button, this.key = t.key || \"\", this.ctrlKey = t.ctrlKey, this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.metaKey = t.metaKey, this.pointerId = t.pointerId || 0, this.pointerType = D(t.pointerType) ? t.pointerType : Dt[t.pointerType] || \"\", (this.c = t).defaultPrevented && this.b();\n        }\n      }\n\n      It.prototype.b = function () {\n        this.Ia = !1;\n      }, U(Ct, It);\n      var Dt = {\n        2: \"touch\",\n        3: \"pen\",\n        4: \"mouse\"\n      };\n\n      Ct.prototype.b = function () {\n        Ct.N.b.call(this);\n        var t = this.c;\n        if (t.preventDefault) t.preventDefault();else if (t.returnValue = !1, St) try {\n          (t.ctrlKey || 112 <= t.keyCode && t.keyCode <= 123) && (t.keyCode = -1);\n        } catch (t) {}\n      };\n\n      var Nt = \"closure_listenable_\" + (1e6 * Math.random() | 0),\n          At = 0;\n\n      function kt(t, e, n, r, i) {\n        this.listener = t, this.proxy = null, this.src = e, this.type = n, this.capture = !!r, this.da = i, this.key = ++At, this.X = this.Z = !1;\n      }\n\n      function Rt(t) {\n        t.X = !0, t.listener = null, t.proxy = null, t.src = null, t.da = null;\n      }\n\n      function Mt(t) {\n        this.src = t, this.a = {}, this.b = 0;\n      }\n\n      function _t(t, e) {\n        var n = e.type;\n\n        if (n in t.a) {\n          var r,\n              i = t.a[n],\n              o = Q(i, e);\n          (r = 0 <= o) && Array.prototype.splice.call(i, o, 1), r && (Rt(e), 0 == t.a[n].length && (delete t.a[n], t.b--));\n        }\n      }\n\n      function Lt(t, e, n, r) {\n        for (var i = 0; i < t.length; ++i) {\n          var o = t[i];\n          if (!o.X && o.listener == e && o.capture == !!n && o.da == r) return i;\n        }\n\n        return -1;\n      }\n\n      Mt.prototype.add = function (t, e, n, r, i) {\n        var o = t.toString();\n        (t = this.a[o]) || (t = this.a[o] = [], this.b++);\n        var a = Lt(t, e, r, i);\n        return -1 < a ? (e = t[a], n || (e.Z = !1)) : ((e = new kt(e, this.src, o, !!r, i)).Z = n, t.push(e)), e;\n      };\n\n      var Ot = \"closure_lm_\" + (1e6 * Math.random() | 0),\n          Pt = {};\n\n      function xt(t, e, n, r, i) {\n        if (r && r.once) return function t(e, n, r, i, o) {\n          if (M(n)) {\n            for (var a = 0; a < n.length; a++) t(e, n[a], r, i, o);\n\n            return null;\n          }\n\n          r = jt(r);\n          return e && e[Nt] ? e.Aa(n, r, L(i) ? !!i.capture : !!i, o) : Ft(e, n, r, !0, i, o);\n        }(t, e, n, r, i);\n\n        if (M(e)) {\n          for (var o = 0; o < e.length; o++) xt(t, e[o], n, r, i);\n\n          return null;\n        }\n\n        return n = jt(n), t && t[Nt] ? t.za(e, n, L(r) ? !!r.capture : !!r, i) : Ft(t, e, n, !1, r, i);\n      }\n\n      function Ft(t, e, n, r, i, o) {\n        if (!e) throw Error(\"Invalid event type\");\n        var a = L(i) ? !!i.capture : !!i;\n        if (a && !Tt) return null;\n        var s = Kt(t);\n        if (s || (t[Ot] = s = new Mt(t)), (n = s.add(e, n, r, a, o)).proxy) return n;\n        if (r = function () {\n          var e = Ut,\n              n = Tt ? function (t) {\n            return e.call(n.src, n.listener, t);\n          } : function (t) {\n            if (!(t = e.call(n.src, n.listener, t))) return t;\n          };\n          return n;\n        }(), (n.proxy = r).src = t, r.listener = n, t.addEventListener) Et || (i = a), void 0 === i && (i = !1), t.addEventListener(e.toString(), r, i);else if (t.attachEvent) t.attachEvent(Vt(e.toString()), r);else {\n          if (!t.addListener || !t.removeListener) throw Error(\"addEventListener and attachEvent are unavailable.\");\n          t.addListener(r);\n        }\n        return n;\n      }\n\n      function qt(t) {\n        if (!N(t) && t && !t.X) {\n          var e = t.src;\n          if (e && e[Nt]) _t(e.c, t);else {\n            var n = t.type,\n                r = t.proxy;\n            e.removeEventListener ? e.removeEventListener(n, r, t.capture) : e.detachEvent ? e.detachEvent(Vt(n), r) : e.addListener && e.removeListener && e.removeListener(r), (n = Kt(e)) ? (_t(n, t), 0 == n.b && (n.src = null, e[Ot] = null)) : Rt(t);\n          }\n        }\n      }\n\n      function Vt(t) {\n        return t in Pt ? Pt[t] : Pt[t] = \"on\" + t;\n      }\n\n      function Bt(t, e) {\n        var n = t.listener,\n            r = t.da || t.src;\n        return t.Z && qt(t), n.call(r, e);\n      }\n\n      function Ut(t, e) {\n        return !!t.X || (Tt ? Bt(t, new Ct(e, this)) : Bt(t, e = new Ct(e || A(\"window.event\"), this)));\n      }\n\n      function Kt(t) {\n        return (t = t[Ot]) instanceof Mt ? t : null;\n      }\n\n      var Qt = \"__closure_events_fn_\" + (1e9 * Math.random() >>> 0);\n\n      function jt(e) {\n        return \"function\" == R(e) ? e : (e[Qt] || (e[Qt] = function (t) {\n          return e.handleEvent(t);\n        }), e[Qt]);\n      }\n\n      function Gt() {\n        K.call(this), this.c = new Mt(this), (this.J = this).B = null;\n      }\n\n      function Wt(t, e, n, r) {\n        if (!(e = t.c.a[String(e)])) return !0;\n        e = e.concat();\n\n        for (var i = !0, o = 0; o < e.length; ++o) {\n          var a = e[o];\n\n          if (a && !a.X && a.capture == n) {\n            var s = a.listener,\n                u = a.da || a.src;\n            a.Z && _t(t.c, a), i = !1 !== s.call(u, r) && i;\n          }\n        }\n\n        return i && 0 != r.Ia;\n      }\n\n      U(Gt, K), Gt.prototype[Nt] = !0, (S = Gt.prototype).addEventListener = function (t, e, n, r) {\n        xt(this, t, e, n, r);\n      }, S.removeEventListener = function (t, e, n, r) {\n        !function t(e, n, r, i, o) {\n          if (M(n)) for (var a = 0; a < n.length; a++) t(e, n[a], r, i, o);else i = L(i) ? !!i.capture : !!i, r = jt(r), e && e[Nt] ? (e = e.c, (n = String(n).toString()) in e.a && -1 < (r = Lt(a = e.a[n], r, i, o)) && (Rt(a[r]), Array.prototype.splice.call(a, r, 1), 0 == a.length && (delete e.a[n], e.b--))) : (e = e && Kt(e)) && (n = e.a[n.toString()], e = -1, n && (e = Lt(n, r, i, o)), (r = -1 < e ? n[e] : null) && qt(r));\n        }(this, t, e, n, r);\n      }, S.dispatchEvent = function (t) {\n        var e,\n            n = this.B;\n        if (n) for (e = []; n; n = n.B) e.push(n);\n        n = this.J;\n        var r = t.type || t;\n        if (D(t)) t = new It(t, n);else if (t instanceof It) t.target = t.target || n;else {\n          var i = t;\n          rt(t = new It(r, n), i);\n        }\n        if (i = !0, e) for (var o = e.length - 1; 0 <= o; o--) {\n          var a = t.a = e[o];\n          i = Wt(a, r, !0, t) && i;\n        }\n        if (i = Wt(a = t.a = n, r, !0, t) && i, i = Wt(a, r, !1, t) && i, e) for (o = 0; o < e.length; o++) i = Wt(a = t.a = e[o], r, !1, t) && i;\n        return i;\n      }, S.G = function () {\n        if (Gt.N.G.call(this), this.c) {\n          var t,\n              e = this.c;\n\n          for (t in e.a) {\n            for (var n = e.a[t], r = 0; r < n.length; r++) Rt(n[r]);\n\n            delete e.a[t], e.b--;\n          }\n        }\n\n        this.B = null;\n      }, S.za = function (t, e, n, r) {\n        return this.c.add(String(t), e, !1, n, r);\n      }, S.Aa = function (t, e, n, r) {\n        return this.c.add(String(t), e, !0, n, r);\n      };\n      var zt = C.JSON.stringify;\n\n      function Ht(t, e) {\n        this.c = t, this.f = e, this.b = 0, this.a = null;\n      }\n\n      function Yt() {\n        this.b = this.a = null;\n      }\n\n      Ht.prototype.get = function () {\n        if (0 < this.b) {\n          this.b--;\n          var t = this.a;\n          this.a = t.next, t.next = null;\n        } else t = this.c();\n\n        return t;\n      };\n\n      var Jt,\n          Xt = new Ht(function () {\n        return new Zt();\n      }, function (t) {\n        t.reset();\n      });\n\n      function Zt() {\n        this.next = this.b = this.a = null;\n      }\n\n      function $t(t) {\n        C.setTimeout(function () {\n          throw t;\n        }, 0);\n      }\n\n      function te(t, e) {\n        Jt || function () {\n          var t = C.Promise.resolve(void 0);\n\n          Jt = function () {\n            t.then(re);\n          };\n        }(), ee || (Jt(), ee = !0), ne.add(t, e);\n      }\n\n      Yt.prototype.add = function (t, e) {\n        var n = Xt.get();\n        n.set(t, e), this.b ? this.b.next = n : this.a = n, this.b = n;\n      }, Zt.prototype.set = function (t, e) {\n        this.a = t, this.b = e, this.next = null;\n      };\n      var ee = !(Zt.prototype.reset = function () {\n        this.next = this.b = this.a = null;\n      }),\n          ne = new Yt();\n\n      function re() {\n        for (var t; r = n = void 0, r = null, (n = ne).a && (r = n.a, n.a = n.a.next, n.a || (n.b = null), r.next = null), t = r;) {\n          try {\n            t.a.call(t.b);\n          } catch (t) {\n            $t(t);\n          }\n\n          var e = Xt;\n          e.f(t), e.b < 100 && (e.b++, t.next = e.a, e.a = t);\n        }\n\n        var n, r;\n        ee = !1;\n      }\n\n      function ie(t, e) {\n        Gt.call(this), this.b = t || 1, this.a = e || C, this.f = q(this.fb, this), this.g = B();\n      }\n\n      function oe(t) {\n        t.ba = !1, t.L && (t.a.clearTimeout(t.L), t.L = null);\n      }\n\n      function ae(t, e, n) {\n        if (\"function\" == R(t)) n && (t = q(t, n));else {\n          if (!t || \"function\" != typeof t.handleEvent) throw Error(\"Invalid listener argument\");\n          t = q(t.handleEvent, t);\n        }\n        return 2147483647 < Number(e) ? -1 : C.setTimeout(t, e || 0);\n      }\n\n      function se(t, e, n) {\n        K.call(this), this.f = null != n ? q(t, n) : t, this.c = e, this.b = q(this.$a, this), this.a = [];\n      }\n\n      function ue(t) {\n        t.U = ae(t.b, t.c), t.f.apply(null, t.a);\n      }\n\n      function ce(t) {\n        K.call(this), this.b = t, this.a = {};\n      }\n\n      U(ie, Gt), (S = ie.prototype).ba = !1, S.L = null, S.fb = function () {\n        if (this.ba) {\n          var t = B() - this.g;\n          0 < t && t < .8 * this.b ? this.L = this.a.setTimeout(this.f, this.b - t) : (this.L && (this.a.clearTimeout(this.L), this.L = null), this.dispatchEvent(\"tick\"), this.ba && (oe(this), this.start()));\n        }\n      }, S.start = function () {\n        this.ba = !0, this.L || (this.L = this.a.setTimeout(this.f, this.b), this.g = B());\n      }, S.G = function () {\n        ie.N.G.call(this), oe(this), delete this.a;\n      }, U(se, K), (S = se.prototype).ea = !1, S.U = null, S.Ta = function (t) {\n        this.a = arguments, this.U ? this.ea = !0 : ue(this);\n      }, S.G = function () {\n        se.N.G.call(this), this.U && (C.clearTimeout(this.U), this.U = null, this.ea = !1, this.a = []);\n      }, S.$a = function () {\n        this.U = null, this.ea && (this.ea = !1, ue(this));\n      }, U(ce, K);\n      var he = [];\n\n      function le(t, e, n, r) {\n        M(n) || (n && (he[0] = n.toString()), n = he);\n\n        for (var i = 0; i < n.length; i++) {\n          var o = xt(e, n[i], r || t.handleEvent, !1, t.b || t);\n          if (!o) break;\n          t.a[o.key] = o;\n        }\n      }\n\n      function fe(t) {\n        tt(t.a, function (t, e) {\n          this.a.hasOwnProperty(e) && qt(t);\n        }, t), t.a = {};\n      }\n\n      function pe() {}\n\n      ce.prototype.G = function () {\n        ce.N.G.call(this), fe(this);\n      }, ce.prototype.handleEvent = function () {\n        throw Error(\"EventHandler.handleEvent not implemented\");\n      };\n      var de = new Gt();\n\n      function me(t) {\n        It.call(this, \"serverreachability\", t);\n      }\n\n      function ye(t) {\n        de.dispatchEvent(new me(de, t));\n      }\n\n      function ge(t) {\n        It.call(this, \"statevent\", t);\n      }\n\n      function ve(t) {\n        de.dispatchEvent(new ge(de, t));\n      }\n\n      function be(t) {\n        It.call(this, \"timingevent\", t);\n      }\n\n      function we(t, e) {\n        if (\"function\" != R(t)) throw Error(\"Fn must not be null and must be a function\");\n        return C.setTimeout(function () {\n          t();\n        }, e);\n      }\n\n      U(me, It), U(ge, It), U(be, It);\n      var Te = {\n        NO_ERROR: 0,\n        gb: 1,\n        nb: 2,\n        mb: 3,\n        jb: 4,\n        lb: 5,\n        ob: 6,\n        La: 7,\n        TIMEOUT: 8,\n        rb: 9\n      },\n          Se = {\n        ib: \"complete\",\n        vb: \"success\",\n        Ma: \"error\",\n        La: \"abort\",\n        tb: \"ready\",\n        ub: \"readystatechange\",\n        TIMEOUT: \"timeout\",\n        pb: \"incrementaldata\",\n        sb: \"progress\",\n        kb: \"downloadprogress\",\n        wb: \"uploadprogress\"\n      };\n\n      function Ee() {}\n\n      function Ie(t) {\n        var e;\n        return (e = t.a) || (e = t.a = {}), e;\n      }\n\n      function Ce() {}\n\n      Ee.prototype.a = null;\n      var De,\n          Ne = {\n        OPEN: \"a\",\n        hb: \"b\",\n        Ma: \"c\",\n        qb: \"d\"\n      };\n\n      function Ae() {\n        It.call(this, \"d\");\n      }\n\n      function ke() {\n        It.call(this, \"c\");\n      }\n\n      function Re() {}\n\n      function Me(t, e, n) {\n        this.g = t, this.W = e, this.V = n || 1, this.I = new ce(this), this.O = _e, t = ht ? 125 : void 0, this.P = new ie(t), this.h = null, this.b = !1, this.l = this.D = this.f = this.F = this.v = this.R = this.i = null, this.j = [], this.a = null, this.A = 0, this.c = this.w = null, this.o = -1, this.m = !1, this.J = 0, this.B = null, this.s = this.S = this.H = !1;\n      }\n\n      U(Ae, It), U(ke, It), U(Re, Ee), De = new Re();\n      var _e = 45e3,\n          Le = {},\n          Oe = {};\n\n      function Pe(t, e, n) {\n        t.F = 1, t.f = sn($e(e)), t.l = n, t.H = !0, Fe(t, null);\n      }\n\n      function xe(t, e, n, r) {\n        t.F = 1, t.f = sn($e(e)), t.l = null, t.H = n, Fe(t, r);\n      }\n\n      function Fe(t, e) {\n        t.v = B(), Be(t), t.D = $e(t.f), an(t.D, \"t\", t.V), t.A = 0, t.a = t.g.$(t.g.Y() ? e : null), 0 < t.J && (t.B = new se(q(t.Ja, t, t.a), t.J)), le(t.I, t.a, \"readystatechange\", t.cb), e = t.h ? et(t.h) : {}, t.l ? (t.w || (t.w = \"POST\"), e[\"Content-Type\"] = \"application/x-www-form-urlencoded\", t.a.ca(t.D, t.w, t.l, e)) : (t.w = \"GET\", t.a.ca(t.D, t.w, null, e)), ye(1);\n      }\n\n      function qe(t, e, n) {\n        for (var r = !0; !t.m && t.A < n.length;) {\n          var i = Ve(t, n);\n\n          if (i == Oe) {\n            4 == e && (t.c = 4, ve(14), r = !1);\n            break;\n          }\n\n          if (i == Le) {\n            t.c = 4, ve(15), r = !1;\n            break;\n          }\n\n          Ge(t, i);\n        }\n\n        4 == e && 0 == n.length && (t.c = 1, ve(16), r = !1), t.b = t.b && r, r || (je(t), Qe(t));\n      }\n\n      function Ve(t, e) {\n        var n = t.A,\n            r = e.indexOf(\"\\n\", n);\n        return -1 == r ? Oe : (n = Number(e.substring(n, r)), isNaN(n) ? Le : (r += 1) + n > e.length ? Oe : (e = e.substr(r, n), t.A = r + n, e));\n      }\n\n      function Be(t) {\n        t.R = B() + t.O, Ue(t, t.O);\n      }\n\n      function Ue(t, e) {\n        if (null != t.i) throw Error(\"WatchDog timer not null\");\n        t.i = we(q(t.ab, t), e);\n      }\n\n      function Ke(t) {\n        t.i && (C.clearTimeout(t.i), t.i = null);\n      }\n\n      function Qe(t) {\n        t.g.Ca() || t.m || t.g.na(t);\n      }\n\n      function je(t) {\n        Ke(t);\n        var e = t.B;\n        e && \"function\" == typeof e.la && e.la(), t.B = null, oe(t.P), fe(t.I), t.a && (e = t.a, t.a = null, e.abort(), e.la());\n      }\n\n      function Ge(t, e) {\n        try {\n          t.g.Fa(t, e), ye(4);\n        } catch (t) {}\n      }\n\n      function We(t, e) {\n        if (t.forEach && \"function\" == typeof t.forEach) t.forEach(e, void 0);else if (_(t) || D(t)) j(t, e, void 0);else {\n          if (t.K && \"function\" == typeof t.K) var n = t.K();else if (t.C && \"function\" == typeof t.C) n = void 0;else if (_(t) || D(t)) {\n            n = [];\n\n            for (var r = t.length, i = 0; i < r; i++) n.push(i);\n          } else for (i in n = [], r = 0, t) n[r++] = i;\n\n          i = (r = function (t) {\n            if (t.C && \"function\" == typeof t.C) return t.C();\n            if (D(t)) return t.split(\"\");\n\n            if (_(t)) {\n              for (var e = [], n = t.length, r = 0; r < n; r++) e.push(t[r]);\n\n              return e;\n            }\n\n            for (r in e = [], n = 0, t) e[n++] = t[r];\n\n            return e;\n          }(t)).length;\n\n          for (var o = 0; o < i; o++) e.call(void 0, r[o], n && n[o], t);\n        }\n      }\n\n      function ze(t, e) {\n        this.b = {}, this.a = [], this.c = 0;\n        var n = arguments.length;\n\n        if (1 < n) {\n          if (n % 2) throw Error(\"Uneven number of arguments\");\n\n          for (var r = 0; r < n; r += 2) this.set(arguments[r], arguments[r + 1]);\n        } else if (t) if (t instanceof ze) for (n = t.K(), r = 0; r < n.length; r++) this.set(n[r], t.get(n[r]));else for (r in t) this.set(r, t[r]);\n      }\n\n      function He(t, e) {\n        Je(t.b, e) && (delete t.b[e], t.c--, t.a.length > 2 * t.c && Ye(t));\n      }\n\n      function Ye(t) {\n        if (t.c != t.a.length) {\n          for (var e = 0, n = 0; e < t.a.length;) {\n            var r = t.a[e];\n            Je(t.b, r) && (t.a[n++] = r), e++;\n          }\n\n          t.a.length = n;\n        }\n\n        if (t.c != t.a.length) {\n          var i = {};\n\n          for (n = e = 0; e < t.a.length;) Je(i, r = t.a[e]) || (i[t.a[n++] = r] = 1), e++;\n\n          t.a.length = n;\n        }\n      }\n\n      function Je(t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }\n\n      (S = Me.prototype).setTimeout = function (t) {\n        this.O = t;\n      }, S.cb = function (t) {\n        t = t.target;\n        var e = this.B;\n        e && 3 == $n(t) ? e.Ta() : this.Ja(t);\n      }, S.Ja = function (t) {\n        try {\n          if (t == this.a) t: {\n            var e = $n(this.a),\n                n = this.a.ya(),\n                r = this.a.T();\n\n            if (!(e < 3 || 3 == e && !ht && !this.a.aa())) {\n              this.m || 4 != e || 7 == n || ye(8 == n || r <= 0 ? 3 : 2), Ke(this);\n              var i = this.a.T();\n              this.o = i;\n              var o = this.a.aa();\n\n              if (this.b = 200 == i) {\n                if (this.S && !this.s) {\n                  e: {\n                    if (this.a) {\n                      var a = tr(this.a, \"X-HTTP-Initial-Response\");\n\n                      if (a && !z(a)) {\n                        var s = a;\n                        break e;\n                      }\n                    }\n\n                    s = null;\n                  }\n\n                  if (!s) {\n                    this.b = !1, this.c = 3, ve(12), je(this), Qe(this);\n                    break t;\n                  }\n\n                  this.s = !0, Ge(this, s);\n                }\n\n                this.H ? (qe(this, e, o), ht && this.b && 3 == e && (le(this.I, this.P, \"tick\", this.bb), this.P.start())) : Ge(this, o), 4 == e && je(this), this.b && !this.m && (4 == e ? this.g.na(this) : (this.b = !1, Be(this)));\n              } else 400 == i && 0 < o.indexOf(\"Unknown SID\") ? (this.c = 3, ve(12)) : (this.c = 0, ve(13)), je(this), Qe(this);\n            }\n          }\n        } catch (t) {}\n      }, S.bb = function () {\n        if (this.a) {\n          var t = $n(this.a),\n              e = this.a.aa();\n          this.A < e.length && (Ke(this), qe(this, t, e), this.b && 4 != t && Be(this));\n        }\n      }, S.cancel = function () {\n        this.m = !0, je(this);\n      }, S.ab = function () {\n        this.i = null;\n        var t = B();\n        0 <= t - this.R ? (2 != this.F && (ye(3), ve(17)), je(this), this.c = 2, Qe(this)) : Ue(this, this.R - t);\n      }, (S = ze.prototype).C = function () {\n        Ye(this);\n\n        for (var t = [], e = 0; e < this.a.length; e++) t.push(this.b[this.a[e]]);\n\n        return t;\n      }, S.K = function () {\n        return Ye(this), this.a.concat();\n      }, S.get = function (t, e) {\n        return Je(this.b, t) ? this.b[t] : e;\n      }, S.set = function (t, e) {\n        Je(this.b, t) || (this.c++, this.a.push(t)), this.b[t] = e;\n      }, S.forEach = function (t, e) {\n        for (var n = this.K(), r = 0; r < n.length; r++) {\n          var i = n[r],\n              o = this.get(i);\n          t.call(e, o, i, this);\n        }\n      };\n      var Xe = /^(?:([^:/?#.]+):)?(?:\\/\\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$/;\n\n      function Ze(t, e) {\n        var n;\n        this.b = this.j = this.f = \"\", this.i = null, this.g = this.a = \"\", this.h = !1, t instanceof Ze ? (this.h = void 0 !== e ? e : t.h, tn(this, t.f), this.j = t.j, en(this, t.b), nn(this, t.i), this.a = t.a, rn(this, Tn(t.c)), this.g = t.g) : t && (n = String(t).match(Xe)) ? (this.h = !!e, tn(this, n[1] || \"\", !0), this.j = un(n[2] || \"\"), en(this, n[3] || \"\", !0), nn(this, n[4]), this.a = un(n[5] || \"\", !0), rn(this, n[6] || \"\", !0), this.g = un(n[7] || \"\")) : (this.h = !!e, this.c = new yn(null, this.h));\n      }\n\n      function $e(t) {\n        return new Ze(t);\n      }\n\n      function tn(t, e, n) {\n        t.f = n ? un(e, !0) : e, t.f && (t.f = t.f.replace(/:$/, \"\"));\n      }\n\n      function en(t, e, n) {\n        t.b = n ? un(e, !0) : e;\n      }\n\n      function nn(t, e) {\n        if (e) {\n          if (e = Number(e), isNaN(e) || e < 0) throw Error(\"Bad port number \" + e);\n          t.i = e;\n        } else t.i = null;\n      }\n\n      function rn(t, e, n) {\n        e instanceof yn ? (t.c = e, function (t, e) {\n          e && !t.f && (gn(t), t.c = null, t.a.forEach(function (t, e) {\n            var n = e.toLowerCase();\n            e != n && (vn(this, e), wn(this, n, t));\n          }, t)), t.f = e;\n        }(t.c, t.h)) : (n || (e = cn(e, dn)), t.c = new yn(e, t.h));\n      }\n\n      function on(t, e, n) {\n        t.c.set(e, n);\n      }\n\n      function an(t, e, n) {\n        M(n) || (n = [String(n)]), wn(t.c, e, n);\n      }\n\n      function sn(t) {\n        return on(t, \"zx\", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ B()).toString(36)), t;\n      }\n\n      function un(t, e) {\n        return t ? e ? decodeURI(t.replace(/%25/g, \"%2525\")) : decodeURIComponent(t) : \"\";\n      }\n\n      function cn(t, e, n) {\n        return D(t) ? (t = encodeURI(t).replace(e, hn), n && (t = t.replace(/%25([0-9a-fA-F]{2})/g, \"%$1\")), t) : null;\n      }\n\n      function hn(t) {\n        return \"%\" + ((t = t.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & t).toString(16);\n      }\n\n      Ze.prototype.toString = function () {\n        var t = [],\n            e = this.f;\n        e && t.push(cn(e, ln, !0), \":\");\n        var n = this.b;\n        return !n && \"file\" != e || (t.push(\"//\"), (e = this.j) && t.push(cn(e, ln, !0), \"@\"), t.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g, \"%$1\")), null != (n = this.i) && t.push(\":\", String(n))), (n = this.a) && (this.b && \"/\" != n.charAt(0) && t.push(\"/\"), t.push(cn(n, \"/\" == n.charAt(0) ? pn : fn, !0))), (n = this.c.toString()) && t.push(\"?\", n), (n = this.g) && t.push(\"#\", cn(n, mn)), t.join(\"\");\n      }, Ze.prototype.resolve = function (t) {\n        var e = $e(this),\n            n = !!t.f;\n        n ? tn(e, t.f) : n = !!t.j, n ? e.j = t.j : n = !!t.b, n ? en(e, t.b) : n = null != t.i;\n        var r = t.a;\n        if (n) nn(e, t.i);else if (n = !!t.a) {\n          if (\"/\" != r.charAt(0)) if (this.b && !this.a) r = \"/\" + r;else {\n            var i = e.a.lastIndexOf(\"/\");\n            -1 != i && (r = e.a.substr(0, i + 1) + r);\n          }\n          if (\"..\" == (i = r) || \".\" == i) r = \"\";else if (J(i, \"./\") || J(i, \"/.\")) {\n            r = 0 == i.lastIndexOf(\"/\", 0), i = i.split(\"/\");\n\n            for (var o = [], a = 0; a < i.length;) {\n              var s = i[a++];\n              \".\" == s ? r && a == i.length && o.push(\"\") : \"..\" == s ? ((1 < o.length || 1 == o.length && \"\" != o[0]) && o.pop(), r && a == i.length && o.push(\"\")) : (o.push(s), r = !0);\n            }\n\n            r = o.join(\"/\");\n          } else r = i;\n        }\n        return n ? e.a = r : n = \"\" !== t.c.toString(), n ? rn(e, Tn(t.c)) : n = !!t.g, n && (e.g = t.g), e;\n      };\n      var ln = /[#\\/\\?@]/g,\n          fn = /[#\\?:]/g,\n          pn = /[#\\?]/g,\n          dn = /[#\\?@]/g,\n          mn = /#/g;\n\n      function yn(t, e) {\n        this.b = this.a = null, this.c = t || null, this.f = !!e;\n      }\n\n      function gn(n) {\n        n.a || (n.a = new ze(), n.b = 0, n.c && function (t, e) {\n          if (t) {\n            t = t.split(\"&\");\n\n            for (var n = 0; n < t.length; n++) {\n              var r = t[n].indexOf(\"=\"),\n                  i = null;\n\n              if (0 <= r) {\n                var o = t[n].substring(0, r);\n                i = t[n].substring(r + 1);\n              } else o = t[n];\n\n              e(o, i ? decodeURIComponent(i.replace(/\\+/g, \" \")) : \"\");\n            }\n          }\n        }(n.c, function (t, e) {\n          n.add(decodeURIComponent(t.replace(/\\+/g, \" \")), e);\n        }));\n      }\n\n      function vn(t, e) {\n        gn(t), e = Sn(t, e), Je(t.a.b, e) && (t.c = null, t.b -= t.a.get(e).length, He(t.a, e));\n      }\n\n      function bn(t, e) {\n        return gn(t), e = Sn(t, e), Je(t.a.b, e);\n      }\n\n      function wn(t, e, n) {\n        vn(t, e), 0 < n.length && (t.c = null, t.a.set(Sn(t, e), W(n)), t.b += n.length);\n      }\n\n      function Tn(t) {\n        var e = new yn();\n        return e.c = t.c, t.a && (e.a = new ze(t.a), e.b = t.b), e;\n      }\n\n      function Sn(t, e) {\n        return e = String(e), t.f && (e = e.toLowerCase()), e;\n      }\n\n      function En(t) {\n        this.a = t, this.b = this.h = null, this.g = !1, this.i = null, this.c = -1, this.l = this.f = null;\n      }\n\n      function In(t) {\n        var e = t.a.F.a;\n        if (null != e) ve(4), e ? (ve(10), fr(t.a, t, !1)) : (ve(11), fr(t.a, t, !0));else {\n          t.b = new Me(t, void 0, void 0), t.b.h = t.h, e = gr(e = t.a, e.Y() ? t.f : null, t.i), ve(4), an(e, \"TYPE\", \"xmlhttp\");\n          var n = t.a.j,\n              r = t.a.I;\n          n && r && on(e, n, r), xe(t.b, e, !1, t.f);\n        }\n      }\n\n      function Cn() {\n        this.a = this.b = null;\n      }\n\n      function Dn() {\n        this.a = new ze();\n      }\n\n      function Nn(t) {\n        var e = typeof t;\n        return \"object\" == e && t || \"function\" == e ? \"o\" + (t[O] || (t[O] = ++P)) : e.charAt(0) + t;\n      }\n\n      function An(t, e) {\n        this.b = t, this.a = e;\n      }\n\n      function kn(t) {\n        this.g = t || Rn, t = C.PerformanceNavigationTiming ? 0 < (t = C.performance.getEntriesByType(\"navigation\")).length && (\"hq\" == t[0].nextHopProtocol || \"h2\" == t[0].nextHopProtocol) : !!(C.ka && C.ka.Da && C.ka.Da() && C.ka.Da().yb), this.f = t ? this.g : 1, this.a = null, 1 < this.f && (this.a = new Dn()), this.b = null, this.c = [];\n      }\n\n      (S = yn.prototype).add = function (t, e) {\n        gn(this), this.c = null, t = Sn(this, t);\n        var n = this.a.get(t);\n        return n || this.a.set(t, n = []), n.push(e), this.b += 1, this;\n      }, S.forEach = function (n, r) {\n        gn(this), this.a.forEach(function (t, e) {\n          j(t, function (t) {\n            n.call(r, t, e, this);\n          }, this);\n        }, this);\n      }, S.K = function () {\n        gn(this);\n\n        for (var t = this.a.C(), e = this.a.K(), n = [], r = 0; r < e.length; r++) for (var i = t[r], o = 0; o < i.length; o++) n.push(e[r]);\n\n        return n;\n      }, S.C = function (t) {\n        gn(this);\n        var e = [];\n        if (D(t)) bn(this, t) && (e = G(e, this.a.get(Sn(this, t))));else {\n          t = this.a.C();\n\n          for (var n = 0; n < t.length; n++) e = G(e, t[n]);\n        }\n        return e;\n      }, S.set = function (t, e) {\n        return gn(this), this.c = null, bn(this, t = Sn(this, t)) && (this.b -= this.a.get(t).length), this.a.set(t, [e]), this.b += 1, this;\n      }, S.get = function (t, e) {\n        return t && 0 < (t = this.C(t)).length ? String(t[0]) : e;\n      }, S.toString = function () {\n        if (this.c) return this.c;\n        if (!this.a) return \"\";\n\n        for (var t = [], e = this.a.K(), n = 0; n < e.length; n++) {\n          var r = e[n],\n              i = encodeURIComponent(String(r));\n          r = this.C(r);\n\n          for (var o = 0; o < r.length; o++) {\n            var a = i;\n            \"\" !== r[o] && (a += \"=\" + encodeURIComponent(String(r[o]))), t.push(a);\n          }\n        }\n\n        return this.c = t.join(\"&\");\n      }, U(function () {}, function () {}), (S = En.prototype).M = null, S.$ = function (t) {\n        return this.a.$(t);\n      }, S.abort = function () {\n        this.b && (this.b.cancel(), this.b = null), this.c = -1;\n      }, S.Ca = function () {\n        return !1;\n      }, S.Fa = function (t, e) {\n        if (this.c = t.o, 0 == this.M) {\n          if (!this.a.o && (t = t.a)) {\n            var n = tr(t, \"X-Client-Wire-Protocol\");\n            this.l = n || null, this.a.j && (t = tr(t, \"X-HTTP-Session-Id\")) && (this.a.I = t);\n          }\n\n          if (e) {\n            try {\n              var r = this.a.ja.a.parse(e);\n            } catch (t) {\n              return (e = this.a).m = this.c, void mr(e, 2);\n            }\n\n            this.f = r[0];\n          } else (e = this.a).m = this.c, mr(e, 2);\n        } else 1 == this.M && (this.g ? ve(6) : \"11111\" == e ? (ve(5), this.g = !0, (!ut || 10 <= Number(gt)) && (this.c = 200, this.b.cancel(), ve(11), fr(this.a, this, !0))) : (ve(7), this.g = !1));\n      }, S.na = function () {\n        if (this.c = this.b.o, this.b.b) 0 == this.M ? (this.M = 1, In(this)) : 1 == this.M && (this.g ? (ve(11), fr(this.a, this, !0)) : (ve(10), fr(this.a, this, !1)));else {\n          0 == this.M ? ve(8) : 1 == this.M && ve(9);\n          var t = this.a;\n          t.m = this.c, mr(t, 2);\n        }\n      }, S.Y = function () {\n        return this.a.Y();\n      }, S.ma = function () {\n        return this.a.ma();\n      }, Dn.prototype.add = function (t) {\n        this.a.set(Nn(t), t);\n      }, Dn.prototype.C = function () {\n        return this.a.C();\n      };\n      var Rn = 10;\n\n      function Mn(t, e) {\n        !t.a && (J(e, \"spdy\") || J(e, \"quic\") || J(e, \"h2\")) && (t.f = t.g, t.a = new Dn(), t.b && (Pn(t, t.b), t.b = null));\n      }\n\n      function _n(t) {\n        return !!t.b || !!t.a && t.a.a.c >= t.f;\n      }\n\n      function Ln(t) {\n        return t.b ? 1 : t.a ? t.a.a.c : 0;\n      }\n\n      function On(t, e) {\n        return t = t.b ? t.b == e : !!t.a && (e = Nn(e), Je(t.a.a.b, e));\n      }\n\n      function Pn(t, e) {\n        t.a ? t.a.add(e) : t.b = e;\n      }\n\n      function xn(t, e) {\n        var n;\n        t.b && t.b == e ? t.b = null : ((n = t.a) && (n = Nn(e), n = Je(t.a.a.b, n)), n && He(t.a.a, Nn(e)));\n      }\n\n      function Fn(t) {\n        if (null != t.b) return t.c.concat(t.b.j);\n        if (null == t.a || 0 == t.a.a.c) return W(t.c);\n        var e = t.c;\n        return j(t.a.C(), function (t) {\n          e = e.concat(t.j);\n        }), e;\n      }\n\n      function qn() {}\n\n      function Vn() {\n        this.a = new qn();\n      }\n\n      function Bn(t, r, e) {\n        var i = e || \"\";\n\n        try {\n          We(t, function (t, e) {\n            var n = t;\n            L(t) && (n = zt(t)), r.push(i + e + \"=\" + encodeURIComponent(n));\n          });\n        } catch (t) {\n          throw r.push(i + \"type=\" + encodeURIComponent(\"_badmap\")), t;\n        }\n      }\n\n      function Un(t, e, n, r, i) {\n        try {\n          e.onload = null, e.onerror = null, e.onabort = null, e.ontimeout = null, i(r);\n        } catch (t) {}\n      }\n\n      kn.prototype.cancel = function () {\n        this.c = Fn(this), this.b ? (this.b.cancel(), this.b = null) : this.a && 0 != this.a.a.c && (j(this.a.C(), function (t) {\n          t.cancel();\n        }), function (t) {\n          t.b = {}, t.a.length = 0, t.c = 0;\n        }(this.a.a));\n      }, qn.prototype.stringify = function (t) {\n        return C.JSON.stringify(t, void 0);\n      }, qn.prototype.parse = function (t) {\n        return C.JSON.parse(t, void 0);\n      };\n      var Kn = C.JSON.parse;\n\n      function Qn(t) {\n        Gt.call(this), this.headers = new ze(), this.H = t || null, this.b = !1, this.s = this.a = null, this.A = \"\", this.h = 0, this.f = \"\", this.g = this.w = this.l = this.v = !1, this.o = 0, this.m = null, this.I = jn, this.D = this.F = !1;\n      }\n\n      U(Qn, Gt);\n      var jn = \"\",\n          Gn = /^https?$/i,\n          Wn = [\"POST\", \"PUT\"];\n\n      function zn(t) {\n        return \"content-type\" == t.toLowerCase();\n      }\n\n      function Hn(t, e) {\n        t.b = !1, t.a && (t.g = !0, t.a.abort(), t.g = !1), t.f = e, t.h = 5, Yn(t), Xn(t);\n      }\n\n      function Yn(t) {\n        t.v || (t.v = !0, t.dispatchEvent(\"complete\"), t.dispatchEvent(\"error\"));\n      }\n\n      function Jn(t) {\n        if (t.b && void 0 !== I && (!t.s[1] || 4 != $n(t) || 2 != t.T())) if (t.l && 4 == $n(t)) ae(t.Ea, 0, t);else if (t.dispatchEvent(\"readystatechange\"), 4 == $n(t)) {\n          t.b = !1;\n\n          try {\n            var e,\n                n = t.T();\n\n            t: switch (n) {\n              case 200:\n              case 201:\n              case 202:\n              case 204:\n              case 206:\n              case 304:\n              case 1223:\n                var r = !0;\n                break t;\n\n              default:\n                r = !1;\n            }\n\n            if (!(e = r)) {\n              var i;\n\n              if (i = 0 === n) {\n                var o = String(t.A).match(Xe)[1] || null;\n\n                if (!o && C.self && C.self.location) {\n                  var a = C.self.location.protocol;\n                  o = a.substr(0, a.length - 1);\n                }\n\n                i = !Gn.test(o ? o.toLowerCase() : \"\");\n              }\n\n              e = i;\n            }\n\n            if (e) t.dispatchEvent(\"complete\"), t.dispatchEvent(\"success\");else {\n              t.h = 6;\n\n              try {\n                var s = 2 < $n(t) ? t.a.statusText : \"\";\n              } catch (t) {\n                s = \"\";\n              }\n\n              t.f = s + \" [\" + t.T() + \"]\", Yn(t);\n            }\n          } finally {\n            Xn(t);\n          }\n        }\n      }\n\n      function Xn(t, e) {\n        if (t.a) {\n          Zn(t);\n          var n = t.a,\n              r = t.s[0] ? k : null;\n          t.a = null, t.s = null, e || t.dispatchEvent(\"ready\");\n\n          try {\n            n.onreadystatechange = r;\n          } catch (t) {}\n        }\n      }\n\n      function Zn(t) {\n        t.a && t.D && (t.a.ontimeout = null), t.m && (C.clearTimeout(t.m), t.m = null);\n      }\n\n      function $n(t) {\n        return t.a ? t.a.readyState : 0;\n      }\n\n      function tr(t, e) {\n        return t.a ? t.a.getResponseHeader(e) : null;\n      }\n\n      function er(t, e, n) {\n        t: {\n          for (r in n) {\n            var r = !1;\n            break t;\n          }\n\n          r = !0;\n        }\n\n        if (r) return t;\n\n        if (n = function (t) {\n          var n = \"\";\n          return tt(t, function (t, e) {\n            n += e, n += \":\", n += t, n += \"\\r\\n\";\n          }), n;\n        }(n), D(t)) {\n          if (e = encodeURIComponent(String(e)), e += n = null != n ? \"=\" + encodeURIComponent(String(n)) : \"\") {\n            if ((n = t.indexOf(\"#\")) < 0 && (n = t.length), (r = t.indexOf(\"?\")) < 0 || n < r) {\n              r = n;\n              var i = \"\";\n            } else i = t.substring(r + 1, n);\n\n            n = (t = [t.substr(0, r), i, t.substr(n)])[1], t[1] = e ? n ? n + \"&\" + e : e : n, t = t[0] + (t[1] ? \"?\" + t[1] : \"\") + t[2];\n          }\n\n          return t;\n        }\n\n        return on(t, e, n), t;\n      }\n\n      function nr(t) {\n        this.f = [], this.F = new Cn(), this.ga = this.pa = this.B = this.ha = this.a = this.I = this.j = this.V = this.g = this.J = this.i = null, this.Qa = this.P = 0, this.Oa = !!A(\"internalChannelParams.failFast\", t), this.ia = this.w = this.s = this.l = this.h = this.c = null, this.oa = !0, this.m = this.ra = this.O = -1, this.S = this.v = this.A = 0, this.Na = A(\"internalChannelParams.baseRetryDelayMs\", t) || 5e3, this.Ra = A(\"internalChannelParams.retryDelaySeedMs\", t) || 1e4, this.Pa = A(\"internalChannelParams.forwardChannelMaxRetries\", t) || 2, this.qa = A(\"internalChannelParams.forwardChannelRequestTimeoutMs\", t) || 2e4, this.Ka = t && t.zb || void 0, this.D = void 0, this.R = t && t.supportsCrossDomainXhr || !1, this.H = \"\", this.b = new kn(t && t.concurrentRequestLimit), this.ja = new Vn(), this.o = !t || void 0 === t.backgroundChannelTest || t.backgroundChannelTest, (this.W = t && t.fastHandshake || !1) && !this.o && (this.o = !0), t && t.forceLongPolling && (this.oa = !1), this.fa = void 0;\n      }\n\n      function rr(t) {\n        if (ir(t), 3 == t.u) {\n          var e = t.P++,\n              n = $e(t.B);\n          on(n, \"SID\", t.H), on(n, \"RID\", e), on(n, \"TYPE\", \"terminate\"), ur(t, n), (e = new Me(t, e, void 0)).F = 2, e.f = sn($e(n)), n = !1, C.navigator && C.navigator.sendBeacon && (n = C.navigator.sendBeacon(e.f.toString(), \"\")), !n && C.Image && (new Image().src = e.f, n = !0), n || (e.a = e.g.$(null), e.a.ca(e.f)), e.v = B(), Be(e);\n        }\n\n        yr(t);\n      }\n\n      function ir(t) {\n        t.w && (t.w.abort(), t.w = null), t.a && (t.a.cancel(), t.a = null), t.l && (C.clearTimeout(t.l), t.l = null), pr(t), t.b.cancel(), t.h && (N(t.h) && C.clearTimeout(t.h), t.h = null);\n      }\n\n      function or(t, e) {\n        t.f.push(new An(t.Qa++, e)), 3 == t.u && ar(t);\n      }\n\n      function ar(t) {\n        _n(t.b) || t.h || (t.h = !0, te(t.Ha, t), t.A = 0);\n      }\n\n      function sr(t, e) {\n        var n;\n        n = e ? e.W : t.P++;\n        var r = $e(t.B);\n        on(r, \"SID\", t.H), on(r, \"RID\", n), on(r, \"AID\", t.O), ur(t, r), t.g && t.i && er(r, t.g, t.i), n = new Me(t, n, t.A + 1), null === t.g && (n.h = t.i), e && (t.f = e.j.concat(t.f)), e = cr(t, n, 1e3), n.setTimeout(Math.round(.5 * t.qa) + Math.round(.5 * t.qa * Math.random())), Pn(t.b, n), Pe(n, r, e);\n      }\n\n      function ur(t, n) {\n        t.c && We({}, function (t, e) {\n          on(n, e, t);\n        });\n      }\n\n      function cr(t, e, n) {\n        n = Math.min(t.f.length, n);\n        var r = t.c ? q(t.c.Sa, t.c, t) : null;\n\n        t: for (var i = t.f, o = -1;;) {\n          var a = [\"count=\" + n];\n          -1 == o ? 0 < n ? (o = i[0].b, a.push(\"ofs=\" + o)) : o = 0 : a.push(\"ofs=\" + o);\n\n          for (var s = !0, u = 0; u < n; u++) {\n            var c = i[u].b,\n                h = i[u].a;\n            if ((c -= o) < 0) o = Math.max(0, i[u].b - 100), s = !1;else try {\n              Bn(h, a, \"req\" + c + \"_\");\n            } catch (t) {\n              r && r(h);\n            }\n          }\n\n          if (s) {\n            r = a.join(\"&\");\n            break t;\n          }\n        }\n\n        return t = t.f.splice(0, n), e.j = t, r;\n      }\n\n      function hr(t) {\n        t.a || t.l || (t.S = 1, te(t.Ga, t), t.v = 0);\n      }\n\n      function lr(t) {\n        return !(t.a || t.l || 3 <= t.v) && (t.S++, t.l = we(q(t.Ga, t), dr(t, t.v)), t.v++, !0);\n      }\n\n      function fr(t, e, n) {\n        var r = e.l;\n        r && Mn(t.b, r), t.ia = t.oa && n, t.m = e.c, t.B = gr(t, null, t.ha), ar(t);\n      }\n\n      function pr(t) {\n        null != t.s && (C.clearTimeout(t.s), t.s = null);\n      }\n\n      function dr(t, e) {\n        var n = t.Na + Math.floor(Math.random() * t.Ra);\n        return t.ma() || (n *= 2), n * e;\n      }\n\n      function mr(t, e) {\n        if (2 == e) {\n          var n = null;\n          t.c && (n = null);\n          var r = q(t.eb, t);\n          n || (n = new Ze(\"//www.google.com/images/cleardot.gif\"), C.location && \"http\" == C.location.protocol || tn(n, \"https\"), sn(n)), function (t, e) {\n            var n = new pe();\n\n            if (C.Image) {\n              var r = new Image();\n              r.onload = V(Un, n, r, \"TestLoadImage: loaded\", !0, e), r.onerror = V(Un, n, r, \"TestLoadImage: error\", !1, e), r.onabort = V(Un, n, r, \"TestLoadImage: abort\", !1, e), r.ontimeout = V(Un, n, r, \"TestLoadImage: timeout\", !1, e), C.setTimeout(function () {\n                r.ontimeout && r.ontimeout();\n              }, 1e4), r.src = t;\n            } else e(!1);\n          }(n.toString(), r);\n        } else ve(2);\n\n        t.u = 0, t.c && t.c.ta(e), yr(t), ir(t);\n      }\n\n      function yr(t) {\n        t.u = 0, t.m = -1, t.c && (0 == Fn(t.b).length && 0 == t.f.length || (t.b.c.length = 0, W(t.f), t.f.length = 0), t.c.sa());\n      }\n\n      function gr(t, e, n) {\n        var r = function (t) {\n          return t instanceof Ze ? $e(t) : new Ze(t, void 0);\n        }(n);\n\n        if (\"\" != r.b) e && en(r, e + \".\" + r.b), nn(r, r.i);else {\n          var i,\n              o = C.location;\n          i = e ? e + \".\" + o.hostname : o.hostname, r = function (t, e, n, r) {\n            var i = new Ze(null, void 0);\n            return t && tn(i, t), e && en(i, e), n && nn(i, n), r && (i.a = r), i;\n          }(o.protocol, i, +o.port, n);\n        }\n        return t.V && tt(t.V, function (t, e) {\n          on(r, e, t);\n        }), e = t.j, n = t.I, e && n && on(r, e, n), on(r, \"VER\", t.wa), ur(t, r), r;\n      }\n\n      function vr() {}\n\n      function br() {\n        if (ut && !(10 <= Number(gt))) throw Error(\"Environmental error: no available transport.\");\n      }\n\n      function wr(t, e) {\n        Gt.call(this), this.a = new nr(e), this.g = t, this.m = e && e.testUrl ? e.testUrl : function (t) {\n          for (var e = t, n = 1; n < arguments.length; n++) {\n            var r,\n                i = arguments[n];\n            if (0 == i.lastIndexOf(\"/\", 0)) e = i;else (r = \"\" == e) || (r = 0 <= (r = e.length - 1) && e.indexOf(\"/\", r) == r), e += r ? i : \"/\" + i;\n          }\n\n          return e;\n        }(this.g, \"test\"), this.b = e && e.messageUrlParams || null, t = e && e.messageHeaders || null, e && e.clientProtocolHeaderRequired && (t ? t[\"X-Client-Protocol\"] = \"webchannel\" : t = {\n          \"X-Client-Protocol\": \"webchannel\"\n        }), this.a.i = t, t = e && e.initMessageHeaders || null, e && e.messageContentType && (t ? t[\"X-WebChannel-Content-Type\"] = e.messageContentType : t = {\n          \"X-WebChannel-Content-Type\": e.messageContentType\n        }), e && e.xa && (t ? t[\"X-WebChannel-Client-Profile\"] = e.xa : t = {\n          \"X-WebChannel-Client-Profile\": e.xa\n        }), this.a.J = t, (t = e && e.httpHeadersOverwriteParam) && !z(t) && (this.a.g = t), this.l = e && e.supportsCrossDomainXhr || !1, this.h = e && e.sendRawJson || !1, (e = e && e.httpSessionIdParam) && !z(e) && (this.a.j = e, null !== (t = this.b) && e in t && e in (t = this.b) && delete t[e]), this.f = new Er(this);\n      }\n\n      function Tr(t) {\n        Ae.call(this);\n        var e = t.__sm__;\n\n        if (e) {\n          t: {\n            for (var n in e) {\n              t = n;\n              break t;\n            }\n\n            t = void 0;\n          }\n\n          (this.c = t) ? (t = this.c, this.data = null !== e && t in e ? e[t] : void 0) : this.data = e;\n        } else this.data = t;\n      }\n\n      function Sr() {\n        ke.call(this), this.status = 1;\n      }\n\n      function Er(t) {\n        this.a = t;\n      }\n\n      (S = Qn.prototype).ca = function (t, e, n, r) {\n        if (this.a) throw Error(\"[goog.net.XhrIo] Object is active with another request=\" + this.A + \"; newUri=\" + t);\n        e = e ? e.toUpperCase() : \"GET\", this.A = t, this.f = \"\", this.h = 0, this.v = !1, this.b = !0, this.a = new XMLHttpRequest(), this.s = this.H ? Ie(this.H) : Ie(De), this.a.onreadystatechange = q(this.Ea, this);\n\n        try {\n          this.w = !0, this.a.open(e, String(t), !0), this.w = !1;\n        } catch (t) {\n          return void Hn(this, t);\n        }\n\n        t = n || \"\";\n        var i = new ze(this.headers);\n        r && We(r, function (t, e) {\n          i.set(e, t);\n        }), r = function (t) {\n          t: {\n            for (var e = zn, n = t.length, r = D(t) ? t.split(\"\") : t, i = 0; i < n; i++) if (i in r && e.call(void 0, r[i], i, t)) {\n              e = i;\n              break t;\n            }\n\n            e = -1;\n          }\n\n          return e < 0 ? null : D(t) ? t.charAt(e) : t[e];\n        }(i.K()), n = C.FormData && t instanceof C.FormData, 0 <= Q(Wn, e) && !r && !n && i.set(\"Content-Type\", \"application/x-www-form-urlencoded;charset=utf-8\"), i.forEach(function (t, e) {\n          this.a.setRequestHeader(e, t);\n        }, this), this.I && (this.a.responseType = this.I), \"withCredentials\" in this.a && this.a.withCredentials !== this.F && (this.a.withCredentials = this.F);\n\n        try {\n          Zn(this), 0 < this.o && ((this.D = function (t) {\n            return ut && bt(9) && N(t.timeout) && void 0 !== t.ontimeout;\n          }(this.a)) ? (this.a.timeout = this.o, this.a.ontimeout = q(this.Ba, this)) : this.m = ae(this.Ba, this.o, this)), this.l = !0, this.a.send(t), this.l = !1;\n        } catch (t) {\n          Hn(this, t);\n        }\n      }, S.Ba = function () {\n        void 0 !== I && this.a && (this.f = \"Timed out after \" + this.o + \"ms, aborting\", this.h = 8, this.dispatchEvent(\"timeout\"), this.abort(8));\n      }, S.abort = function (t) {\n        this.a && this.b && (this.b = !1, this.g = !0, this.a.abort(), this.g = !1, this.h = t || 7, this.dispatchEvent(\"complete\"), this.dispatchEvent(\"abort\"), Xn(this));\n      }, S.G = function () {\n        this.a && (this.b && (this.b = !1, this.g = !0, this.a.abort(), this.g = !1), Xn(this, !0)), Qn.N.G.call(this);\n      }, S.Ea = function () {\n        this.j || (this.w || this.l || this.g ? Jn(this) : this.Za());\n      }, S.Za = function () {\n        Jn(this);\n      }, S.T = function () {\n        try {\n          return 2 < $n(this) ? this.a.status : -1;\n        } catch (t) {\n          return -1;\n        }\n      }, S.aa = function () {\n        try {\n          return this.a ? this.a.responseText : \"\";\n        } catch (t) {\n          return \"\";\n        }\n      }, S.Ua = function (t) {\n        if (this.a) {\n          var e = this.a.responseText;\n          return t && 0 == e.indexOf(t) && (e = e.substring(t.length)), Kn(e);\n        }\n      }, S.ya = function () {\n        return this.h;\n      }, S.Xa = function () {\n        return D(this.f) ? this.f : String(this.f);\n      }, (S = nr.prototype).wa = 8, S.u = 1, S.Ca = function () {\n        return 0 == this.u;\n      }, S.Ha = function (t) {\n        if (this.h) if (this.h = null, 1 == this.u) {\n          if (!t) {\n            this.P = Math.floor(1e5 * Math.random()), t = this.P++;\n            var e,\n                n = new Me(this, t, void 0),\n                r = this.i;\n            if (this.J && (r ? rt(r = et(r), this.J) : r = this.J), null === this.g && (n.h = r), this.W) t: {\n              for (var i = e = 0; i < this.f.length; i++) {\n                var o = this.f[i];\n                if (void 0 === (o = \"__data__\" in o.a && D(o = o.a.__data__) ? o.length : void 0)) break;\n\n                if (4096 < (e += o)) {\n                  e = i;\n                  break t;\n                }\n\n                if (4096 === e || i === this.f.length - 1) {\n                  e = i + 1;\n                  break t;\n                }\n              }\n\n              e = 1e3;\n            } else e = 1e3;\n            e = cr(this, n, e), on(i = $e(this.B), \"RID\", t), on(i, \"CVER\", 22), this.o && this.j && on(i, \"X-HTTP-Session-Id\", this.j), ur(this, i), this.g && r && er(i, this.g, r), Pn(this.b, n), this.W ? (on(i, \"$req\", e), on(i, \"SID\", \"null\"), n.S = !0, Pe(n, i, null)) : Pe(n, i, e), this.u = 2;\n          }\n        } else 3 == this.u && (t ? sr(this, t) : 0 == this.f.length || _n(this.b) || sr(this));\n      }, S.Ga = function () {\n        this.l = null, this.a = new Me(this, \"rpc\", this.S), null === this.g && (this.a.h = this.i), this.a.J = 0;\n        var t = $e(this.pa);\n        on(t, \"RID\", \"rpc\"), on(t, \"SID\", this.H), on(t, \"CI\", this.ia ? \"0\" : \"1\"), on(t, \"AID\", this.O), ur(this, t), on(t, \"TYPE\", \"xmlhttp\"), this.g && this.i && er(t, this.g, this.i), this.D && this.a.setTimeout(this.D), xe(this.a, t, !0, this.ga);\n      }, S.Fa = function (t, e) {\n        if (0 != this.u && (this.a == t || On(this.b, t))) if (this.m = t.o, !t.s && On(this.b, t) && 3 == this.u) {\n          try {\n            var n = this.ja.a.parse(e);\n          } catch (t) {\n            n = null;\n          }\n\n          if (M(n) && 3 == n.length) {\n            if (0 == (e = n)[0]) {\n              t: if (!this.l) {\n                if (this.a) {\n                  if (!(this.a.v + 3e3 < t.v)) break t;\n                  pr(this), this.a.cancel(), this.a = null;\n                }\n\n                lr(this), ve(18);\n              }\n            } else this.ra = e[1], 0 < this.ra - this.O && e[2] < 37500 && this.ia && 0 == this.v && !this.s && (this.s = we(q(this.Ya, this), 6e3));\n\n            if (Ln(this.b) <= 1 && this.fa) {\n              try {\n                this.fa();\n              } catch (t) {}\n\n              this.fa = void 0;\n            }\n          } else mr(this, 11);\n        } else if (!t.s && this.a != t || pr(this), !z(e)) for (e = n = this.ja.a.parse(e), n = 0; n < e.length; n++) {\n          var r = e[n];\n          if (this.O = r[0], r = r[1], 2 == this.u) {\n            if (\"c\" == r[0]) {\n              this.H = r[1], this.ga = r[2];\n              var i = r[3];\n              null != i && (this.wa = i), null != (r = r[5]) && N(r) && 0 < r && (this.D = 1.5 * r), this.o && (r = t.a) && ((i = tr(r, \"X-Client-Wire-Protocol\")) && Mn(this.b, i), this.j && (r = tr(r, \"X-HTTP-Session-Id\"))) && (this.I = r, on(this.B, this.j, r)), this.u = 3, this.c && this.c.va(), r = t, this.pa = gr(this, this.Y() ? this.ga : null, this.ha), r.s ? (xn(this.b, r), (i = this.D) && r.setTimeout(i), r.i && (Ke(r), Be(r)), this.a = r) : hr(this), 0 < this.f.length && ar(this);\n            } else \"stop\" != r[0] && \"close\" != r[0] || mr(this, 7);\n          } else 3 == this.u && (\"stop\" == r[0] || \"close\" == r[0] ? \"stop\" == r[0] ? mr(this, 7) : rr(this) : \"noop\" != r[0] && this.c && this.c.ua(r), this.v = 0);\n        }\n      }, S.Ya = function () {\n        null != this.s && (this.s = null, this.a.cancel(), this.a = null, lr(this), ve(19));\n      }, S.na = function (t) {\n        var e = null;\n\n        if (this.a == t) {\n          pr(this), this.a = null;\n          var n = 2;\n        } else {\n          if (!On(this.b, t)) return;\n          e = t.j, xn(this.b, t), n = 1;\n        }\n\n        if (this.m = t.o, 0 != this.u) if (t.b) 1 == n ? (e = B() - t.v, de.dispatchEvent(new be(de, t.l ? t.l.length : 0, e, this.A)), ar(this)) : hr(this);else {\n          var r = t.c;\n          if (3 == r || 0 == r && 0 < this.m || !(1 == n && function (t, e) {\n            return !(Ln(t.b) >= t.b.f - (t.h ? 1 : 0)) && (t.h ? (t.f = e.j.concat(t.f), !0) : !(1 == t.u || 2 == t.u || t.A >= (t.Oa ? 0 : t.Pa)) && (t.h = we(q(t.Ha, t, e), dr(t, t.A)), t.A++, !0));\n          }(this, t) || 2 == n && lr(this))) switch (e && 0 < e.length && (t = this.b, t.c = t.c.concat(e)), r) {\n            case 1:\n              mr(this, 5);\n              break;\n\n            case 4:\n              mr(this, 10);\n              break;\n\n            case 3:\n              mr(this, 6);\n              break;\n\n            default:\n              mr(this, 2);\n          }\n        }\n      }, S.eb = function (t) {\n        ve(t ? 2 : 1);\n      }, S.$ = function (t) {\n        if (t && !this.R) throw Error(\"Can't create secondary domain capable XhrIo object.\");\n        return (t = new Qn(this.Ka)).F = this.R, t;\n      }, S.ma = function () {\n        return !!this.c && !0;\n      }, S.Y = function () {\n        return this.R;\n      }, (S = vr.prototype).va = function () {}, S.ua = function () {}, S.ta = function () {}, S.sa = function () {}, S.Sa = function () {}, br.prototype.a = function (t, e) {\n        return new wr(t, e);\n      }, U(wr, Gt), (S = wr.prototype).addEventListener = function (t, e, n, r) {\n        wr.N.addEventListener.call(this, t, e, n, r);\n      }, S.removeEventListener = function (t, e, n, r) {\n        wr.N.removeEventListener.call(this, t, e, n, r);\n      }, S.Va = function () {\n        this.a.c = this.f, this.l && (this.a.R = !0);\n        var t = this.a,\n            e = this.m,\n            n = this.g,\n            r = this.b || void 0;\n        ve(0), t.ha = n, t.V = r || {}, t.o && (t.F.b = [], t.F.a = !1), t.w = new En(t), null === t.g && (t.w.h = t.i), n = e, t.g && t.i && (n = er(e, t.g, t.i)), (t = t.w).i = n, e = gr(t.a, null, t.i), ve(3), null != (n = t.a.F.b) ? (t.f = n[0], t.M = 1, In(t)) : (an(e, \"MODE\", \"init\"), !t.a.o && t.a.j && an(e, \"X-HTTP-Session-Id\", t.a.j), t.b = new Me(t, void 0, void 0), t.b.h = t.h, xe(t.b, e, !1, null), t.M = 0);\n      }, S.close = function () {\n        rr(this.a);\n      }, S.Wa = function (t) {\n        if (D(t)) {\n          var e = {};\n          e.__data__ = t, or(this.a, e);\n        } else this.h ? ((e = {}).__data__ = zt(t), or(this.a, e)) : or(this.a, t);\n      }, S.G = function () {\n        this.a.c = null, delete this.f, rr(this.a), delete this.a, wr.N.G.call(this);\n      }, U(Tr, Ae), U(Sr, ke), U(Er, vr), Er.prototype.va = function () {\n        this.a.dispatchEvent(\"a\");\n      }, Er.prototype.ua = function (t) {\n        this.a.dispatchEvent(new Tr(t));\n      }, Er.prototype.ta = function (t) {\n        this.a.dispatchEvent(new Sr(t));\n      }, Er.prototype.sa = function () {\n        this.a.dispatchEvent(\"b\");\n      };\n      var Ir = V(function (t, e) {\n        function n() {}\n\n        n.prototype = t.prototype;\n        var r = new n();\n        return t.apply(r, Array.prototype.slice.call(arguments, 1)), r;\n      }, br);\n      br.prototype.createWebChannel = br.prototype.a, wr.prototype.send = wr.prototype.Wa, wr.prototype.open = wr.prototype.Va, wr.prototype.close = wr.prototype.close, Te.NO_ERROR = 0, Te.TIMEOUT = 8, Te.HTTP_ERROR = 6, Se.COMPLETE = \"complete\", (Ce.EventType = Ne).OPEN = \"a\", Ne.CLOSE = \"b\", Ne.ERROR = \"c\", Ne.MESSAGE = \"d\", Gt.prototype.listen = Gt.prototype.za, Qn.prototype.listenOnce = Qn.prototype.Aa, Qn.prototype.getLastError = Qn.prototype.Xa, Qn.prototype.getLastErrorCode = Qn.prototype.ya, Qn.prototype.getStatus = Qn.prototype.T, Qn.prototype.getResponseJson = Qn.prototype.Ua, Qn.prototype.getResponseText = Qn.prototype.aa, Qn.prototype.send = Qn.prototype.ca;\n      var Cr,\n          Dr,\n          Nr = {\n        createWebChannelTransport: Ir,\n        ErrorCode: Te,\n        EventType: Se,\n        WebChannel: Ce,\n        XhrIo: Qn\n      },\n          Ar = Nr.createWebChannelTransport,\n          kr = Nr.ErrorCode,\n          Rr = Nr.EventType,\n          Mr = Nr.WebChannel,\n          _r = Nr.XhrIo,\n          Lr = Zd.SDK_VERSION,\n          Or = new u(\"@firebase/firestore\");\n\n      function Pr() {\n        return Or.logLevel === o.DEBUG ? Cr.DEBUG : Or.logLevel === o.SILENT ? Cr.SILENT : Cr.ERROR;\n      }\n\n      function xr(t) {\n        switch (t) {\n          case Cr.DEBUG:\n            Or.logLevel = o.DEBUG;\n            break;\n\n          case Cr.ERROR:\n            Or.logLevel = o.ERROR;\n            break;\n\n          case Cr.SILENT:\n            Or.logLevel = o.SILENT;\n            break;\n\n          default:\n            Or.error(\"Firestore (\" + Lr + \"): Invalid value passed to `setLogLevel`\");\n        }\n      }\n\n      function Fr(t, e) {\n        for (var n = [], r = 2; r < arguments.length; r++) n[r - 2] = arguments[r];\n\n        if (Or.logLevel <= o.DEBUG) {\n          var i = n.map(Vr);\n          Or.debug.apply(Or, a([\"Firestore (\" + Lr + \") [\" + t + \"]: \" + e], i));\n        }\n      }\n\n      function qr(t) {\n        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n        if (Or.logLevel <= o.ERROR) {\n          var r = e.map(Vr);\n          Or.error.apply(Or, a([\"Firestore (\" + Lr + \"): \" + t], r));\n        }\n      }\n\n      function Vr(e) {\n        if (\"string\" == typeof e) return e;\n        var t = Kr.getPlatform();\n\n        try {\n          return t.formatJSON(e);\n        } catch (t) {\n          return e;\n        }\n      }\n\n      function Br(t) {\n        var e = \"FIRESTORE (\" + Lr + \") INTERNAL ASSERTION FAILED: \" + t;\n        throw qr(e), new Error(e);\n      }\n\n      function Ur(t, e) {\n        t || Br(e);\n      }\n\n      (Dr = Cr = Cr || {})[Dr.DEBUG = 0] = \"DEBUG\", Dr[Dr.ERROR = 1] = \"ERROR\", Dr[Dr.SILENT = 2] = \"SILENT\";\n      var Kr = (Qr.setPlatform = function (t) {\n        Qr.platform && Br(\"Platform already defined\"), Qr.platform = t;\n      }, Qr.getPlatform = function () {\n        return Qr.platform || Br(\"Platform not set\"), Qr.platform;\n      }, Qr);\n\n      function Qr() {}\n\n      function jr() {\n        return Kr.getPlatform().emptyByteString;\n      }\n\n      var Gr,\n          Wr = {\n        OK: \"ok\",\n        CANCELLED: \"cancelled\",\n        UNKNOWN: \"unknown\",\n        INVALID_ARGUMENT: \"invalid-argument\",\n        DEADLINE_EXCEEDED: \"deadline-exceeded\",\n        NOT_FOUND: \"not-found\",\n        ALREADY_EXISTS: \"already-exists\",\n        PERMISSION_DENIED: \"permission-denied\",\n        UNAUTHENTICATED: \"unauthenticated\",\n        RESOURCE_EXHAUSTED: \"resource-exhausted\",\n        FAILED_PRECONDITION: \"failed-precondition\",\n        ABORTED: \"aborted\",\n        OUT_OF_RANGE: \"out-of-range\",\n        UNIMPLEMENTED: \"unimplemented\",\n        INTERNAL: \"internal\",\n        UNAVAILABLE: \"unavailable\",\n        DATA_LOSS: \"data-loss\"\n      },\n          zr = (t(Hr, Gr = Error), Hr);\n\n      function Hr(t, e) {\n        var n = Gr.call(this, e) || this;\n        return n.code = t, n.message = e, n.name = \"FirebaseError\", n.toString = function () {\n          return n.name + \": [code=\" + n.code + \"]: \" + n.message;\n        }, n;\n      }\n\n      function Yr(t, e) {\n        function n() {\n          var t = \"This constructor is private.\";\n          throw e && (t += \" \", t += e), new zr(Wr.INVALID_ARGUMENT, t);\n        }\n\n        for (var r in n.prototype = t.prototype, t) t.hasOwnProperty(r) && (n[r] = t[r]);\n\n        return n;\n      }\n\n      function Jr(t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }\n\n      function Xr(t, e) {\n        return void 0 !== t ? t : e;\n      }\n\n      function Zr(t, e) {\n        for (var n in t) if (Object.prototype.hasOwnProperty.call(t, n)) {\n          var r = Number(n);\n          isNaN(r) || e(r, t[n]);\n        }\n      }\n\n      function $r(t, e) {\n        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n]);\n      }\n\n      function ti(t) {\n        for (var e in Ur(null != t && \"object\" == typeof t, \"isEmpty() expects object parameter.\"), t) if (Object.prototype.hasOwnProperty.call(t, e)) return !1;\n\n        return !0;\n      }\n\n      function ei(t, e) {\n        if (0 !== e.length) throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() does not support arguments, but was called with \" + bi(e.length, \"argument\") + \".\");\n      }\n\n      function ni(t, e, n) {\n        if (e.length !== n) throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() requires \" + bi(n, \"argument\") + \", but was called with \" + bi(e.length, \"argument\") + \".\");\n      }\n\n      function ri(t, e, n) {\n        if (e.length < n) throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() requires at least \" + bi(n, \"argument\") + \", but was called with \" + bi(e.length, \"argument\") + \".\");\n      }\n\n      function ii(t, e, n, r) {\n        if (e.length < n || e.length > r) throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() requires between \" + n + \" and \" + r + \" arguments, but was called with \" + bi(e.length, \"argument\") + \".\");\n      }\n\n      function oi(t, e, n, r) {\n        li(t, e, vi(n) + \" argument\", r);\n      }\n\n      function ai(t, e, n, r) {\n        void 0 !== r && oi(t, e, n, r);\n      }\n\n      function si(t, e, n, r) {\n        li(t, e, n + \" option\", r);\n      }\n\n      function ui(t, e, n, r) {\n        void 0 !== r && si(t, e, n, r);\n      }\n\n      function ci(t, e, n, r, i) {\n        void 0 !== r && function (t, e, n, r, i) {\n          if (!(r instanceof Array)) throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + e + \" option to be an array, but it was: \" + pi(r));\n\n          for (var o = 0; o < r.length; ++o) if (!i(r[o])) throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() requires all \" + e + \" elements to be \" + n + \", but the value at index \" + o + \" was: \" + pi(r[o]));\n        }(t, e, n, r, i);\n      }\n\n      function hi(t, e, n, r, i) {\n        void 0 !== r && function (t, e, n, r, i) {\n          for (var o = [], a = 0, s = i; a < s.length; a++) {\n            var u = s[a];\n            if (u === r) return;\n            o.push(pi(u));\n          }\n\n          var c = pi(r);\n          throw new zr(Wr.INVALID_ARGUMENT, \"Invalid value \" + c + \" provided to function \" + t + '() for option \"' + n + '\". Acceptable values: ' + o.join(\", \"));\n        }(t, 0, n, r, i);\n      }\n\n      function li(t, e, n, r) {\n        if (!(\"object\" === e ? fi(r) : \"non-empty string\" === e ? \"string\" == typeof r && \"\" !== r : typeof r === e)) {\n          var i = pi(r);\n          throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + n + \" to be of type \" + e + \", but it was: \" + i);\n        }\n      }\n\n      function fi(t) {\n        return \"object\" == typeof t && null !== t && (Object.getPrototypeOf(t) === Object.prototype || null === Object.getPrototypeOf(t));\n      }\n\n      function pi(t) {\n        if (void 0 === t) return \"undefined\";\n        if (null === t) return \"null\";\n        if (\"string\" == typeof t) return 20 < t.length && (t = t.substring(0, 20) + \"...\"), JSON.stringify(t);\n        if (\"number\" == typeof t || \"boolean\" == typeof t) return \"\" + t;\n        if (\"object\" != typeof t) return \"function\" == typeof t ? \"a function\" : Br(\"Unknown wrong type: \" + typeof t);\n        if (t instanceof Array) return \"an array\";\n\n        var e = function (t) {\n          if (t.constructor) {\n            var e = /function\\s+([^\\s(]+)\\s*\\(/.exec(t.constructor.toString());\n            if (e && 1 < e.length) return e[1];\n          }\n\n          return null;\n        }(t);\n\n        return e ? \"a custom \" + e + \" object\" : \"an object\";\n      }\n\n      function di(t, e, n) {\n        if (void 0 === n) throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() requires a valid \" + vi(e) + \" argument, but it was undefined.\");\n      }\n\n      function mi(n, t, r) {\n        $r(t, function (t, e) {\n          if (r.indexOf(t) < 0) throw new zr(Wr.INVALID_ARGUMENT, \"Unknown option '\" + t + \"' passed to function \" + n + \"(). Available options: \" + r.join(\", \"));\n        });\n      }\n\n      function yi(t, e, n, r) {\n        var i = pi(r);\n        return new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + vi(n) + \" argument to be a \" + e + \", but it was: \" + i);\n      }\n\n      function gi(t, e, n) {\n        if (n <= 0) throw new zr(Wr.INVALID_ARGUMENT, 'Function \"' + t + '()\" requires its ' + vi(e) + \" argument to be a positive number, but it was: \" + n + \".\");\n      }\n\n      function vi(t) {\n        switch (t) {\n          case 1:\n            return \"first\";\n\n          case 2:\n            return \"second\";\n\n          case 3:\n            return \"third\";\n\n          default:\n            return t + \"th\";\n        }\n      }\n\n      function bi(t, e) {\n        return t + \" \" + e + (1 === t ? \"\" : \"s\");\n      }\n\n      var wi = (Ti.newId = function () {\n        for (var t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", e = \"\", n = 0; n < 20; n++) e += t.charAt(Math.floor(Math.random() * t.length));\n\n        return Ur(20 === e.length, \"Invalid auto ID: \" + e), e;\n      }, Ti);\n\n      function Ti() {}\n\n      function Si(t, e) {\n        return t < e ? -1 : e < t ? 1 : 0;\n      }\n\n      function Ei(t, e) {\n        if (t.length !== e.length) return !1;\n\n        for (var n = 0; n < t.length; n++) if (!t[n].isEqual(e[n])) return !1;\n\n        return !0;\n      }\n\n      function Ii(t) {\n        return t + \"\\0\";\n      }\n\n      function Ci() {\n        if (\"undefined\" == typeof Uint8Array) throw new zr(Wr.UNIMPLEMENTED, \"Uint8Arrays are not available in this environment.\");\n      }\n\n      function Di() {\n        if (!Kr.getPlatform().base64Available) throw new zr(Wr.UNIMPLEMENTED, \"Blobs are unavailable in Firestore in this environment.\");\n      }\n\n      var Ni = (Ai.fromBase64String = function (t) {\n        ni(\"Blob.fromBase64String\", arguments, 1), oi(\"Blob.fromBase64String\", \"string\", 1, t), Di();\n\n        try {\n          return new Ai(Kr.getPlatform().atob(t));\n        } catch (t) {\n          throw new zr(Wr.INVALID_ARGUMENT, \"Failed to construct Blob from Base64 string: \" + t);\n        }\n      }, Ai.fromUint8Array = function (t) {\n        if (ni(\"Blob.fromUint8Array\", arguments, 1), Ci(), !(t instanceof Uint8Array)) throw yi(\"Blob.fromUint8Array\", \"Uint8Array\", 1, t);\n        return new Ai(Array.prototype.map.call(t, function (t) {\n          return String.fromCharCode(t);\n        }).join(\"\"));\n      }, Ai.prototype.toBase64 = function () {\n        return ni(\"Blob.toBase64\", arguments, 0), Di(), Kr.getPlatform().btoa(this._binaryString);\n      }, Ai.prototype.toUint8Array = function () {\n        ni(\"Blob.toUint8Array\", arguments, 0), Ci();\n\n        for (var t = new Uint8Array(this._binaryString.length), e = 0; e < this._binaryString.length; e++) t[e] = this._binaryString.charCodeAt(e);\n\n        return t;\n      }, Ai.prototype.toString = function () {\n        return \"Blob(base64: \" + this.toBase64() + \")\";\n      }, Ai.prototype.isEqual = function (t) {\n        return this._binaryString === t._binaryString;\n      }, Ai.prototype._compareTo = function (t) {\n        return Si(this._binaryString, t._binaryString);\n      }, Ai);\n\n      function Ai(t) {\n        Di(), this._binaryString = t;\n      }\n\n      var ki = Yr(Ni, \"Use Blob.fromUint8Array() or Blob.fromBase64String() instead.\"),\n          Ri = function (t, e, n, r, i) {\n        this.databaseId = t, this.persistenceKey = e, this.host = n, this.ssl = r, this.forceLongPolling = i;\n      },\n          Mi = \"(default)\",\n          _i = (Object.defineProperty(Li.prototype, \"isDefaultDatabase\", {\n        get: function () {\n          return this.database === Mi;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Li.prototype.isEqual = function (t) {\n        return t instanceof Li && t.projectId === this.projectId && t.database === this.database;\n      }, Li.prototype.compareTo = function (t) {\n        return Si(this.projectId, t.projectId) || Si(this.database, t.database);\n      }, Li);\n\n      function Li(t, e) {\n        this.projectId = t, this.database = e || Mi;\n      }\n\n      var Oi = (Pi.prototype.setPreviousValue = function (t) {\n        return this.previousValue = Math.max(t, this.previousValue), this.previousValue;\n      }, Pi.prototype.next = function () {\n        var t = ++this.previousValue;\n        return this.writeNewSequenceNumber && this.writeNewSequenceNumber(t), t;\n      }, Pi.INVALID = -1, Pi);\n\n      function Pi(t, e) {\n        var n = this;\n        this.previousValue = t, e && (e.sequenceNumberHandler = function (t) {\n          return n.setPreviousValue(t);\n        }, this.writeNewSequenceNumber = function (t) {\n          return e.writeSequenceNumber(t);\n        });\n      }\n\n      var xi = \"__name__\",\n          Fi = (Object.defineProperty(qi.prototype, \"length\", {\n        get: function () {\n          return this.len;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), qi.prototype.isEqual = function (t) {\n        return 0 === qi.comparator(this, t);\n      }, qi.prototype.child = function (t) {\n        var e = this.segments.slice(this.offset, this.limit());\n        return t instanceof qi ? t.forEach(function (t) {\n          e.push(t);\n        }) : e.push(t), this.construct(e);\n      }, qi.prototype.limit = function () {\n        return this.offset + this.length;\n      }, qi.prototype.popFirst = function (t) {\n        return t = void 0 === t ? 1 : t, Ur(this.length >= t, \"Can't call popFirst() with less segments\"), this.construct(this.segments, this.offset + t, this.length - t);\n      }, qi.prototype.popLast = function () {\n        return Ur(!this.isEmpty(), \"Can't call popLast() on empty path\"), this.construct(this.segments, this.offset, this.length - 1);\n      }, qi.prototype.firstSegment = function () {\n        return Ur(!this.isEmpty(), \"Can't call firstSegment() on empty path\"), this.segments[this.offset];\n      }, qi.prototype.lastSegment = function () {\n        return this.get(this.length - 1);\n      }, qi.prototype.get = function (t) {\n        return Ur(t < this.length, \"Index out of range\"), this.segments[this.offset + t];\n      }, qi.prototype.isEmpty = function () {\n        return 0 === this.length;\n      }, qi.prototype.isPrefixOf = function (t) {\n        if (t.length < this.length) return !1;\n\n        for (var e = 0; e < this.length; e++) if (this.get(e) !== t.get(e)) return !1;\n\n        return !0;\n      }, qi.prototype.isImmediateParentOf = function (t) {\n        if (this.length + 1 !== t.length) return !1;\n\n        for (var e = 0; e < this.length; e++) if (this.get(e) !== t.get(e)) return !1;\n\n        return !0;\n      }, qi.prototype.forEach = function (t) {\n        for (var e = this.offset, n = this.limit(); e < n; e++) t(this.segments[e]);\n      }, qi.prototype.toArray = function () {\n        return this.segments.slice(this.offset, this.limit());\n      }, qi.comparator = function (t, e) {\n        for (var n = Math.min(t.length, e.length), r = 0; r < n; r++) {\n          var i = t.get(r),\n              o = e.get(r);\n          if (i < o) return -1;\n          if (o < i) return 1;\n        }\n\n        return t.length < e.length ? -1 : t.length > e.length ? 1 : 0;\n      }, qi);\n\n      function qi(t, e, n) {\n        void 0 === e ? e = 0 : e > t.length && Br(\"offset \" + e + \" out of range \" + t.length), void 0 === n ? n = t.length - e : n > t.length - e && Br(\"length \" + n + \" out of range \" + (t.length - e)), this.segments = t, this.offset = e, this.len = n;\n      }\n\n      var Vi,\n          Bi = (t(Ui, Vi = Fi), Ui.prototype.construct = function (t, e, n) {\n        return new Ui(t, e, n);\n      }, Ui.prototype.canonicalString = function () {\n        return this.toArray().join(\"/\");\n      }, Ui.prototype.toString = function () {\n        return this.canonicalString();\n      }, Ui.fromString = function (t) {\n        if (0 <= t.indexOf(\"//\")) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid path (\" + t + \"). Paths must not contain // in them.\");\n        return new Ui(t.split(\"/\").filter(function (t) {\n          return 0 < t.length;\n        }));\n      }, Ui.EMPTY_PATH = new Ui([]), Ui);\n\n      function Ui() {\n        return null !== Vi && Vi.apply(this, arguments) || this;\n      }\n\n      var Ki,\n          Qi = /^[_a-zA-Z][_a-zA-Z0-9]*$/,\n          ji = (t(Gi, Ki = Fi), Gi.prototype.construct = function (t, e, n) {\n        return new Gi(t, e, n);\n      }, Gi.isValidIdentifier = function (t) {\n        return Qi.test(t);\n      }, Gi.prototype.canonicalString = function () {\n        return this.toArray().map(function (t) {\n          return t = t.replace(\"\\\\\", \"\\\\\\\\\").replace(\"`\", \"\\\\`\"), Gi.isValidIdentifier(t) || (t = \"`\" + t + \"`\"), t;\n        }).join(\".\");\n      }, Gi.prototype.toString = function () {\n        return this.canonicalString();\n      }, Gi.prototype.isKeyField = function () {\n        return 1 === this.length && this.get(0) === xi;\n      }, Gi.keyField = function () {\n        return new Gi([xi]);\n      }, Gi.fromServerFormat = function (t) {\n        for (var e = [], n = \"\", r = 0, i = function () {\n          if (0 === n.length) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid field path (\" + t + \"). Paths must not be empty, begin with '.', end with '.', or contain '..'\");\n          e.push(n), n = \"\";\n        }, o = !1; r < t.length;) {\n          var a = t[r];\n\n          if (\"\\\\\" === a) {\n            if (r + 1 === t.length) throw new zr(Wr.INVALID_ARGUMENT, \"Path has trailing escape character: \" + t);\n            var s = t[r + 1];\n            if (\"\\\\\" !== s && \".\" !== s && \"`\" !== s) throw new zr(Wr.INVALID_ARGUMENT, \"Path has invalid escape sequence: \" + t);\n            n += s, r += 2;\n          } else \"`\" === a ? o = !o : \".\" !== a || o ? n += a : i(), r++;\n        }\n\n        if (i(), o) throw new zr(Wr.INVALID_ARGUMENT, \"Unterminated ` in path: \" + t);\n        return new Gi(e);\n      }, Gi.EMPTY_PATH = new Gi([]), Gi);\n\n      function Gi() {\n        return null !== Ki && Ki.apply(this, arguments) || this;\n      }\n\n      var Wi = (zi.prototype.hasCollectionId = function (t) {\n        return 2 <= this.path.length && this.path.get(this.path.length - 2) === t;\n      }, zi.prototype.isEqual = function (t) {\n        return null !== t && 0 === Bi.comparator(this.path, t.path);\n      }, zi.prototype.toString = function () {\n        return this.path.toString();\n      }, zi.comparator = function (t, e) {\n        return Bi.comparator(t.path, e.path);\n      }, zi.isDocumentKey = function (t) {\n        return t.length % 2 == 0;\n      }, zi.fromSegments = function (t) {\n        return new zi(new Bi(t.slice()));\n      }, zi.fromPathString = function (t) {\n        return new zi(Bi.fromString(t));\n      }, zi.EMPTY = new zi(new Bi([])), zi);\n\n      function zi(t) {\n        this.path = t, Ur(zi.isDocumentKey(t), \"Invalid DocumentKey with an odd number of segments: \" + t.toArray().join(\"/\"));\n      }\n\n      var Hi,\n          Yi,\n          Ji = function () {\n        var n = this;\n        this.promise = new Promise(function (t, e) {\n          n.resolve = t, n.reject = e;\n        });\n      };\n\n      (Yi = Hi = Hi || {}).All = \"all\", Yi.ListenStreamIdle = \"listen_stream_idle\", Yi.ListenStreamConnectionBackoff = \"listen_stream_connection_backoff\", Yi.WriteStreamIdle = \"write_stream_idle\", Yi.WriteStreamConnectionBackoff = \"write_stream_connection_backoff\", Yi.OnlineStateTimeout = \"online_state_timeout\", Yi.ClientMetadataRefresh = \"client_metadata_refresh\", Yi.LruGarbageCollection = \"lru_garbage_collection\", Yi.RetryTransaction = \"retry_transaction\";\n      var Xi = (Zi.createAndSchedule = function (t, e, n, r, i) {\n        var o = new Zi(t, e, Date.now() + n, r, i);\n        return o.start(n), o;\n      }, Zi.prototype.start = function (t) {\n        var e = this;\n        this.timerHandle = setTimeout(function () {\n          return e.handleDelayElapsed();\n        }, t);\n      }, Zi.prototype.skipDelay = function () {\n        return this.handleDelayElapsed();\n      }, Zi.prototype.cancel = function (t) {\n        null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new zr(Wr.CANCELLED, \"Operation cancelled\" + (t ? \": \" + t : \"\"))));\n      }, Zi.prototype.handleDelayElapsed = function () {\n        var e = this;\n        this.asyncQueue.enqueueAndForget(function () {\n          return null !== e.timerHandle ? (e.clearTimeout(), e.op().then(function (t) {\n            return e.deferred.resolve(t);\n          })) : Promise.resolve();\n        });\n      }, Zi.prototype.clearTimeout = function () {\n        null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);\n      }, Zi);\n\n      function Zi(t, e, n, r, i) {\n        this.asyncQueue = t, this.timerId = e, this.targetTimeMs = n, this.op = r, this.removalCallback = i, this.deferred = new Ji(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.catch = this.deferred.promise.catch.bind(this.deferred.promise), this.deferred.promise.catch(function (t) {});\n      }\n\n      var $i = (Object.defineProperty(to.prototype, \"isShuttingDown\", {\n        get: function () {\n          return this._isShuttingDown;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), to.prototype.enqueueAndForget = function (t) {\n        this.enqueue(t);\n      }, to.prototype.enqueueAndForgetEvenAfterShutdown = function (t) {\n        this.verifyNotFailed(), this.enqueueInternal(t);\n      }, to.prototype.enqueueEvenAfterShutdown = function (t) {\n        return this.verifyNotFailed(), this.enqueueInternal(t);\n      }, to.prototype.enqueueAndInitiateShutdown = function (e) {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.verifyNotFailed(), this._isShuttingDown ? [3, 2] : (this._isShuttingDown = !0, [4, this.enqueueEvenAfterShutdown(e)]);\n\n              case 1:\n                t.sent(), t.label = 2;\n\n              case 2:\n                return [2];\n            }\n          });\n        });\n      }, to.prototype.enqueue = function (t) {\n        return this.verifyNotFailed(), this._isShuttingDown ? new Promise(function (t) {}) : this.enqueueInternal(t);\n      }, to.prototype.enqueueInternal = function (t) {\n        var n = this,\n            e = this.tail.then(function () {\n          return n.operationInProgress = !0, t().catch(function (t) {\n            n.failure = t, n.operationInProgress = !1;\n            var e = t.stack || t.message || \"\";\n            throw qr(\"INTERNAL UNHANDLED ERROR: \", e), e.indexOf(\"Firestore Test Simulated Error\") < 0 && setTimeout(function () {\n              throw t;\n            }, 0), t;\n          }).then(function (t) {\n            return n.operationInProgress = !1, t;\n          });\n        });\n        return this.tail = e;\n      }, to.prototype.enqueueAfterDelay = function (t, e, n) {\n        var r = this;\n        this.verifyNotFailed(), Ur(0 <= e, \"Attempted to schedule an operation with a negative delay of \" + e), -1 < this.timerIdsToSkip.indexOf(t) && (e = 0);\n        var i = Xi.createAndSchedule(this, t, e, n, function (t) {\n          return r.removeDelayedOperation(t);\n        });\n        return this.delayedOperations.push(i), i;\n      }, to.prototype.verifyNotFailed = function () {\n        this.failure && Br(\"AsyncQueue is already failed: \" + (this.failure.stack || this.failure.message));\n      }, to.prototype.verifyOperationInProgress = function () {\n        Ur(this.operationInProgress, \"verifyOpInProgress() called when no op in progress on this queue.\");\n      }, to.prototype.drain = function () {\n        return this.enqueueEvenAfterShutdown(function () {\n          return Promise.resolve();\n        });\n      }, to.prototype.containsDelayedOperation = function (t) {\n        for (var e = 0, n = this.delayedOperations; e < n.length; e++) if (n[e].timerId === t) return !0;\n\n        return !1;\n      }, to.prototype.runDelayedOperationsEarly = function (r) {\n        var i = this;\n        return this.drain().then(function () {\n          Ur(r === Hi.All || i.containsDelayedOperation(r), \"Attempted to drain to missing operation \" + r), i.delayedOperations.sort(function (t, e) {\n            return t.targetTimeMs - e.targetTimeMs;\n          });\n\n          for (var t = 0, e = i.delayedOperations; t < e.length; t++) {\n            var n = e[t];\n            if (n.skipDelay(), r !== Hi.All && n.timerId === r) break;\n          }\n\n          return i.drain();\n        });\n      }, to.prototype.skipDelaysForTimerId = function (t) {\n        this.timerIdsToSkip.push(t);\n      }, to.prototype.removeDelayedOperation = function (t) {\n        var e = this.delayedOperations.indexOf(t);\n        Ur(0 <= e, \"Delayed operation not found.\"), this.delayedOperations.splice(e, 1);\n      }, to);\n\n      function to() {\n        this.tail = Promise.resolve(), this._isShuttingDown = !1, this.delayedOperations = [], this.failure = null, this.operationInProgress = !1, this.timerIdsToSkip = [];\n      }\n\n      var eo = \"\u0001\",\n          no = \"\u0001\",\n          ro = \"\u0010\",\n          io = \"\u0011\";\n\n      function oo(t) {\n        for (var e = \"\", n = 0; n < t.length; n++) 0 < e.length && (e = so(e)), e = ao(t.get(n), e);\n\n        return so(e);\n      }\n\n      function ao(t, e) {\n        for (var n = e, r = t.length, i = 0; i < r; i++) {\n          var o = t.charAt(i);\n\n          switch (o) {\n            case \"\\0\":\n              n += eo + ro;\n              break;\n\n            case eo:\n              n += eo + io;\n              break;\n\n            default:\n              n += o;\n          }\n        }\n\n        return n;\n      }\n\n      function so(t) {\n        return t + eo + no;\n      }\n\n      function uo(t) {\n        var e = t.length;\n        if (Ur(2 <= e, \"Invalid path \" + t), 2 === e) return Ur(t.charAt(0) === eo && t.charAt(1) === no, \"Non-empty path \" + t + \" had length 2\"), Bi.EMPTY_PATH;\n\n        for (var n = e - 2, r = [], i = \"\", o = 0; o < e;) {\n          var a = t.indexOf(eo, o);\n\n          switch ((a < 0 || n < a) && Br('Invalid encoded resource path: \"' + t + '\"'), t.charAt(a + 1)) {\n            case no:\n              var s = t.substring(o, a),\n                  u = void 0;\n              0 === i.length ? u = s : (u = i += s, i = \"\"), r.push(u);\n              break;\n\n            case ro:\n              i += t.substring(o, a), i += \"\\0\";\n              break;\n\n            case io:\n              i += t.substring(o, a + 1);\n              break;\n\n            default:\n              Br('Invalid encoded resource path: \"' + t + '\"');\n          }\n\n          o = a + 2;\n        }\n\n        return new Bi(r);\n      }\n\n      var co = (ho.now = function () {\n        return ho.fromMillis(Date.now());\n      }, ho.fromDate = function (t) {\n        return ho.fromMillis(t.getTime());\n      }, ho.fromMillis = function (t) {\n        var e = Math.floor(t / 1e3);\n        return new ho(e, 1e6 * (t - 1e3 * e));\n      }, ho.prototype.toDate = function () {\n        return new Date(this.toMillis());\n      }, ho.prototype.toMillis = function () {\n        return 1e3 * this.seconds + this.nanoseconds / 1e6;\n      }, ho.prototype._compareTo = function (t) {\n        return this.seconds === t.seconds ? Si(this.nanoseconds, t.nanoseconds) : Si(this.seconds, t.seconds);\n      }, ho.prototype.isEqual = function (t) {\n        return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds;\n      }, ho.prototype.toString = function () {\n        return \"Timestamp(seconds=\" + this.seconds + \", nanoseconds=\" + this.nanoseconds + \")\";\n      }, ho);\n\n      function ho(t, e) {\n        if (this.seconds = t, (this.nanoseconds = e) < 0) throw new zr(Wr.INVALID_ARGUMENT, \"Timestamp nanoseconds out of range: \" + e);\n        if (1e9 <= e) throw new zr(Wr.INVALID_ARGUMENT, \"Timestamp nanoseconds out of range: \" + e);\n        if (t < -62135596800) throw new zr(Wr.INVALID_ARGUMENT, \"Timestamp seconds out of range: \" + t);\n        if (253402300800 <= t) throw new zr(Wr.INVALID_ARGUMENT, \"Timestamp seconds out of range: \" + t);\n      }\n\n      var lo = (fo.fromMicroseconds = function (t) {\n        var e = Math.floor(t / 1e6);\n        return new fo(new co(e, t % 1e6 * 1e3));\n      }, fo.fromTimestamp = function (t) {\n        return new fo(t);\n      }, fo.forDeletedDoc = function () {\n        return fo.MIN;\n      }, fo.prototype.compareTo = function (t) {\n        return this.timestamp._compareTo(t.timestamp);\n      }, fo.prototype.isEqual = function (t) {\n        return this.timestamp.isEqual(t.timestamp);\n      }, fo.prototype.toMicroseconds = function () {\n        return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;\n      }, fo.prototype.toString = function () {\n        return \"SnapshotVersion(\" + this.timestamp.toString() + \")\";\n      }, fo.prototype.toTimestamp = function () {\n        return this.timestamp;\n      }, fo.MIN = new fo(new co(0, 0)), fo);\n\n      function fo(t) {\n        this.timestamp = t;\n      }\n\n      var po = (mo.prototype.insert = function (t, e) {\n        return new mo(this.comparator, this.root.insert(t, e, this.comparator).copy(null, null, vo.BLACK, null, null));\n      }, mo.prototype.remove = function (t) {\n        return new mo(this.comparator, this.root.remove(t, this.comparator).copy(null, null, vo.BLACK, null, null));\n      }, mo.prototype.get = function (t) {\n        for (var e = this.root; !e.isEmpty();) {\n          var n = this.comparator(t, e.key);\n          if (0 === n) return e.value;\n          n < 0 ? e = e.left : 0 < n && (e = e.right);\n        }\n\n        return null;\n      }, mo.prototype.indexOf = function (t) {\n        for (var e = 0, n = this.root; !n.isEmpty();) {\n          var r = this.comparator(t, n.key);\n          if (0 === r) return e + n.left.size;\n          n = r < 0 ? n.left : (e += n.left.size + 1, n.right);\n        }\n\n        return -1;\n      }, mo.prototype.isEmpty = function () {\n        return this.root.isEmpty();\n      }, Object.defineProperty(mo.prototype, \"size\", {\n        get: function () {\n          return this.root.size;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), mo.prototype.minKey = function () {\n        return this.root.minKey();\n      }, mo.prototype.maxKey = function () {\n        return this.root.maxKey();\n      }, mo.prototype.inorderTraversal = function (t) {\n        return this.root.inorderTraversal(t);\n      }, mo.prototype.forEach = function (n) {\n        this.inorderTraversal(function (t, e) {\n          return n(t, e), !1;\n        });\n      }, mo.prototype.toString = function () {\n        var n = [];\n        return this.inorderTraversal(function (t, e) {\n          return n.push(t + \":\" + e), !1;\n        }), \"{\" + n.join(\", \") + \"}\";\n      }, mo.prototype.reverseTraversal = function (t) {\n        return this.root.reverseTraversal(t);\n      }, mo.prototype.getIterator = function () {\n        return new yo(this.root, null, this.comparator, !1);\n      }, mo.prototype.getIteratorFrom = function (t) {\n        return new yo(this.root, t, this.comparator, !1);\n      }, mo.prototype.getReverseIterator = function () {\n        return new yo(this.root, null, this.comparator, !0);\n      }, mo.prototype.getReverseIteratorFrom = function (t) {\n        return new yo(this.root, t, this.comparator, !0);\n      }, mo);\n\n      function mo(t, e) {\n        this.comparator = t, this.root = e || vo.EMPTY;\n      }\n\n      var yo = (go.prototype.getNext = function () {\n        Ur(0 < this.nodeStack.length, \"getNext() called on iterator when hasNext() is false.\");\n        var t = this.nodeStack.pop(),\n            e = {\n          key: t.key,\n          value: t.value\n        };\n        if (this.isReverse) for (t = t.left; !t.isEmpty();) this.nodeStack.push(t), t = t.right;else for (t = t.right; !t.isEmpty();) this.nodeStack.push(t), t = t.left;\n        return e;\n      }, go.prototype.hasNext = function () {\n        return 0 < this.nodeStack.length;\n      }, go.prototype.peek = function () {\n        if (0 === this.nodeStack.length) return null;\n        var t = this.nodeStack[this.nodeStack.length - 1];\n        return {\n          key: t.key,\n          value: t.value\n        };\n      }, go);\n\n      function go(t, e, n, r) {\n        this.isReverse = r, this.nodeStack = [];\n\n        for (var i = 1; !t.isEmpty();) if (i = e ? n(t.key, e) : 1, r && (i *= -1), i < 0) t = this.isReverse ? t.left : t.right;else {\n          if (0 === i) {\n            this.nodeStack.push(t);\n            break;\n          }\n\n          this.nodeStack.push(t), t = this.isReverse ? t.right : t.left;\n        }\n      }\n\n      var vo = (bo.prototype.copy = function (t, e, n, r, i) {\n        return new bo(null != t ? t : this.key, null != e ? e : this.value, null != n ? n : this.color, null != r ? r : this.left, null != i ? i : this.right);\n      }, bo.prototype.isEmpty = function () {\n        return !1;\n      }, bo.prototype.inorderTraversal = function (t) {\n        return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t);\n      }, bo.prototype.reverseTraversal = function (t) {\n        return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t);\n      }, bo.prototype.min = function () {\n        return this.left.isEmpty() ? this : this.left.min();\n      }, bo.prototype.minKey = function () {\n        return this.min().key;\n      }, bo.prototype.maxKey = function () {\n        return this.right.isEmpty() ? this.key : this.right.maxKey();\n      }, bo.prototype.insert = function (t, e, n) {\n        var r = this,\n            i = n(t, r.key);\n        return (r = i < 0 ? r.copy(null, null, null, r.left.insert(t, e, n), null) : 0 === i ? r.copy(null, e, null, null, null) : r.copy(null, null, null, null, r.right.insert(t, e, n))).fixUp();\n      }, bo.prototype.removeMin = function () {\n        if (this.left.isEmpty()) return bo.EMPTY;\n        var t = this;\n        return t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()), (t = t.copy(null, null, null, t.left.removeMin(), null)).fixUp();\n      }, bo.prototype.remove = function (t, e) {\n        var n,\n            r = this;\n        if (e(t, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(t, e), null);else {\n          if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), 0 === e(t, r.key)) {\n            if (r.right.isEmpty()) return bo.EMPTY;\n            n = r.right.min(), r = r.copy(n.key, n.value, null, null, r.right.removeMin());\n          }\n\n          r = r.copy(null, null, null, null, r.right.remove(t, e));\n        }\n        return r.fixUp();\n      }, bo.prototype.isRed = function () {\n        return this.color;\n      }, bo.prototype.fixUp = function () {\n        var t = this;\n        return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t;\n      }, bo.prototype.moveRedLeft = function () {\n        var t = this.colorFlip();\n        return t.right.left.isRed() && (t = (t = (t = t.copy(null, null, null, null, t.right.rotateRight())).rotateLeft()).colorFlip()), t;\n      }, bo.prototype.moveRedRight = function () {\n        var t = this.colorFlip();\n        return t.left.left.isRed() && (t = (t = t.rotateRight()).colorFlip()), t;\n      }, bo.prototype.rotateLeft = function () {\n        var t = this.copy(null, null, bo.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, t, null);\n      }, bo.prototype.rotateRight = function () {\n        var t = this.copy(null, null, bo.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, t);\n      }, bo.prototype.colorFlip = function () {\n        var t = this.left.copy(null, null, !this.left.color, null, null),\n            e = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, t, e);\n      }, bo.prototype.checkMaxDepth = function () {\n        var t = this.check();\n        return Math.pow(2, t) <= this.size + 1;\n      }, bo.prototype.check = function () {\n        if (this.isRed() && this.left.isRed()) throw Br(\"Red node has red child(\" + this.key + \",\" + this.value + \")\");\n        if (this.right.isRed()) throw Br(\"Right child of (\" + this.key + \",\" + this.value + \") is red\");\n        var t = this.left.check();\n        if (t !== this.right.check()) throw Br(\"Black depths differ\");\n        return t + (this.isRed() ? 0 : 1);\n      }, bo.EMPTY = null, bo.RED = !0, bo.BLACK = !1, bo);\n\n      function bo(t, e, n, r, i) {\n        this.key = t, this.value = e, this.color = null != n ? n : bo.RED, this.left = null != r ? r : bo.EMPTY, this.right = null != i ? i : bo.EMPTY, this.size = this.left.size + 1 + this.right.size;\n      }\n\n      var wo = (Object.defineProperty(To.prototype, \"key\", {\n        get: function () {\n          throw Br(\"LLRBEmptyNode has no key.\");\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(To.prototype, \"value\", {\n        get: function () {\n          throw Br(\"LLRBEmptyNode has no value.\");\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(To.prototype, \"color\", {\n        get: function () {\n          throw Br(\"LLRBEmptyNode has no color.\");\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(To.prototype, \"left\", {\n        get: function () {\n          throw Br(\"LLRBEmptyNode has no left child.\");\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(To.prototype, \"right\", {\n        get: function () {\n          throw Br(\"LLRBEmptyNode has no right child.\");\n        },\n        enumerable: !0,\n        configurable: !0\n      }), To.prototype.copy = function (t, e, n, r, i) {\n        return this;\n      }, To.prototype.insert = function (t, e, n) {\n        return new vo(t, e);\n      }, To.prototype.remove = function (t, e) {\n        return this;\n      }, To.prototype.isEmpty = function () {\n        return !0;\n      }, To.prototype.inorderTraversal = function (t) {\n        return !1;\n      }, To.prototype.reverseTraversal = function (t) {\n        return !1;\n      }, To.prototype.minKey = function () {\n        return null;\n      }, To.prototype.maxKey = function () {\n        return null;\n      }, To.prototype.isRed = function () {\n        return !1;\n      }, To.prototype.checkMaxDepth = function () {\n        return !0;\n      }, To.prototype.check = function () {\n        return 0;\n      }, To);\n\n      function To() {\n        this.size = 0;\n      }\n\n      vo.EMPTY = new wo();\n      var So = (Eo.fromMapKeys = function (t) {\n        var e = new Eo(t.comparator);\n        return t.forEach(function (t) {\n          e = e.add(t);\n        }), e;\n      }, Eo.prototype.has = function (t) {\n        return null !== this.data.get(t);\n      }, Eo.prototype.first = function () {\n        return this.data.minKey();\n      }, Eo.prototype.last = function () {\n        return this.data.maxKey();\n      }, Object.defineProperty(Eo.prototype, \"size\", {\n        get: function () {\n          return this.data.size;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Eo.prototype.indexOf = function (t) {\n        return this.data.indexOf(t);\n      }, Eo.prototype.forEach = function (n) {\n        this.data.inorderTraversal(function (t, e) {\n          return n(t), !1;\n        });\n      }, Eo.prototype.forEachInRange = function (t, e) {\n        for (var n = this.data.getIteratorFrom(t[0]); n.hasNext();) {\n          var r = n.getNext();\n          if (0 <= this.comparator(r.key, t[1])) return;\n          e(r.key);\n        }\n      }, Eo.prototype.forEachWhile = function (t, e) {\n        var n;\n\n        for (n = void 0 !== e ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext();) if (!t(n.getNext().key)) return;\n      }, Eo.prototype.firstAfterOrEqual = function (t) {\n        var e = this.data.getIteratorFrom(t);\n        return e.hasNext() ? e.getNext().key : null;\n      }, Eo.prototype.getIterator = function () {\n        return new Io(this.data.getIterator());\n      }, Eo.prototype.getIteratorFrom = function (t) {\n        return new Io(this.data.getIteratorFrom(t));\n      }, Eo.prototype.add = function (t) {\n        return this.copy(this.data.remove(t).insert(t, !0));\n      }, Eo.prototype.delete = function (t) {\n        return this.has(t) ? this.copy(this.data.remove(t)) : this;\n      }, Eo.prototype.isEmpty = function () {\n        return this.data.isEmpty();\n      }, Eo.prototype.unionWith = function (t) {\n        var e = this;\n        return t.forEach(function (t) {\n          e = e.add(t);\n        }), e;\n      }, Eo.prototype.isEqual = function (t) {\n        if (!(t instanceof Eo)) return !1;\n        if (this.size !== t.size) return !1;\n\n        for (var e = this.data.getIterator(), n = t.data.getIterator(); e.hasNext();) {\n          var r = e.getNext().key,\n              i = n.getNext().key;\n          if (0 !== this.comparator(r, i)) return !1;\n        }\n\n        return !0;\n      }, Eo.prototype.toArray = function () {\n        var e = [];\n        return this.forEach(function (t) {\n          e.push(t);\n        }), e;\n      }, Eo.prototype.toString = function () {\n        var e = [];\n        return this.forEach(function (t) {\n          return e.push(t);\n        }), \"SortedSet(\" + e.toString() + \")\";\n      }, Eo.prototype.copy = function (t) {\n        var e = new Eo(this.comparator);\n        return e.data = t, e;\n      }, Eo);\n\n      function Eo(t) {\n        this.comparator = t, this.data = new po(this.comparator);\n      }\n\n      var Io = (Co.prototype.getNext = function () {\n        return this.iter.getNext().key;\n      }, Co.prototype.hasNext = function () {\n        return this.iter.hasNext();\n      }, Co);\n\n      function Co(t) {\n        this.iter = t;\n      }\n\n      var Do = new po(Wi.comparator);\n\n      function No() {\n        return Do;\n      }\n\n      function Ao() {\n        return No();\n      }\n\n      var ko = new po(Wi.comparator);\n\n      function Ro() {\n        return ko;\n      }\n\n      var Mo = new po(Wi.comparator);\n\n      function _o() {\n        return Mo;\n      }\n\n      var Lo = new So(Wi.comparator);\n\n      function Oo() {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        for (var n = Lo, r = 0, i = t; r < i.length; r++) {\n          var o = i[r];\n          n = n.add(o);\n        }\n\n        return n;\n      }\n\n      var Po = new So(Si);\n\n      function xo() {\n        return Po;\n      }\n\n      var Fo = (qo.prototype.applyToRemoteDocument = function (t, e, n) {\n        e && Ur(e.key.isEqual(t), \"applyToRemoteDocument: key \" + t + \" should match maybeDoc key\\n        \" + e.key);\n        var r = n.mutationResults;\n        Ur(r.length === this.mutations.length, \"Mismatch between mutations length\\n      (\" + this.mutations.length + \") and mutation results length\\n      (\" + r.length + \").\");\n\n        for (var i = 0; i < this.mutations.length; i++) {\n          var o = this.mutations[i];\n\n          if (o.key.isEqual(t)) {\n            var a = r[i];\n            e = o.applyToRemoteDocument(e, a);\n          }\n        }\n\n        return e;\n      }, qo.prototype.applyToLocalView = function (t, e) {\n        e && Ur(e.key.isEqual(t), \"applyToLocalDocument: key \" + t + \" should match maybeDoc key\\n        \" + e.key);\n\n        for (var n = 0, r = this.baseMutations; n < r.length; n++) (s = r[n]).key.isEqual(t) && (e = s.applyToLocalView(e, e, this.localWriteTime));\n\n        for (var i = e, o = 0, a = this.mutations; o < a.length; o++) {\n          var s;\n          (s = a[o]).key.isEqual(t) && (e = s.applyToLocalView(e, i, this.localWriteTime));\n        }\n\n        return e;\n      }, qo.prototype.applyToLocalDocumentSet = function (n) {\n        var r = this,\n            i = n;\n        return this.mutations.forEach(function (t) {\n          var e = r.applyToLocalView(t.key, n.get(t.key));\n          e && (i = i.insert(t.key, e));\n        }), i;\n      }, qo.prototype.keys = function () {\n        return this.mutations.reduce(function (t, e) {\n          return t.add(e.key);\n        }, Oo());\n      }, qo.prototype.isEqual = function (t) {\n        return this.batchId === t.batchId && Ei(this.mutations, t.mutations) && Ei(this.baseMutations, t.baseMutations);\n      }, qo);\n\n      function qo(t, e, n, r) {\n        this.batchId = t, this.localWriteTime = e, this.baseMutations = n, Ur(0 < (this.mutations = r).length, \"Cannot create an empty mutation batch\");\n      }\n\n      var Vo = (Bo.from = function (t, e, n, r) {\n        Ur(t.mutations.length === n.length, \"Mutations sent \" + t.mutations.length + \" must equal results received \" + n.length);\n\n        for (var i = _o(), o = t.mutations, a = 0; a < o.length; a++) i = i.insert(o[a].key, n[a].version);\n\n        return new Bo(t, e, n, r, i);\n      }, Bo);\n\n      function Bo(t, e, n, r, i) {\n        this.batch = t, this.commitVersion = e, this.mutationResults = n, this.streamToken = r, this.docVersions = i;\n      }\n\n      var Uo = (Ko.prototype.catch = function (t) {\n        return this.next(void 0, t);\n      }, Ko.prototype.next = function (r, i) {\n        var o = this;\n        return this.callbackAttached && Br(\"Called next() or catch() twice for PersistencePromise\"), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(i, this.error) : this.wrapSuccess(r, this.result) : new Ko(function (e, n) {\n          o.nextCallback = function (t) {\n            o.wrapSuccess(r, t).next(e, n);\n          }, o.catchCallback = function (t) {\n            o.wrapFailure(i, t).next(e, n);\n          };\n        });\n      }, Ko.prototype.toPromise = function () {\n        var n = this;\n        return new Promise(function (t, e) {\n          n.next(t, e);\n        });\n      }, Ko.prototype.wrapUserFunction = function (t) {\n        try {\n          var e = t();\n          return e instanceof Ko ? e : Ko.resolve(e);\n        } catch (t) {\n          return Ko.reject(t);\n        }\n      }, Ko.prototype.wrapSuccess = function (t, e) {\n        return t ? this.wrapUserFunction(function () {\n          return t(e);\n        }) : Ko.resolve(e);\n      }, Ko.prototype.wrapFailure = function (t, e) {\n        return t ? this.wrapUserFunction(function () {\n          return t(e);\n        }) : Ko.reject(e);\n      }, Ko.resolve = function (n) {\n        return new Ko(function (t, e) {\n          t(n);\n        });\n      }, Ko.reject = function (n) {\n        return new Ko(function (t, e) {\n          e(n);\n        });\n      }, Ko.waitFor = function (t) {\n        return new Ko(function (e, n) {\n          var r = 0,\n              i = 0,\n              o = !1;\n          t.forEach(function (t) {\n            ++r, t.next(function () {\n              ++i, o && i === r && e();\n            }, function (t) {\n              return n(t);\n            });\n          }), o = !0, i === r && e();\n        });\n      }, Ko.or = function (t) {\n        for (var n = Ko.resolve(!1), e = function (e) {\n          n = n.next(function (t) {\n            return t ? Ko.resolve(t) : e();\n          });\n        }, r = 0, i = t; r < i.length; r++) e(i[r]);\n\n        return n;\n      }, Ko.forEach = function (t, n) {\n        var r = this,\n            i = [];\n        return t.forEach(function (t, e) {\n          i.push(n.call(r, t, e));\n        }), this.waitFor(i);\n      }, Ko);\n\n      function Ko(t) {\n        var e = this;\n        this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, t(function (t) {\n          e.isDone = !0, e.result = t, e.nextCallback && e.nextCallback(t);\n        }, function (t) {\n          e.isDone = !0, e.error = t, e.catchCallback && e.catchCallback(t);\n        });\n      }\n\n      var Qo = \"SimpleDb\",\n          jo = (Go.openOrCreate = function (o, t, a) {\n        return Ur(Go.isAvailable(), \"IndexedDB not supported in current environment.\"), Fr(Qo, \"Opening database:\", o), new Uo(function (n, r) {\n          var i = window.indexedDB.open(o, t);\n          i.onsuccess = function (t) {\n            var e = t.target.result;\n            n(new Go(e));\n          }, i.onblocked = function () {\n            r(new zr(Wr.FAILED_PRECONDITION, \"Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.\"));\n          }, i.onerror = function (t) {\n            var e = t.target.error;\n            \"VersionError\" === e.name ? r(new zr(Wr.FAILED_PRECONDITION, \"A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.\")) : r(e);\n          }, i.onupgradeneeded = function (t) {\n            Fr(Qo, 'Database \"' + o + '\" requires upgrade from version:', t.oldVersion);\n            var e = t.target.result;\n            a.createOrUpgrade(e, i.transaction, t.oldVersion, cu).next(function () {\n              Fr(Qo, \"Database upgrade to version \" + cu + \" complete\");\n            });\n          };\n        }).toPromise();\n      }, Go.delete = function (t) {\n        return Fr(Qo, \"Removing database:\", t), Zo(window.indexedDB.deleteDatabase(t)).toPromise();\n      }, Go.isAvailable = function () {\n        if (\"undefined\" == typeof window || null == window.indexedDB) return !1;\n        if (Go.isMockPersistence()) return !0;\n        if (void 0 === window.navigator) return !1;\n        var t = h(),\n            e = Go.getIOSVersion(t),\n            n = 0 < e && e < 10,\n            r = Go.getAndroidVersion(t),\n            i = 0 < r && r < 4.5;\n        return !(0 < t.indexOf(\"MSIE \") || 0 < t.indexOf(\"Trident/\") || 0 < t.indexOf(\"Edge/\") || n || i);\n      }, Go.isMockPersistence = function () {\n        var t;\n        return \"undefined\" != typeof process && \"YES\" === (null === (t = process.env) || void 0 === t ? void 0 : t.USE_MOCK_PERSISTENCE);\n      }, Go.getStore = function (t, e) {\n        return t.store(e);\n      }, Go.getIOSVersion = function (t) {\n        var e = t.match(/i(?:phone|pad|pod) os ([\\d_]+)/i),\n            n = e ? e[1].split(\"_\").slice(0, 2).join(\".\") : \"-1\";\n        return Number(n);\n      }, Go.getAndroidVersion = function (t) {\n        var e = t.match(/Android ([\\d.]+)/i),\n            n = e ? e[1].split(\".\").slice(0, 2).join(\".\") : \"-1\";\n        return Number(n);\n      }, Go.prototype.setVersionChangeListener = function (e) {\n        this.db.onversionchange = function (t) {\n          return e(t);\n        };\n      }, Go.prototype.runTransaction = function (r, c, h) {\n        return p(this, void 0, void 0, function () {\n          var o, a, s, e, u, n;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                o = r.startsWith(\"readonly\"), a = r.endsWith(\"idempotent\"), s = 0, e = function () {\n                  var e, n, r, i;\n                  return m(this, function (t) {\n                    switch (t.label) {\n                      case 0:\n                        ++s, e = Ho.open(u.db, o ? \"readonly\" : \"readwrite\", c), t.label = 1;\n\n                      case 1:\n                        return t.trys.push([1, 3,, 4]), (n = h(e).catch(function (t) {\n                          return e.abort(t), Uo.reject(t);\n                        }).toPromise()).catch(function () {}), [4, e.completionPromise];\n\n                      case 2:\n                        return t.sent(), [2, {\n                          value: n\n                        }];\n\n                      case 3:\n                        return r = t.sent(), i = a && \"FirebaseError\" !== r.name && s < 3, Fr(Qo, \"Transaction failed with error: %s. Retrying: %s.\", r.message, i), i ? [3, 4] : [2, {\n                          value: Promise.reject(r)\n                        }];\n\n                      case 4:\n                        return [2];\n                    }\n                  });\n                }, u = this, t.label = 1;\n\n              case 1:\n                return [5, e()];\n\n              case 2:\n                return \"object\" == typeof (n = t.sent()) ? [2, n.value] : [3, 1];\n\n              case 3:\n                return [2];\n            }\n          });\n        });\n      }, Go.prototype.close = function () {\n        this.db.close();\n      }, Go);\n\n      function Go(t) {\n        this.db = t, 12.2 === Go.getIOSVersion(h()) && qr(\"Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.\");\n      }\n\n      var Wo = (Object.defineProperty(zo.prototype, \"isDone\", {\n        get: function () {\n          return this.shouldStop;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(zo.prototype, \"skipToKey\", {\n        get: function () {\n          return this.nextKey;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(zo.prototype, \"cursor\", {\n        set: function (t) {\n          this.dbCursor = t;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), zo.prototype.done = function () {\n        this.shouldStop = !0;\n      }, zo.prototype.skip = function (t) {\n        this.nextKey = t;\n      }, zo.prototype.delete = function () {\n        return Zo(this.dbCursor.delete());\n      }, zo);\n\n      function zo(t) {\n        this.dbCursor = t, this.shouldStop = !1, this.nextKey = null;\n      }\n\n      var Ho = (Yo.open = function (t, e, n) {\n        return new Yo(t.transaction(n, e));\n      }, Object.defineProperty(Yo.prototype, \"completionPromise\", {\n        get: function () {\n          return this.completionDeferred.promise;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Yo.prototype.abort = function (t) {\n        t && this.completionDeferred.reject(t), this.aborted || (Fr(Qo, \"Aborting transaction:\", t ? t.message : \"Client-initiated abort\"), this.aborted = !0, this.transaction.abort());\n      }, Yo.prototype.store = function (t) {\n        var e = this.transaction.objectStore(t);\n        return Ur(!!e, \"Object store not part of transaction: \" + t), new Jo(e);\n      }, Yo);\n\n      function Yo(t) {\n        var n = this;\n        this.transaction = t, this.aborted = !1, this.completionDeferred = new Ji(), this.transaction.oncomplete = function () {\n          n.completionDeferred.resolve();\n        }, this.transaction.onabort = function () {\n          t.error ? n.completionDeferred.reject(t.error) : n.completionDeferred.resolve();\n        }, this.transaction.onerror = function (t) {\n          var e = ta(t.target.error);\n          n.completionDeferred.reject(e);\n        };\n      }\n\n      var Jo = (Xo.prototype.put = function (t, e) {\n        return Zo(void 0 !== e ? (Fr(Qo, \"PUT\", this.store.name, t, e), this.store.put(e, t)) : (Fr(Qo, \"PUT\", this.store.name, \"<auto-key>\", t), this.store.put(t)));\n      }, Xo.prototype.add = function (t) {\n        return Fr(Qo, \"ADD\", this.store.name, t, t), Zo(this.store.add(t));\n      }, Xo.prototype.get = function (e) {\n        var n = this;\n        return Zo(this.store.get(e)).next(function (t) {\n          return void 0 === t && (t = null), Fr(Qo, \"GET\", n.store.name, e, t), t;\n        });\n      }, Xo.prototype.delete = function (t) {\n        return Fr(Qo, \"DELETE\", this.store.name, t), Zo(this.store.delete(t));\n      }, Xo.prototype.count = function () {\n        return Fr(Qo, \"COUNT\", this.store.name), Zo(this.store.count());\n      }, Xo.prototype.loadAll = function (t, e) {\n        var n = this.cursor(this.options(t, e)),\n            r = [];\n        return this.iterateCursor(n, function (t, e) {\n          r.push(e);\n        }).next(function () {\n          return r;\n        });\n      }, Xo.prototype.deleteAll = function (t, e) {\n        Fr(Qo, \"DELETE ALL\", this.store.name);\n        var n = this.options(t, e);\n        n.keysOnly = !1;\n        var r = this.cursor(n);\n        return this.iterateCursor(r, function (t, e, n) {\n          return n.delete();\n        });\n      }, Xo.prototype.iterate = function (t, e) {\n        var n;\n        e ? n = t : (n = {}, e = t);\n        var r = this.cursor(n);\n        return this.iterateCursor(r, e);\n      }, Xo.prototype.iterateSerial = function (i) {\n        var t = this.cursor({});\n        return new Uo(function (n, r) {\n          t.onerror = function (t) {\n            var e = ta(t.target.error);\n            r(e);\n          }, t.onsuccess = function (t) {\n            var e = t.target.result;\n            e ? i(e.primaryKey, e.value).next(function (t) {\n              t ? e.continue() : n();\n            }) : n();\n          };\n        });\n      }, Xo.prototype.iterateCursor = function (t, a) {\n        var s = [];\n        return new Uo(function (o, e) {\n          t.onerror = function (t) {\n            e(t.target.error);\n          }, t.onsuccess = function (t) {\n            var e = t.target.result;\n\n            if (e) {\n              var n = new Wo(e),\n                  r = a(e.primaryKey, e.value, n);\n\n              if (r instanceof Uo) {\n                var i = r.catch(function (t) {\n                  return n.done(), Uo.reject(t);\n                });\n                s.push(i);\n              }\n\n              n.isDone ? o() : null === n.skipToKey ? e.continue() : e.continue(n.skipToKey);\n            } else o();\n          };\n        }).next(function () {\n          return Uo.waitFor(s);\n        });\n      }, Xo.prototype.options = function (t, e) {\n        var n = void 0;\n        return void 0 !== t && (\"string\" == typeof t ? n = t : (Ur(void 0 === e, \"3rd argument must not be defined if 2nd is a range.\"), e = t)), {\n          index: n,\n          range: e\n        };\n      }, Xo.prototype.cursor = function (t) {\n        var e = \"next\";\n\n        if (t.reverse && (e = \"prev\"), t.index) {\n          var n = this.store.index(t.index);\n          return t.keysOnly ? n.openKeyCursor(t.range, e) : n.openCursor(t.range, e);\n        }\n\n        return this.store.openCursor(t.range, e);\n      }, Xo);\n\n      function Xo(t) {\n        this.store = t;\n      }\n\n      function Zo(t) {\n        return new Uo(function (n, r) {\n          t.onsuccess = function (t) {\n            var e = t.target.result;\n            n(e);\n          }, t.onerror = function (t) {\n            var e = ta(t.target.error);\n            r(e);\n          };\n        });\n      }\n\n      var $o = !1;\n\n      function ta(t) {\n        var e = jo.getIOSVersion(h());\n\n        if (12.2 <= e && e < 13) {\n          var n = \"An internal error was encountered in the Indexed Database server\";\n\n          if (0 <= t.message.indexOf(n)) {\n            var r = new zr(\"internal\", \"IOS_INDEXEDDB_BUG1: IndexedDb has thrown '\" + n + \"'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.\");\n            return $o || ($o = !0, setTimeout(function () {\n              throw r;\n            }, 0)), r;\n          }\n        }\n\n        return t;\n      }\n\n      var ea = (na.forUser = function (t, e, n, r) {\n        return Ur(\"\" !== t.uid, \"UserID must not be an empty string.\"), new na(t.isAuthenticated() ? t.uid : \"\", e, n, r);\n      }, na.prototype.checkEmpty = function (t) {\n        var r = !0,\n            e = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);\n        return aa(t).iterate({\n          index: gu.userMutationsIndex,\n          range: e\n        }, function (t, e, n) {\n          r = !1, n.done();\n        }).next(function () {\n          return r;\n        });\n      }, na.prototype.acknowledgeBatch = function (e, t, n) {\n        return this.getMutationQueueMetadata(e).next(function (t) {\n          return t.lastStreamToken = oa(n), ua(e).put(t);\n        });\n      }, na.prototype.getLastStreamToken = function (t) {\n        return this.getMutationQueueMetadata(t).next(function (t) {\n          return t.lastStreamToken;\n        });\n      }, na.prototype.setLastStreamToken = function (e, n) {\n        return this.getMutationQueueMetadata(e).next(function (t) {\n          return t.lastStreamToken = oa(n), ua(e).put(t);\n        });\n      }, na.prototype.addMutationBatch = function (c, h, l, f) {\n        var p = this,\n            d = sa(c),\n            m = aa(c);\n        return m.add({}).next(function (t) {\n          Ur(\"number\" == typeof t, \"Auto-generated key is not a number\");\n\n          for (var e = new Fo(t, h, l, f), n = p.serializer.toDbMutationBatch(p.userId, e), r = [], i = new So(function (t, e) {\n            return Si(t.canonicalString(), e.canonicalString());\n          }), o = 0, a = f; o < a.length; o++) {\n            var s = a[o],\n                u = bu.key(p.userId, s.key.path, t);\n            i = i.add(s.key.path.popLast()), r.push(m.put(n)), r.push(d.put(u, bu.PLACEHOLDER));\n          }\n\n          return i.forEach(function (t) {\n            r.push(p.indexManager.addToCollectionParentIndex(c, t));\n          }), c.addOnCommittedListener(function () {\n            p.documentKeysByBatchId[t] = e.keys();\n          }), Uo.waitFor(r).next(function () {\n            return e;\n          });\n        });\n      }, na.prototype.lookupMutationBatch = function (t, e) {\n        var n = this;\n        return aa(t).get(e).next(function (t) {\n          return t ? (Ur(t.userId === n.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + e), n.serializer.fromDbMutationBatch(t)) : null;\n        });\n      }, na.prototype.lookupMutationKeys = function (t, n) {\n        var r = this;\n        return this.documentKeysByBatchId[n] ? Uo.resolve(this.documentKeysByBatchId[n]) : this.lookupMutationBatch(t, n).next(function (t) {\n          if (t) {\n            var e = t.keys();\n            return r.documentKeysByBatchId[n] = e;\n          }\n\n          return null;\n        });\n      }, na.prototype.getNextMutationBatchAfterBatchId = function (t, e) {\n        var r = this,\n            i = e + 1,\n            n = IDBKeyRange.lowerBound([this.userId, i]),\n            o = null;\n        return aa(t).iterate({\n          index: gu.userMutationsIndex,\n          range: n\n        }, function (t, e, n) {\n          e.userId === r.userId && (Ur(e.batchId >= i, \"Should have found mutation after \" + i), o = r.serializer.fromDbMutationBatch(e)), n.done();\n        }).next(function () {\n          return o;\n        });\n      }, na.prototype.getHighestUnacknowledgedBatchId = function (t) {\n        var e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]),\n            r = -1;\n        return aa(t).iterate({\n          index: gu.userMutationsIndex,\n          range: e,\n          reverse: !0\n        }, function (t, e, n) {\n          r = e.batchId, n.done();\n        }).next(function () {\n          return r;\n        });\n      }, na.prototype.getAllMutationBatches = function (t) {\n        var e = this,\n            n = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);\n        return aa(t).loadAll(gu.userMutationsIndex, n).next(function (t) {\n          return t.map(function (t) {\n            return e.serializer.fromDbMutationBatch(t);\n          });\n        });\n      }, na.prototype.getAllMutationBatchesAffectingDocumentKey = function (s, u) {\n        var c = this,\n            t = bu.prefixForPath(this.userId, u.path),\n            e = IDBKeyRange.lowerBound(t),\n            h = [];\n        return sa(s).iterate({\n          range: e\n        }, function (e, t, n) {\n          var r = e[0],\n              i = e[1],\n              o = e[2],\n              a = uo(i);\n          if (r === c.userId && u.path.isEqual(a)) return aa(s).get(o).next(function (t) {\n            if (!t) throw Br(\"Dangling document-mutation reference found: \" + e + \" which points to \" + o);\n            Ur(t.userId === c.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + o), h.push(c.serializer.fromDbMutationBatch(t));\n          });\n          n.done();\n        }).next(function () {\n          return h;\n        });\n      }, na.prototype.getAllMutationBatchesAffectingDocumentKeys = function (r, t) {\n        var u = this,\n            c = new So(Si),\n            i = [];\n        return t.forEach(function (s) {\n          var t = bu.prefixForPath(u.userId, s.path),\n              e = IDBKeyRange.lowerBound(t),\n              n = sa(r).iterate({\n            range: e\n          }, function (t, e, n) {\n            var r = t[0],\n                i = t[1],\n                o = t[2],\n                a = uo(i);\n            r === u.userId && s.path.isEqual(a) ? c = c.add(o) : n.done();\n          });\n          i.push(n);\n        }), Uo.waitFor(i).next(function () {\n          return u.lookupMutationBatches(r, c);\n        });\n      }, na.prototype.getAllMutationBatchesAffectingQuery = function (t, e) {\n        var s = this;\n        Ur(!e.isDocumentQuery(), \"Document queries shouldn't go down this path\"), Ur(!e.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n        var u = e.path,\n            c = u.length + 1,\n            n = bu.prefixForPath(this.userId, u),\n            r = IDBKeyRange.lowerBound(n),\n            h = new So(Si);\n        return sa(t).iterate({\n          range: r\n        }, function (t, e, n) {\n          var r = t[0],\n              i = t[1],\n              o = t[2],\n              a = uo(i);\n          r === s.userId && u.isPrefixOf(a) ? a.length === c && (h = h.add(o)) : n.done();\n        }).next(function () {\n          return s.lookupMutationBatches(t, h);\n        });\n      }, na.prototype.lookupMutationBatches = function (t, e) {\n        var n = this,\n            r = [],\n            i = [];\n        return e.forEach(function (e) {\n          i.push(aa(t).get(e).next(function (t) {\n            if (null === t) throw Br(\"Dangling document-mutation reference found, which points to \" + e);\n            Ur(t.userId === n.userId, \"Unexpected user '\" + t.userId + \"' for mutation batch \" + e), r.push(n.serializer.fromDbMutationBatch(t));\n          }));\n        }), Uo.waitFor(i).next(function () {\n          return r;\n        });\n      }, na.prototype.removeMutationBatch = function (e, n) {\n        var r = this;\n        return ia(e.simpleDbTransaction, this.userId, n).next(function (t) {\n          return e.addOnCommittedListener(function () {\n            r.removeCachedMutationKeys(n.batchId);\n          }), Uo.forEach(t, function (t) {\n            return r.referenceDelegate.removeMutationReference(e, t);\n          });\n        });\n      }, na.prototype.removeCachedMutationKeys = function (t) {\n        delete this.documentKeysByBatchId[t];\n      }, na.prototype.performConsistencyCheck = function (n) {\n        var o = this;\n        return this.checkEmpty(n).next(function (t) {\n          if (!t) return Uo.resolve();\n          var e = IDBKeyRange.lowerBound(bu.prefixForUser(o.userId)),\n              i = [];\n          return sa(n).iterate({\n            range: e\n          }, function (t, e, n) {\n            if (t[0] === o.userId) {\n              var r = uo(t[1]);\n              i.push(r);\n            } else n.done();\n          }).next(function () {\n            Ur(0 === i.length, \"Document leak -- detected dangling mutation references when queue is empty. Dangling keys: \" + i.map(function (t) {\n              return t.canonicalString();\n            }));\n          });\n        });\n      }, na.prototype.containsKey = function (t, e) {\n        return ra(t, this.userId, e);\n      }, na.prototype.getMutationQueueMetadata = function (t) {\n        var e = this;\n        return ua(t).get(this.userId).next(function (t) {\n          return t || new mu(e.userId, -1, \"\");\n        });\n      }, na);\n\n      function na(t, e, n, r) {\n        this.userId = t, this.serializer = e, this.indexManager = n, this.referenceDelegate = r, this.documentKeysByBatchId = {};\n      }\n\n      function ra(t, o, e) {\n        var n = bu.prefixForPath(o, e.path),\n            a = n[1],\n            r = IDBKeyRange.lowerBound(n),\n            s = !1;\n        return sa(t).iterate({\n          range: r,\n          keysOnly: !0\n        }, function (t, e, n) {\n          var r = t[0],\n              i = t[1];\n          t[2];\n          r === o && i === a && (s = !0), n.done();\n        }).next(function () {\n          return s;\n        });\n      }\n\n      function ia(t, e, n) {\n        var r = t.store(gu.store),\n            i = t.store(bu.store),\n            o = [],\n            a = IDBKeyRange.only(n.batchId),\n            s = 0,\n            u = r.iterate({\n          range: a\n        }, function (t, e, n) {\n          return s++, n.delete();\n        });\n        o.push(u.next(function () {\n          Ur(1 === s, \"Dangling document-mutation reference found: Missing batch \" + n.batchId);\n        }));\n\n        for (var c = [], h = 0, l = n.mutations; h < l.length; h++) {\n          var f = l[h],\n              p = bu.key(e, f.key.path, n.batchId);\n          o.push(i.delete(p)), c.push(f.key);\n        }\n\n        return Uo.waitFor(o).next(function () {\n          return c;\n        });\n      }\n\n      function oa(t) {\n        return t instanceof Uint8Array ? (Ur(jo.isMockPersistence(), \"Persisting non-string stream tokens is only supported with mock persistence.\"), t.toString()) : t;\n      }\n\n      function aa(t) {\n        return fc.getStore(t, gu.store);\n      }\n\n      function sa(t) {\n        return fc.getStore(t, bu.store);\n      }\n\n      function ua(t) {\n        return fc.getStore(t, mu.store);\n      }\n\n      var ca, ha;\n      (ha = ca = ca || {})[ha.QueryCache = 0] = \"QueryCache\", ha[ha.SyncEngine = 1] = \"SyncEngine\";\n      var la = (fa.prototype.next = function () {\n        var t = this.nextId;\n        return this.nextId += 2, t;\n      }, fa.prototype.after = function (t) {\n        return this.seek(t + 2), this.next();\n      }, fa.prototype.seek = function (t) {\n        Ur((1 & t) === this.generatorId, \"Cannot supply target ID from different generator ID\"), this.nextId = t;\n      }, fa.forTargetCache = function () {\n        return new fa(ca.QueryCache, 2);\n      }, fa.forSyncEngine = function () {\n        return new fa(ca.SyncEngine);\n      }, fa);\n\n      function fa(t, e) {\n        Ur((1 & (this.generatorId = t)) === t, \"Generator ID \" + t + \" contains more than 1 reserved bits\"), this.seek(void 0 !== e ? e : this.generatorId);\n      }\n\n      var pa = (da.prototype.allocateTargetId = function (e) {\n        var n = this;\n        return this.retrieveMetadata(e).next(function (t) {\n          return t.highestTargetId = n.targetIdGenerator.after(t.highestTargetId), n.saveMetadata(e, t).next(function () {\n            return t.highestTargetId;\n          });\n        });\n      }, da.prototype.getLastRemoteSnapshotVersion = function (t) {\n        return this.retrieveMetadata(t).next(function (t) {\n          return lo.fromTimestamp(new co(t.lastRemoteSnapshotVersion.seconds, t.lastRemoteSnapshotVersion.nanoseconds));\n        });\n      }, da.prototype.getHighestSequenceNumber = function (t) {\n        return ga(t.simpleDbTransaction);\n      }, da.prototype.setTargetsMetadata = function (e, n, r) {\n        var i = this;\n        return this.retrieveMetadata(e).next(function (t) {\n          return t.highestListenSequenceNumber = n, r && (t.lastRemoteSnapshotVersion = r.toTimestamp()), n > t.highestListenSequenceNumber && (t.highestListenSequenceNumber = n), i.saveMetadata(e, t);\n        });\n      }, da.prototype.addTargetData = function (e, n) {\n        var r = this;\n        return this.saveTargetData(e, n).next(function () {\n          return r.retrieveMetadata(e).next(function (t) {\n            return t.targetCount += 1, r.updateMetadataFromTargetData(n, t), r.saveMetadata(e, t);\n          });\n        });\n      }, da.prototype.updateTargetData = function (t, e) {\n        return this.saveTargetData(t, e);\n      }, da.prototype.removeTargetData = function (e, t) {\n        var n = this;\n        return this.removeMatchingKeysForTargetId(e, t.targetId).next(function () {\n          return ma(e).delete(t.targetId);\n        }).next(function () {\n          return n.retrieveMetadata(e);\n        }).next(function (t) {\n          return Ur(0 < t.targetCount, \"Removing from an empty target cache\"), t.targetCount -= 1, n.saveMetadata(e, t);\n        });\n      }, da.prototype.removeTargets = function (r, i, o) {\n        var a = this,\n            s = 0,\n            u = [];\n        return ma(r).iterate(function (t, e) {\n          var n = a.serializer.fromDbTarget(e);\n          n.sequenceNumber <= i && null === o.get(n.targetId) && (s++, u.push(a.removeTargetData(r, n)));\n        }).next(function () {\n          return Uo.waitFor(u);\n        }).next(function () {\n          return s;\n        });\n      }, da.prototype.forEachTarget = function (t, r) {\n        var i = this;\n        return ma(t).iterate(function (t, e) {\n          var n = i.serializer.fromDbTarget(e);\n          r(n);\n        });\n      }, da.prototype.retrieveMetadata = function (t) {\n        return ya(t.simpleDbTransaction);\n      }, da.prototype.saveMetadata = function (t, e) {\n        return function (t) {\n          return fc.getStore(t, Mu.store);\n        }(t).put(Mu.key, e);\n      }, da.prototype.saveTargetData = function (t, e) {\n        return ma(t).put(this.serializer.toDbTarget(e));\n      }, da.prototype.updateMetadataFromTargetData = function (t, e) {\n        var n = !1;\n        return t.targetId > e.highestTargetId && (e.highestTargetId = t.targetId, n = !0), t.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t.sequenceNumber, n = !0), n;\n      }, da.prototype.getTargetCount = function (t) {\n        return this.retrieveMetadata(t).next(function (t) {\n          return t.targetCount;\n        });\n      }, da.prototype.getTargetData = function (t, i) {\n        var o = this,\n            e = i.canonicalId(),\n            n = IDBKeyRange.bound([e, Number.NEGATIVE_INFINITY], [e, Number.POSITIVE_INFINITY]),\n            a = null;\n        return ma(t).iterate({\n          range: n,\n          index: Nu.queryTargetsIndexName\n        }, function (t, e, n) {\n          var r = o.serializer.fromDbTarget(e);\n          i.isEqual(r.target) && (a = r, n.done());\n        }).next(function () {\n          return a;\n        });\n      }, da.prototype.addMatchingKeys = function (n, t, r) {\n        var i = this,\n            o = [],\n            a = va(n);\n        return t.forEach(function (t) {\n          var e = oo(t.path);\n          o.push(a.put(new ku(r, e))), o.push(i.referenceDelegate.addReference(n, t));\n        }), Uo.waitFor(o);\n      }, da.prototype.removeMatchingKeys = function (n, t, r) {\n        var i = this,\n            o = va(n);\n        return Uo.forEach(t, function (t) {\n          var e = oo(t.path);\n          return Uo.waitFor([o.delete([r, e]), i.referenceDelegate.removeReference(n, t)]);\n        });\n      }, da.prototype.removeMatchingKeysForTargetId = function (t, e) {\n        var n = va(t),\n            r = IDBKeyRange.bound([e], [e + 1], !1, !0);\n        return n.delete(r);\n      }, da.prototype.getMatchingKeysForTargetId = function (t, e) {\n        var n = IDBKeyRange.bound([e], [e + 1], !1, !0),\n            r = va(t),\n            o = Oo();\n        return r.iterate({\n          range: n,\n          keysOnly: !0\n        }, function (t, e, n) {\n          var r = uo(t[1]),\n              i = new Wi(r);\n          o = o.add(i);\n        }).next(function () {\n          return o;\n        });\n      }, da.prototype.containsKey = function (t, e) {\n        var n = oo(e.path),\n            r = IDBKeyRange.bound([n], [Ii(n)], !1, !0),\n            i = 0;\n        return va(t).iterate({\n          index: ku.documentTargetsIndex,\n          keysOnly: !0,\n          range: r\n        }, function (t, e, n) {\n          var r = t[0];\n          t[1], 0 !== r && (i++, n.done());\n        }).next(function () {\n          return 0 < i;\n        });\n      }, da.prototype.getTargetDataForTarget = function (t, e) {\n        var n = this;\n        return ma(t).get(e).next(function (t) {\n          return t ? n.serializer.fromDbTarget(t) : null;\n        });\n      }, da);\n\n      function da(t, e) {\n        this.referenceDelegate = t, this.serializer = e, this.targetIdGenerator = la.forTargetCache();\n      }\n\n      function ma(t) {\n        return fc.getStore(t, Nu.store);\n      }\n\n      function ya(t) {\n        return jo.getStore(t, Mu.store).get(Mu.key).next(function (t) {\n          return Ur(null !== t, \"Missing metadata row.\"), t;\n        });\n      }\n\n      function ga(t) {\n        return ya(t).next(function (t) {\n          return t.highestListenSequenceNumber;\n        });\n      }\n\n      function va(t) {\n        return fc.getStore(t, ku.store);\n      }\n\n      var ba = (wa.fromSet = function (t) {\n        return new wa(t);\n      }, wa.fromArray = function (t) {\n        var e = new So(ji.comparator);\n        return t.forEach(function (t) {\n          return e = e.add(t);\n        }), new wa(e);\n      }, wa.prototype.covers = function (e) {\n        var n = !1;\n        return this.fields.forEach(function (t) {\n          t.isPrefixOf(e) && (n = !0);\n        }), n;\n      }, wa.prototype.isEqual = function (t) {\n        return this.fields.isEqual(t.fields);\n      }, wa);\n\n      function wa(t) {\n        this.fields = t;\n      }\n\n      var Ta = (Sa.prototype.isEqual = function (t) {\n        return this.field.isEqual(t.field) && this.transform.isEqual(t.transform);\n      }, Sa);\n\n      function Sa(t, e) {\n        this.field = t, this.transform = e;\n      }\n\n      var Ea,\n          Ia,\n          Ca = function (t, e) {\n        this.version = t, this.transformResults = e;\n      };\n\n      (Ia = Ea = Ea || {})[Ia.Set = 0] = \"Set\", Ia[Ia.Patch = 1] = \"Patch\", Ia[Ia.Transform = 2] = \"Transform\", Ia[Ia.Delete = 3] = \"Delete\";\n      var Da = (Na.exists = function (t) {\n        return new Na(void 0, t);\n      }, Na.updateTime = function (t) {\n        return new Na(t);\n      }, Object.defineProperty(Na.prototype, \"isNone\", {\n        get: function () {\n          return void 0 === this.updateTime && void 0 === this.exists;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Na.prototype.isValidFor = function (t) {\n        return void 0 !== this.updateTime ? t instanceof Vs && t.version.isEqual(this.updateTime) : void 0 !== this.exists ? this.exists === t instanceof Vs : (Ur(this.isNone, \"Precondition should be empty\"), !0);\n      }, Na.prototype.isEqual = function (t) {\n        return function (t, e) {\n          return null != t ? !(!e || !t.isEqual(e)) : t === e;\n        }(this.updateTime, t.updateTime) && this.exists === t.exists;\n      }, Na.NONE = new Na(), Na);\n\n      function Na(t, e) {\n        this.updateTime = t, this.exists = e, Ur(void 0 === t || void 0 === e, 'Precondition can specify \"exists\" or \"updateTime\" but not both');\n      }\n\n      var Aa = (ka.prototype.verifyKeyMatches = function (t) {\n        null != t && Ur(t.key.isEqual(this.key), \"Can only apply a mutation to a document with the same key\");\n      }, ka.getPostMutationVersion = function (t) {\n        return t instanceof Vs ? t.version : lo.MIN;\n      }, ka);\n\n      function ka() {}\n\n      var Ra,\n          Ma = (t(_a, Ra = Aa), _a.prototype.applyToRemoteDocument = function (t, e) {\n        this.verifyKeyMatches(t), Ur(null == e.transformResults, \"Transform results received by SetMutation.\");\n        var n = e.version;\n        return new Vs(this.key, n, {\n          hasCommittedMutations: !0\n        }, this.value);\n      }, _a.prototype.applyToLocalView = function (t, e, n) {\n        if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n        var r = Aa.getPostMutationVersion(t);\n        return new Vs(this.key, r, {\n          hasLocalMutations: !0\n        }, this.value);\n      }, _a.prototype.extractBaseValue = function (t) {\n        return null;\n      }, _a.prototype.isEqual = function (t) {\n        return t instanceof _a && this.key.isEqual(t.key) && this.value.isEqual(t.value) && this.precondition.isEqual(t.precondition);\n      }, _a);\n\n      function _a(t, e, n) {\n        var r = Ra.call(this) || this;\n        return r.key = t, r.value = e, r.precondition = n, r.type = Ea.Set, r;\n      }\n\n      var La,\n          Oa = (t(Pa, La = Aa), Pa.prototype.applyToRemoteDocument = function (t, e) {\n        if (this.verifyKeyMatches(t), Ur(null == e.transformResults, \"Transform results received by PatchMutation.\"), !this.precondition.isValidFor(t)) return new Gs(this.key, e.version);\n        var n = this.patchDocument(t);\n        return new Vs(this.key, e.version, {\n          hasCommittedMutations: !0\n        }, n);\n      }, Pa.prototype.applyToLocalView = function (t, e, n) {\n        if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n        var r = Aa.getPostMutationVersion(t),\n            i = this.patchDocument(t);\n        return new Vs(this.key, r, {\n          hasLocalMutations: !0\n        }, i);\n      }, Pa.prototype.extractBaseValue = function (t) {\n        return null;\n      }, Pa.prototype.isEqual = function (t) {\n        return t instanceof Pa && this.key.isEqual(t.key) && this.fieldMask.isEqual(t.fieldMask) && this.precondition.isEqual(t.precondition);\n      }, Pa.prototype.patchDocument = function (t) {\n        var e;\n        return e = t instanceof Vs ? t.data() : Ms.EMPTY, this.patchObject(e);\n      }, Pa.prototype.patchObject = function (n) {\n        var r = this;\n        return this.fieldMask.fields.forEach(function (t) {\n          if (!t.isEmpty()) {\n            var e = r.data.field(t);\n            n = null !== e ? n.set(t, e) : n.delete(t);\n          }\n        }), n;\n      }, Pa);\n\n      function Pa(t, e, n, r) {\n        var i = La.call(this) || this;\n        return i.key = t, i.data = e, i.fieldMask = n, i.precondition = r, i.type = Ea.Patch, i;\n      }\n\n      var xa,\n          Fa = (t(qa, xa = Aa), qa.prototype.applyToRemoteDocument = function (t, e) {\n        if (this.verifyKeyMatches(t), Ur(null != e.transformResults, \"Transform results missing for TransformMutation.\"), !this.precondition.isValidFor(t)) return new Gs(this.key, e.version);\n        var n = this.requireDocument(t),\n            r = this.serverTransformResults(t, e.transformResults),\n            i = e.version,\n            o = this.transformObject(n.data(), r);\n        return new Vs(this.key, i, {\n          hasCommittedMutations: !0\n        }, o);\n      }, qa.prototype.applyToLocalView = function (t, e, n) {\n        if (this.verifyKeyMatches(t), !this.precondition.isValidFor(t)) return t;\n        var r = this.requireDocument(t),\n            i = this.localTransformResults(n, t, e),\n            o = this.transformObject(r.data(), i);\n        return new Vs(this.key, r.version, {\n          hasLocalMutations: !0\n        }, o);\n      }, qa.prototype.extractBaseValue = function (t) {\n        for (var e = null, n = 0, r = this.fieldTransforms; n < r.length; n++) {\n          var i = r[n],\n              o = t instanceof Vs ? t.field(i.field) : void 0,\n              a = i.transform.computeBaseValue(o || null);\n          null != a && (e = null == e ? Ms.EMPTY.set(i.field, a) : e.set(i.field, a));\n        }\n\n        return e;\n      }, qa.prototype.isEqual = function (t) {\n        return t instanceof qa && this.key.isEqual(t.key) && Ei(this.fieldTransforms, t.fieldTransforms) && this.precondition.isEqual(t.precondition);\n      }, qa.prototype.requireDocument = function (t) {\n        return Ur(t instanceof Vs, \"Unknown MaybeDocument type \" + t), Ur(t.key.isEqual(this.key), \"Can only transform a document with the same key\"), t;\n      }, qa.prototype.serverTransformResults = function (t, e) {\n        var n = [];\n        Ur(this.fieldTransforms.length === e.length, \"server transform result count (\" + e.length + \") should match field transform count (\" + this.fieldTransforms.length + \")\");\n\n        for (var r = 0; r < e.length; r++) {\n          var i = this.fieldTransforms[r],\n              o = i.transform,\n              a = null;\n          t instanceof Vs && (a = t.field(i.field)), n.push(o.applyToRemoteDocument(a, e[r]));\n        }\n\n        return n;\n      }, qa.prototype.localTransformResults = function (t, e, n) {\n        for (var r = [], i = 0, o = this.fieldTransforms; i < o.length; i++) {\n          var a = o[i],\n              s = a.transform,\n              u = null;\n          e instanceof Vs && (u = e.field(a.field)), null === u && n instanceof Vs && (u = n.field(a.field)), r.push(s.applyToLocalView(u, t));\n        }\n\n        return r;\n      }, qa.prototype.transformObject = function (t, e) {\n        Ur(e.length === this.fieldTransforms.length, \"TransformResults length mismatch.\");\n\n        for (var n = 0; n < this.fieldTransforms.length; n++) {\n          var r = this.fieldTransforms[n].field;\n          t = t.set(r, e[n]);\n        }\n\n        return t;\n      }, qa);\n\n      function qa(t, e) {\n        var n = xa.call(this) || this;\n        return n.key = t, n.fieldTransforms = e, n.type = Ea.Transform, n.precondition = Da.exists(!0), n;\n      }\n\n      var Va,\n          Ba,\n          Ua,\n          Ka,\n          Qa,\n          ja = (t(Ga, Va = Aa), Ga.prototype.applyToRemoteDocument = function (t, e) {\n        return this.verifyKeyMatches(t), Ur(null == e.transformResults, \"Transform results received by DeleteMutation.\"), new Ks(this.key, e.version, {\n          hasCommittedMutations: !0\n        });\n      }, Ga.prototype.applyToLocalView = function (t, e, n) {\n        return this.verifyKeyMatches(t), this.precondition.isValidFor(t) ? (t && Ur(t.key.isEqual(this.key), \"Can only apply mutation to document with same key\"), new Ks(this.key, lo.forDeletedDoc())) : t;\n      }, Ga.prototype.extractBaseValue = function (t) {\n        return null;\n      }, Ga.prototype.isEqual = function (t) {\n        return t instanceof Ga && this.key.isEqual(t.key) && this.precondition.isEqual(t.precondition);\n      }, Ga);\n\n      function Ga(t, e) {\n        var n = Va.call(this) || this;\n        return n.key = t, n.precondition = e, n.type = Ea.Delete, n;\n      }\n\n      (Ua = Ba = Ba || {})[Ua.NullValue = 0] = \"NullValue\", Ua[Ua.BooleanValue = 1] = \"BooleanValue\", Ua[Ua.NumberValue = 2] = \"NumberValue\", Ua[Ua.TimestampValue = 3] = \"TimestampValue\", Ua[Ua.StringValue = 4] = \"StringValue\", Ua[Ua.BlobValue = 5] = \"BlobValue\", Ua[Ua.RefValue = 6] = \"RefValue\", Ua[Ua.GeoPointValue = 7] = \"GeoPointValue\", Ua[Ua.ArrayValue = 8] = \"ArrayValue\", Ua[Ua.ObjectValue = 9] = \"ObjectValue\", (Qa = Ka = Ka || {})[Qa.Default = 0] = \"Default\", Qa[Qa.Estimate = 1] = \"Estimate\", Qa[Qa.Previous = 2] = \"Previous\";\n      var Wa = (za.fromSnapshotOptions = function (t, e) {\n        switch (t.serverTimestamps) {\n          case \"estimate\":\n            return new za(Ka.Estimate, e);\n\n          case \"previous\":\n            return new za(Ka.Previous, e);\n\n          case \"none\":\n          case void 0:\n            return new za(Ka.Default, e);\n\n          default:\n            return Br(\"fromSnapshotOptions() called with invalid options.\");\n        }\n      }, za);\n\n      function za(t, e) {\n        this.serverTimestampBehavior = t, this.timestampsInSnapshots = e;\n      }\n\n      var Ha = (Ya.prototype.toString = function () {\n        var t = this.value();\n        return null === t ? \"null\" : t.toString();\n      }, Ya.prototype.defaultCompareTo = function (t) {\n        return Ur(this.typeOrder !== t.typeOrder, \"Default compareTo should not be used for values of same type.\"), Si(this.typeOrder, t.typeOrder);\n      }, Ya);\n\n      function Ya() {}\n\n      var Ja,\n          Xa = (t(Za, Ja = Ha), Za.prototype.value = function (t) {\n        return null;\n      }, Za.prototype.isEqual = function (t) {\n        return t instanceof Za;\n      }, Za.prototype.compareTo = function (t) {\n        return t instanceof Za ? 0 : this.defaultCompareTo(t);\n      }, Za.INSTANCE = new Za(), Za);\n\n      function Za() {\n        var t = Ja.call(this) || this;\n        return t.typeOrder = Ba.NullValue, t.internalValue = null, t;\n      }\n\n      var $a,\n          ts = (t(es, $a = Ha), es.prototype.value = function (t) {\n        return this.internalValue;\n      }, es.prototype.isEqual = function (t) {\n        return t instanceof es && this.internalValue === t.internalValue;\n      }, es.prototype.compareTo = function (t) {\n        return t instanceof es ? Si(this, t) : this.defaultCompareTo(t);\n      }, es.of = function (t) {\n        return t ? es.TRUE : es.FALSE;\n      }, es.TRUE = new es(!0), es.FALSE = new es(!1), es);\n\n      function es(t) {\n        var e = $a.call(this) || this;\n        return e.internalValue = t, e.typeOrder = Ba.BooleanValue, e;\n      }\n\n      var ns,\n          rs = (t(is, ns = Ha), is.prototype.value = function (t) {\n        return this.internalValue;\n      }, is.prototype.compareTo = function (t) {\n        return t instanceof is ? function (t, e) {\n          return t < e ? -1 : e < t ? 1 : t === e ? 0 : isNaN(t) ? isNaN(e) ? 0 : -1 : 1;\n        }(this.internalValue, t.internalValue) : this.defaultCompareTo(t);\n      }, is);\n\n      function is(t) {\n        var e = ns.call(this) || this;\n        return e.internalValue = t, e.typeOrder = Ba.NumberValue, e;\n      }\n\n      function os(t, e) {\n        return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e;\n      }\n\n      var as,\n          ss = (t(us, as = rs), us.prototype.isEqual = function (t) {\n        return t instanceof us && os(this.internalValue, t.internalValue);\n      }, us);\n\n      function us() {\n        return null !== as && as.apply(this, arguments) || this;\n      }\n\n      var cs,\n          hs = (t(ls, cs = rs), ls.prototype.isEqual = function (t) {\n        return t instanceof ls && os(this.internalValue, t.internalValue);\n      }, ls.NAN = new ls(NaN), ls.POSITIVE_INFINITY = new ls(1 / 0), ls.NEGATIVE_INFINITY = new ls(-1 / 0), ls);\n\n      function ls() {\n        return null !== cs && cs.apply(this, arguments) || this;\n      }\n\n      var fs,\n          ps = (t(ds, fs = Ha), ds.prototype.value = function (t) {\n        return this.internalValue;\n      }, ds.prototype.isEqual = function (t) {\n        return t instanceof ds && this.internalValue === t.internalValue;\n      }, ds.prototype.compareTo = function (t) {\n        return t instanceof ds ? Si(this.internalValue, t.internalValue) : this.defaultCompareTo(t);\n      }, ds);\n\n      function ds(t) {\n        var e = fs.call(this) || this;\n        return e.internalValue = t, e.typeOrder = Ba.StringValue, e;\n      }\n\n      var ms,\n          ys = (t(gs, ms = Ha), gs.prototype.value = function (t) {\n        return !t || t.timestampsInSnapshots ? this.internalValue : this.internalValue.toDate();\n      }, gs.prototype.isEqual = function (t) {\n        return t instanceof gs && this.internalValue.isEqual(t.internalValue);\n      }, gs.prototype.compareTo = function (t) {\n        return t instanceof gs ? this.internalValue._compareTo(t.internalValue) : t instanceof bs ? -1 : this.defaultCompareTo(t);\n      }, gs);\n\n      function gs(t) {\n        var e = ms.call(this) || this;\n        return e.internalValue = t, e.typeOrder = Ba.TimestampValue, e;\n      }\n\n      var vs,\n          bs = (t(ws, vs = Ha), ws.prototype.value = function (t) {\n        return t && t.serverTimestampBehavior === Ka.Estimate ? new ys(this.localWriteTime).value(t) : t && t.serverTimestampBehavior === Ka.Previous && this.previousValue ? this.previousValue.value(t) : null;\n      }, ws.prototype.isEqual = function (t) {\n        return t instanceof ws && this.localWriteTime.isEqual(t.localWriteTime);\n      }, ws.prototype.compareTo = function (t) {\n        return t instanceof ws ? this.localWriteTime._compareTo(t.localWriteTime) : t instanceof ys ? 1 : this.defaultCompareTo(t);\n      }, ws.prototype.toString = function () {\n        return \"<ServerTimestamp localTime=\" + this.localWriteTime.toString() + \">\";\n      }, ws);\n\n      function ws(t, e) {\n        var n = vs.call(this) || this;\n        return n.localWriteTime = t, n.previousValue = e, n.typeOrder = Ba.TimestampValue, n;\n      }\n\n      var Ts,\n          Ss = (t(Es, Ts = Ha), Es.prototype.value = function (t) {\n        return this.internalValue;\n      }, Es.prototype.isEqual = function (t) {\n        return t instanceof Es && this.internalValue.isEqual(t.internalValue);\n      }, Es.prototype.compareTo = function (t) {\n        return t instanceof Es ? this.internalValue._compareTo(t.internalValue) : this.defaultCompareTo(t);\n      }, Es);\n\n      function Es(t) {\n        var e = Ts.call(this) || this;\n        return e.internalValue = t, e.typeOrder = Ba.BlobValue, e;\n      }\n\n      var Is,\n          Cs = (t(Ds, Is = Ha), Ds.prototype.value = function (t) {\n        return this.key;\n      }, Ds.prototype.isEqual = function (t) {\n        return t instanceof Ds && this.key.isEqual(t.key) && this.databaseId.isEqual(t.databaseId);\n      }, Ds.prototype.compareTo = function (t) {\n        if (t instanceof Ds) {\n          var e = this.databaseId.compareTo(t.databaseId);\n          return 0 !== e ? e : Wi.comparator(this.key, t.key);\n        }\n\n        return this.defaultCompareTo(t);\n      }, Ds);\n\n      function Ds(t, e) {\n        var n = Is.call(this) || this;\n        return n.databaseId = t, n.key = e, n.typeOrder = Ba.RefValue, n;\n      }\n\n      var Ns,\n          As = (t(ks, Ns = Ha), ks.prototype.value = function (t) {\n        return this.internalValue;\n      }, ks.prototype.isEqual = function (t) {\n        return t instanceof ks && this.internalValue.isEqual(t.internalValue);\n      }, ks.prototype.compareTo = function (t) {\n        return t instanceof ks ? this.internalValue._compareTo(t.internalValue) : this.defaultCompareTo(t);\n      }, ks);\n\n      function ks(t) {\n        var e = Ns.call(this) || this;\n        return e.internalValue = t, e.typeOrder = Ba.GeoPointValue, e;\n      }\n\n      var Rs,\n          Ms = (t(_s, Rs = Ha), _s.prototype.value = function (n) {\n        var r = {};\n        return this.internalValue.inorderTraversal(function (t, e) {\n          r[t] = e.value(n);\n        }), r;\n      }, _s.prototype.forEach = function (t) {\n        this.internalValue.inorderTraversal(t);\n      }, _s.prototype.isEqual = function (t) {\n        if (t instanceof _s) {\n          for (var e = this.internalValue.getIterator(), n = t.internalValue.getIterator(); e.hasNext() && n.hasNext();) {\n            var r = e.getNext(),\n                i = n.getNext();\n            if (r.key !== i.key || !r.value.isEqual(i.value)) return !1;\n          }\n\n          return !e.hasNext() && !n.hasNext();\n        }\n\n        return !1;\n      }, _s.prototype.compareTo = function (t) {\n        if (t instanceof _s) {\n          for (var e = this.internalValue.getIterator(), n = t.internalValue.getIterator(); e.hasNext() && n.hasNext();) {\n            var r = e.getNext(),\n                i = n.getNext(),\n                o = Si(r.key, i.key) || r.value.compareTo(i.value);\n            if (o) return o;\n          }\n\n          return Si(e.hasNext(), n.hasNext());\n        }\n\n        return this.defaultCompareTo(t);\n      }, _s.prototype.set = function (t, e) {\n        if (Ur(!t.isEmpty(), \"Cannot set field for empty path on ObjectValue\"), 1 === t.length) return this.setChild(t.firstSegment(), e);\n        var n = this.child(t.firstSegment());\n        n instanceof _s || (n = _s.EMPTY);\n        var r = n.set(t.popFirst(), e);\n        return this.setChild(t.firstSegment(), r);\n      }, _s.prototype.delete = function (t) {\n        if (Ur(!t.isEmpty(), \"Cannot delete field for empty path on ObjectValue\"), 1 === t.length) return new _s(this.internalValue.remove(t.firstSegment()));\n        var e = this.child(t.firstSegment());\n\n        if (e instanceof _s) {\n          var n = e.delete(t.popFirst());\n          return new _s(this.internalValue.insert(t.firstSegment(), n));\n        }\n\n        return this;\n      }, _s.prototype.contains = function (t) {\n        return null !== this.field(t);\n      }, _s.prototype.field = function (t) {\n        Ur(!t.isEmpty(), \"Can't get field of empty path\");\n        var e = this;\n        return t.forEach(function (t) {\n          e = e instanceof _s ? e.internalValue.get(t) : null;\n        }), e;\n      }, _s.prototype.fieldMask = function () {\n        var i = new So(ji.comparator);\n        return this.internalValue.forEach(function (t, e) {\n          var n = new ji([t]);\n\n          if (e instanceof _s) {\n            var r = e.fieldMask().fields;\n            r.isEmpty() ? i = i.add(n) : r.forEach(function (t) {\n              i = i.add(n.child(t));\n            });\n          } else i = i.add(n);\n        }), ba.fromSet(i);\n      }, _s.prototype.toString = function () {\n        return this.internalValue.toString();\n      }, _s.prototype.child = function (t) {\n        return this.internalValue.get(t) || void 0;\n      }, _s.prototype.setChild = function (t, e) {\n        return new _s(this.internalValue.insert(t, e));\n      }, _s.EMPTY = new _s(new po(Si)), _s);\n\n      function _s(t) {\n        var e = Rs.call(this) || this;\n        return e.internalValue = t, e.typeOrder = Ba.ObjectValue, e;\n      }\n\n      var Ls,\n          Os = (t(Ps, Ls = Ha), Ps.prototype.value = function (e) {\n        return this.internalValue.map(function (t) {\n          return t.value(e);\n        });\n      }, Ps.prototype.contains = function (t) {\n        for (var e = 0, n = this.internalValue; e < n.length; e++) if (n[e].isEqual(t)) return !0;\n\n        return !1;\n      }, Ps.prototype.forEach = function (t) {\n        this.internalValue.forEach(t);\n      }, Ps.prototype.isEqual = function (t) {\n        if (t instanceof Ps) {\n          if (this.internalValue.length !== t.internalValue.length) return !1;\n\n          for (var e = 0; e < this.internalValue.length; e++) if (!this.internalValue[e].isEqual(t.internalValue[e])) return !1;\n\n          return !0;\n        }\n\n        return !1;\n      }, Ps.prototype.compareTo = function (t) {\n        if (t instanceof Ps) {\n          for (var e = Math.min(this.internalValue.length, t.internalValue.length), n = 0; n < e; n++) {\n            var r = this.internalValue[n].compareTo(t.internalValue[n]);\n            if (r) return r;\n          }\n\n          return Si(this.internalValue.length, t.internalValue.length);\n        }\n\n        return this.defaultCompareTo(t);\n      }, Ps.prototype.toString = function () {\n        return \"[\" + this.internalValue.map(function (t) {\n          return t.toString();\n        }).join(\",\") + \"]\";\n      }, Ps);\n\n      function Ps(t) {\n        var e = Ls.call(this) || this;\n        return e.internalValue = t, e.typeOrder = Ba.ArrayValue, e;\n      }\n\n      var xs = (Fs.compareByKey = function (t, e) {\n        return Wi.comparator(t.key, e.key);\n      }, Fs);\n\n      function Fs(t, e) {\n        this.key = t, this.version = e;\n      }\n\n      var qs,\n          Vs = (t(Bs, qs = xs), Bs.prototype.field = function (t) {\n        if (this.objectValue) return this.objectValue.field(t);\n        this.fieldValueCache || (this.fieldValueCache = new Map());\n        var e = t.canonicalString(),\n            n = this.fieldValueCache.get(e);\n\n        if (void 0 === n) {\n          var r = this.getProtoField(t);\n          n = void 0 === r ? null : this.converter(r), this.fieldValueCache.set(e, n);\n        }\n\n        return n;\n      }, Bs.prototype.data = function () {\n        var n = this;\n\n        if (!this.objectValue) {\n          var r = Ms.EMPTY;\n          $r(this.proto.fields || {}, function (t, e) {\n            r = r.set(new ji([t]), n.converter(e));\n          }), this.objectValue = r, this.fieldValueCache = void 0;\n        }\n\n        return this.objectValue;\n      }, Bs.prototype.value = function () {\n        return this.data().value();\n      }, Bs.prototype.isEqual = function (t) {\n        return t instanceof Bs && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.hasLocalMutations === t.hasLocalMutations && this.hasCommittedMutations === t.hasCommittedMutations && this.data().isEqual(t.data());\n      }, Bs.prototype.toString = function () {\n        return \"Document(\" + this.key + \", \" + this.version + \", \" + this.data().toString() + \", {hasLocalMutations: \" + this.hasLocalMutations + \"}), {hasCommittedMutations: \" + this.hasCommittedMutations + \"})\";\n      }, Object.defineProperty(Bs.prototype, \"hasPendingWrites\", {\n        get: function () {\n          return this.hasLocalMutations || this.hasCommittedMutations;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Bs.prototype.getProtoField = function (t) {\n        Ur(void 0 !== this.proto, \"Can only call getProtoField() when proto is defined\");\n\n        for (var e = this.proto.fields ? this.proto.fields[t.firstSegment()] : void 0, n = 1; n < t.length; ++n) {\n          if (!e || !e.mapValue || !e.mapValue.fields) return;\n          e = e.mapValue.fields[t.get(n)];\n        }\n\n        return e;\n      }, Bs.compareByField = function (t, e, n) {\n        var r = e.field(t),\n            i = n.field(t);\n        return null !== r && null !== i ? r.compareTo(i) : Br(\"Trying to compare documents on fields that don't exist\");\n      }, Bs);\n\n      function Bs(t, e, n, r, i, o) {\n        var a = qs.call(this, t, e) || this;\n        return a.objectValue = r, a.proto = i, a.converter = o, Ur(void 0 !== a.objectValue || void 0 !== a.proto && void 0 !== a.converter, \"If objectValue is not defined, proto and converter need to be set.\"), a.hasLocalMutations = !!n.hasLocalMutations, a.hasCommittedMutations = !!n.hasCommittedMutations, a;\n      }\n\n      var Us,\n          Ks = (t(Qs, Us = xs), Qs.prototype.toString = function () {\n        return \"NoDocument(\" + this.key + \", \" + this.version + \")\";\n      }, Object.defineProperty(Qs.prototype, \"hasPendingWrites\", {\n        get: function () {\n          return this.hasCommittedMutations;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Qs.prototype.isEqual = function (t) {\n        return t instanceof Qs && t.hasCommittedMutations === this.hasCommittedMutations && t.version.isEqual(this.version) && t.key.isEqual(this.key);\n      }, Qs);\n\n      function Qs(t, e, n) {\n        var r = Us.call(this, t, e) || this;\n        return r.hasCommittedMutations = !(!n || !n.hasCommittedMutations), r;\n      }\n\n      var js,\n          Gs = (t(Ws, js = xs), Ws.prototype.toString = function () {\n        return \"UnknownDocument(\" + this.key + \", \" + this.version + \")\";\n      }, Object.defineProperty(Ws.prototype, \"hasPendingWrites\", {\n        get: function () {\n          return !0;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Ws.prototype.isEqual = function (t) {\n        return t instanceof Ws && t.version.isEqual(this.version) && t.key.isEqual(this.key);\n      }, Ws);\n\n      function Ws() {\n        return null !== js && js.apply(this, arguments) || this;\n      }\n\n      var zs = (Hs.prototype.get = function (t) {\n        var e = this.mapKeyFn(t),\n            n = this.inner[e];\n        if (void 0 !== n) for (var r = 0, i = n; r < i.length; r++) {\n          var o = i[r],\n              a = o[0],\n              s = o[1];\n          if (a.isEqual(t)) return s;\n        }\n      }, Hs.prototype.has = function (t) {\n        return void 0 !== this.get(t);\n      }, Hs.prototype.set = function (t, e) {\n        var n = this.mapKeyFn(t),\n            r = this.inner[n];\n\n        if (void 0 !== r) {\n          for (var i = 0; i < r.length; i++) if (r[i][0].isEqual(t)) return void (r[i] = [t, e]);\n\n          r.push([t, e]);\n        } else this.inner[n] = [[t, e]];\n      }, Hs.prototype.delete = function (t) {\n        var e = this.mapKeyFn(t),\n            n = this.inner[e];\n        if (void 0 === n) return !1;\n\n        for (var r = 0; r < n.length; r++) if (n[r][0].isEqual(t)) return 1 === n.length ? delete this.inner[e] : n.splice(r, 1), !0;\n\n        return !1;\n      }, Hs.prototype.forEach = function (s) {\n        $r(this.inner, function (t, e) {\n          for (var n = 0, r = e; n < r.length; n++) {\n            var i = r[n],\n                o = i[0],\n                a = i[1];\n            s(o, a);\n          }\n        });\n      }, Hs.prototype.isEmpty = function () {\n        return ti(this.inner);\n      }, Hs);\n\n      function Hs(t) {\n        this.mapKeyFn = t, this.inner = {};\n      }\n\n      var Ys = (Object.defineProperty(Js.prototype, \"readTime\", {\n        get: function () {\n          return Ur(void 0 !== this._readTime, \"Read time is not set. All removeEntry() calls must include a readTime if `trackRemovals` is used.\"), this._readTime;\n        },\n        set: function (t) {\n          Ur(void 0 === this._readTime || this._readTime.isEqual(t), \"All changes in a RemoteDocumentChangeBuffer must have the same read time\"), this._readTime = t;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Js.prototype.addEntry = function (t, e) {\n        this.assertNotApplied(), this.readTime = e, this.changes.set(t.key, t);\n      }, Js.prototype.removeEntry = function (t, e) {\n        this.assertNotApplied(), e && (this.readTime = e), this.changes.set(t, null);\n      }, Js.prototype.getEntry = function (t, e) {\n        this.assertNotApplied();\n        var n = this.changes.get(e);\n        return void 0 !== n ? Uo.resolve(n) : this.getFromCache(t, e);\n      }, Js.prototype.getEntries = function (t, e) {\n        return this.getAllFromCache(t, e);\n      }, Js.prototype.apply = function (t) {\n        return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(t);\n      }, Js.prototype.assertNotApplied = function () {\n        Ur(!this.changesApplied, \"Changes have already been applied.\");\n      }, Js);\n\n      function Js() {\n        this.changes = new zs(function (t) {\n          return t.toString();\n        }), this.changesApplied = !1;\n      }\n\n      var Xs,\n          Zs = ($s.prototype.addEntry = function (t, e, n) {\n        return nu(t).put(ru(e), n);\n      }, $s.prototype.removeEntry = function (t, e) {\n        var n = nu(t),\n            r = ru(e);\n        return n.delete(r);\n      }, $s.prototype.updateMetadata = function (e, n) {\n        var r = this;\n        return this.getMetadata(e).next(function (t) {\n          return t.byteSize += n, r.setMetadata(e, t);\n        });\n      }, $s.prototype.getEntry = function (t, e) {\n        var n = this;\n        return nu(t).get(ru(e)).next(function (t) {\n          return n.maybeDecodeDocument(t);\n        });\n      }, $s.prototype.getSizedEntry = function (t, e) {\n        var n = this;\n        return nu(t).get(ru(e)).next(function (t) {\n          var e = n.maybeDecodeDocument(t);\n          return e ? {\n            maybeDocument: e,\n            size: iu(t)\n          } : null;\n        });\n      }, $s.prototype.getEntries = function (t, e) {\n        var r = this,\n            i = Ao();\n        return this.forEachDbEntry(t, e, function (t, e) {\n          var n = r.maybeDecodeDocument(e);\n          i = i.insert(t, n);\n        }).next(function () {\n          return i;\n        });\n      }, $s.prototype.getSizedEntries = function (t, e) {\n        var r = this,\n            i = Ao(),\n            o = new po(Wi.comparator);\n        return this.forEachDbEntry(t, e, function (t, e) {\n          var n = r.maybeDecodeDocument(e);\n          o = n ? (i = i.insert(t, n), o.insert(t, iu(e))) : (i = i.insert(t, null), o.insert(t, 0));\n        }).next(function () {\n          return {\n            maybeDocuments: i,\n            sizeMap: o\n          };\n        });\n      }, $s.prototype.forEachDbEntry = function (t, e, i) {\n        if (e.isEmpty()) return Uo.resolve();\n        var n = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()),\n            o = e.getIterator(),\n            a = o.getNext();\n        return nu(t).iterate({\n          range: n\n        }, function (t, e, n) {\n          for (var r = Wi.fromSegments(t); a && Wi.comparator(a, r) < 0;) i(a, null), a = o.getNext();\n\n          a && a.isEqual(r) && (i(a, e), a = o.hasNext() ? o.getNext() : null), a ? n.skip(a.path.toArray()) : n.done();\n        }).next(function () {\n          for (; a;) i(a, null), a = o.hasNext() ? o.getNext() : null;\n        });\n      }, $s.prototype.getDocumentsMatchingQuery = function (t, i, e) {\n        var o = this;\n        Ur(!i.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n        var a = Ro(),\n            s = i.path.length + 1,\n            n = {};\n\n        if (e.isEqual(lo.MIN)) {\n          var r = i.path.toArray();\n          n.range = IDBKeyRange.lowerBound(r);\n        } else {\n          var u = i.path.toArray(),\n              c = this.serializer.toDbTimestampKey(e);\n          n.range = IDBKeyRange.lowerBound([u, c], !0), n.index = Eu.collectionReadTimeIndex;\n        }\n\n        return nu(t).iterate(n, function (t, e, n) {\n          if (t.length === s) {\n            var r = o.serializer.fromDbRemoteDocument(e);\n            i.path.isPrefixOf(r.key.path) ? r instanceof Vs && i.matches(r) && (a = a.insert(r.key, r)) : n.done();\n          }\n        }).next(function () {\n          return a;\n        });\n      }, $s.prototype.getNewDocumentChanges = function (t, e) {\n        var r = this,\n            i = No(),\n            o = this.serializer.toDbTimestampKey(e),\n            n = nu(t),\n            a = IDBKeyRange.lowerBound(o, !0);\n        return n.iterate({\n          index: Eu.readTimeIndex,\n          range: a\n        }, function (t, e) {\n          var n = r.serializer.fromDbRemoteDocument(e);\n          i = i.insert(n.key, n), o = e.readTime;\n        }).next(function () {\n          return {\n            changedDocs: i,\n            readTime: r.serializer.fromDbTimestampKey(o)\n          };\n        });\n      }, $s.prototype.getLastDocumentChange = function (t) {\n        var r,\n            i = this,\n            e = nu(t),\n            o = lo.MIN;\n        return e.iterate({\n          index: Eu.readTimeIndex,\n          reverse: !0\n        }, function (t, e, n) {\n          r = i.serializer.fromDbRemoteDocument(e), e.readTime && (o = i.serializer.fromDbTimestampKey(e.readTime)), n.done();\n        }).next(function () {\n          return {\n            changedDoc: r,\n            readTime: o\n          };\n        });\n      }, $s.prototype.newChangeBuffer = function (t) {\n        return new $s.RemoteDocumentChangeBuffer(this, !!t && t.trackRemovals);\n      }, $s.prototype.getSize = function (t) {\n        return this.getMetadata(t).next(function (t) {\n          return t.byteSize;\n        });\n      }, $s.prototype.getMetadata = function (t) {\n        return eu(t).get(Cu.key).next(function (t) {\n          return Ur(!!t, \"Missing document cache metadata\"), t;\n        });\n      }, $s.prototype.setMetadata = function (t, e) {\n        return eu(t).put(Cu.key, e);\n      }, $s.prototype.maybeDecodeDocument = function (t) {\n        if (t) {\n          var e = this.serializer.fromDbRemoteDocument(t);\n          return e instanceof Ks && e.version.isEqual(lo.forDeletedDoc()) ? null : e;\n        }\n\n        return null;\n      }, $s.RemoteDocumentChangeBuffer = (t(tu, Xs = Ys), tu.prototype.applyChanges = function (a) {\n        var s = this,\n            u = [],\n            c = 0,\n            h = new So(function (t, e) {\n          return Si(t.canonicalString(), e.canonicalString());\n        });\n        return this.changes.forEach(function (t, e) {\n          var n = s.documentSizes.get(t);\n\n          if (Ur(void 0 !== n, \"Cannot modify a document that wasn't read (for \" + t + \")\"), e) {\n            Ur(!s.readTime.isEqual(lo.MIN), \"Cannot add a document with a read time of zero\");\n            var r = s.documentCache.serializer.toDbRemoteDocument(e, s.readTime);\n            h = h.add(t.path.popLast());\n            var i = iu(r);\n            c += i - n, u.push(s.documentCache.addEntry(a, t, r));\n          } else if (c -= n, s.trackRemovals) {\n            var o = s.documentCache.serializer.toDbRemoteDocument(new Ks(t, lo.forDeletedDoc()), s.readTime);\n            u.push(s.documentCache.addEntry(a, t, o));\n          } else u.push(s.documentCache.removeEntry(a, t));\n        }), h.forEach(function (t) {\n          u.push(s.documentCache.indexManager.addToCollectionParentIndex(a, t));\n        }), u.push(this.documentCache.updateMetadata(a, c)), Uo.waitFor(u);\n      }, tu.prototype.getFromCache = function (t, e) {\n        var n = this;\n        return this.documentCache.getSizedEntry(t, e).next(function (t) {\n          return null === t ? (n.documentSizes.set(e, 0), null) : (n.documentSizes.set(e, t.size), t.maybeDocument);\n        });\n      }, tu.prototype.getAllFromCache = function (t, e) {\n        var n = this;\n        return this.documentCache.getSizedEntries(t, e).next(function (t) {\n          var e = t.maybeDocuments;\n          return t.sizeMap.forEach(function (t, e) {\n            n.documentSizes.set(t, e);\n          }), e;\n        });\n      }, tu), $s);\n\n      function $s(t, e) {\n        this.serializer = t, this.indexManager = e;\n      }\n\n      function tu(t, e) {\n        var n = Xs.call(this) || this;\n        return n.documentCache = t, n.trackRemovals = e, n.documentSizes = new zs(function (t) {\n          return t.toString();\n        }), n;\n      }\n\n      function eu(t) {\n        return fc.getStore(t, Cu.store);\n      }\n\n      function nu(t) {\n        return fc.getStore(t, Eu.store);\n      }\n\n      function ru(t) {\n        return t.path.toArray();\n      }\n\n      function iu(t) {\n        var e;\n        if (t.document) e = t.document;else if (t.unknownDocument) e = t.unknownDocument;else {\n          if (!t.noDocument) throw Br(\"Unknown remote document type\");\n          e = t.noDocument;\n        }\n        return JSON.stringify(e).length;\n      }\n\n      var ou = (au.prototype.addToCollectionParentIndex = function (t, e) {\n        return this.collectionParentIndex.add(e), Uo.resolve();\n      }, au.prototype.getCollectionParents = function (t, e) {\n        return Uo.resolve(this.collectionParentIndex.getEntries(e));\n      }, au);\n\n      function au() {\n        this.collectionParentIndex = new su();\n      }\n\n      var su = (uu.prototype.add = function (t) {\n        Ur(t.length % 2 == 1, \"Expected a collection path.\");\n        var e = t.lastSegment(),\n            n = t.popLast(),\n            r = this.index[e] || new So(Bi.comparator),\n            i = !r.has(n);\n        return this.index[e] = r.add(n), i;\n      }, uu.prototype.has = function (t) {\n        var e = t.lastSegment(),\n            n = t.popLast(),\n            r = this.index[e];\n        return r && r.has(n);\n      }, uu.prototype.getEntries = function (t) {\n        return (this.index[t] || new So(Bi.comparator)).toArray();\n      }, uu);\n\n      function uu() {\n        this.index = {};\n      }\n\n      var cu = 9,\n          hu = (lu.prototype.createOrUpgrade = function (t, e, n, r) {\n        var i = this;\n        Ur(n < r && 0 <= n && r <= cu, \"Unexpected schema upgrade from v\" + n + \" to v{toVersion}.\");\n        var o = new Ho(e);\n        n < 1 && 1 <= r && (function (t) {\n          t.createObjectStore(pu.store);\n        }(t), function (t) {\n          t.createObjectStore(mu.store, {\n            keyPath: mu.keyPath\n          }), t.createObjectStore(gu.store, {\n            keyPath: gu.keyPath,\n            autoIncrement: !0\n          }).createIndex(gu.userMutationsIndex, gu.userMutationsKeyPath, {\n            unique: !0\n          }), t.createObjectStore(bu.store);\n        }(t), Pu(t), function (t) {\n          t.createObjectStore(Eu.store);\n        }(t));\n        var a = Uo.resolve();\n        return n < 3 && 3 <= r && (0 !== n && (function (t) {\n          t.deleteObjectStore(ku.store), t.deleteObjectStore(Nu.store), t.deleteObjectStore(Mu.store);\n        }(t), Pu(t)), a = a.next(function () {\n          return function (t) {\n            var e = t.store(Mu.store),\n                n = new Mu(0, 0, lo.MIN.toTimestamp(), 0);\n            return e.put(Mu.key, n);\n          }(o);\n        })), n < 4 && 4 <= r && (0 !== n && (a = a.next(function () {\n          return function (r, i) {\n            return i.store(gu.store).loadAll().next(function (t) {\n              r.deleteObjectStore(gu.store), r.createObjectStore(gu.store, {\n                keyPath: gu.keyPath,\n                autoIncrement: !0\n              }).createIndex(gu.userMutationsIndex, gu.userMutationsKeyPath, {\n                unique: !0\n              });\n              var e = i.store(gu.store),\n                  n = t.map(function (t) {\n                return e.put(t);\n              });\n              return Uo.waitFor(n);\n            });\n          }(t, o);\n        })), a = a.next(function () {\n          !function (t) {\n            t.createObjectStore(xu.store, {\n              keyPath: xu.keyPath\n            });\n          }(t);\n        })), n < 5 && 5 <= r && (a = a.next(function () {\n          return i.removeAcknowledgedMutations(o);\n        })), n < 6 && 6 <= r && (a = a.next(function () {\n          return function (t) {\n            t.createObjectStore(Cu.store);\n          }(t), i.addDocumentGlobal(o);\n        })), n < 7 && 7 <= r && (a = a.next(function () {\n          return i.ensureSequenceNumbers(o);\n        })), n < 8 && 8 <= r && (a = a.next(function () {\n          return i.createCollectionParentIndex(t, o);\n        })), n < 9 && 9 <= r && (a = a.next(function () {\n          !function (t) {\n            t.objectStoreNames.contains(\"remoteDocumentChanges\") && t.deleteObjectStore(\"remoteDocumentChanges\");\n          }(t), function (t) {\n            var e = t.objectStore(Eu.store);\n            e.createIndex(Eu.readTimeIndex, Eu.readTimeIndexPath, {\n              unique: !1\n            }), e.createIndex(Eu.collectionReadTimeIndex, Eu.collectionReadTimeIndexPath, {\n              unique: !1\n            });\n          }(e);\n        })), a;\n      }, lu.prototype.addDocumentGlobal = function (e) {\n        var n = 0;\n        return e.store(Eu.store).iterate(function (t, e) {\n          n += iu(e);\n        }).next(function () {\n          var t = new Cu(n);\n          return e.store(Cu.store).put(Cu.key, t);\n        });\n      }, lu.prototype.removeAcknowledgedMutations = function (r) {\n        var i = this,\n            t = r.store(mu.store),\n            e = r.store(gu.store);\n        return t.loadAll().next(function (t) {\n          return Uo.forEach(t, function (n) {\n            var t = IDBKeyRange.bound([n.userId, -1], [n.userId, n.lastAcknowledgedBatchId]);\n            return e.loadAll(gu.userMutationsIndex, t).next(function (t) {\n              return Uo.forEach(t, function (t) {\n                Ur(t.userId === n.userId, \"Cannot process batch \" + t.batchId + \" from unexpected user\");\n                var e = i.serializer.fromDbMutationBatch(t);\n                return ia(r, n.userId, e).next(function () {});\n              });\n            });\n          });\n        });\n      }, lu.prototype.ensureSequenceNumbers = function (t) {\n        var a = t.store(ku.store),\n            e = t.store(Eu.store);\n        return ga(t).next(function (i) {\n          var o = [];\n          return e.iterate(function (t, e) {\n            var n = new Bi(t),\n                r = function (t) {\n              return [0, oo(t)];\n            }(n);\n\n            o.push(a.get(r).next(function (t) {\n              return t ? Uo.resolve() : function (t) {\n                return a.put(new ku(0, oo(t), i));\n              }(n);\n            }));\n          }).next(function () {\n            return Uo.waitFor(o);\n          });\n        });\n      }, lu.prototype.createCollectionParentIndex = function (t, e) {\n        function i(t) {\n          if (o.add(t)) {\n            var e = t.lastSegment(),\n                n = t.popLast();\n            return r.put({\n              collectionId: e,\n              parent: oo(n)\n            });\n          }\n        }\n\n        t.createObjectStore(Lu.store, {\n          keyPath: Lu.keyPath\n        });\n        var r = e.store(Lu.store),\n            o = new su();\n        return e.store(Eu.store).iterate({\n          keysOnly: !0\n        }, function (t, e) {\n          var n = new Bi(t);\n          return i(n.popLast());\n        }).next(function () {\n          return e.store(bu.store).iterate({\n            keysOnly: !0\n          }, function (t, e) {\n            t[0];\n            var n = t[1],\n                r = (t[2], uo(n));\n            return i(r.popLast());\n          });\n        });\n      }, lu);\n\n      function lu(t) {\n        this.serializer = t;\n      }\n\n      var fu = function (t, e) {\n        this.seconds = t, this.nanoseconds = e;\n      },\n          pu = (du.store = \"owner\", du.key = \"owner\", du);\n\n      function du(t, e, n) {\n        this.ownerId = t, this.allowTabSynchronization = e, this.leaseTimestampMs = n;\n      }\n\n      var mu = (yu.store = \"mutationQueues\", yu.keyPath = \"userId\", yu);\n\n      function yu(t, e, n) {\n        this.userId = t, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;\n      }\n\n      var gu = (vu.store = \"mutations\", vu.keyPath = \"batchId\", vu.userMutationsIndex = \"userMutationsIndex\", vu.userMutationsKeyPath = [\"userId\", \"batchId\"], vu);\n\n      function vu(t, e, n, r, i) {\n        this.userId = t, this.batchId = e, this.localWriteTimeMs = n, this.baseMutations = r, this.mutations = i;\n      }\n\n      var bu = (wu.prefixForUser = function (t) {\n        return [t];\n      }, wu.prefixForPath = function (t, e) {\n        return [t, oo(e)];\n      }, wu.key = function (t, e, n) {\n        return [t, oo(e), n];\n      }, wu.store = \"documentMutations\", wu.PLACEHOLDER = new wu(), wu);\n\n      function wu() {}\n\n      var Tu = function (t, e) {\n        this.path = t, this.readTime = e;\n      },\n          Su = function (t, e) {\n        this.path = t, this.version = e;\n      },\n          Eu = (Iu.store = \"remoteDocuments\", Iu.readTimeIndex = \"readTimeIndex\", Iu.readTimeIndexPath = \"readTime\", Iu.collectionReadTimeIndex = \"collectionReadTimeIndex\", Iu.collectionReadTimeIndexPath = [\"parentPath\", \"readTime\"], Iu);\n\n      function Iu(t, e, n, r, i, o) {\n        this.unknownDocument = t, this.noDocument = e, this.document = n, this.hasCommittedMutations = r, this.readTime = i, this.parentPath = o;\n      }\n\n      var Cu = (Du.store = \"remoteDocumentGlobal\", Du.key = \"remoteDocumentGlobalKey\", Du);\n\n      function Du(t) {\n        this.byteSize = t;\n      }\n\n      var Nu = (Au.store = \"targets\", Au.keyPath = \"targetId\", Au.queryTargetsIndexName = \"queryTargetsIndex\", Au.queryTargetsKeyPath = [\"canonicalId\", \"targetId\"], Au);\n\n      function Au(t, e, n, r, i, o, a) {\n        this.targetId = t, this.canonicalId = e, this.readTime = n, this.resumeToken = r, this.lastListenSequenceNumber = i, this.lastLimboFreeSnapshotVersion = o, this.query = a;\n      }\n\n      var ku = (Ru.store = \"targetDocuments\", Ru.keyPath = [\"targetId\", \"path\"], Ru.documentTargetsIndex = \"documentTargetsIndex\", Ru.documentTargetsKeyPath = [\"path\", \"targetId\"], Ru);\n\n      function Ru(t, e, n) {\n        this.targetId = t, this.path = e, Ur(0 === t == (void 0 !== (this.sequenceNumber = n)), \"A target-document row must either have targetId == 0 and a defined sequence number, or a non-zero targetId and no sequence number\");\n      }\n\n      var Mu = (_u.key = \"targetGlobalKey\", _u.store = \"targetGlobal\", _u);\n\n      function _u(t, e, n, r) {\n        this.highestTargetId = t, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = r;\n      }\n\n      var Lu = (Ou.store = \"collectionParents\", Ou.keyPath = [\"collectionId\", \"parent\"], Ou);\n\n      function Ou(t, e) {\n        this.collectionId = t, this.parent = e;\n      }\n\n      function Pu(t) {\n        t.createObjectStore(ku.store, {\n          keyPath: ku.keyPath\n        }).createIndex(ku.documentTargetsIndex, ku.documentTargetsKeyPath, {\n          unique: !0\n        }), t.createObjectStore(Nu.store, {\n          keyPath: Nu.keyPath\n        }).createIndex(Nu.queryTargetsIndexName, Nu.queryTargetsKeyPath, {\n          unique: !0\n        }), t.createObjectStore(Mu.store);\n      }\n\n      var xu = (Fu.store = \"clientMetadata\", Fu.keyPath = \"clientId\", Fu);\n\n      function Fu(t, e, n, r) {\n        this.clientId = t, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = r;\n      }\n\n      var qu,\n          Vu,\n          Bu = a(a(a([mu.store, gu.store, bu.store, Eu.store, Nu.store, pu.store, Mu.store, ku.store], [xu.store]), [Cu.store]), [Lu.store]),\n          Uu = (Ku.prototype.addToCollectionParentIndex = function (t, e) {\n        var n = this;\n        if (Ur(e.length % 2 == 1, \"Expected a collection path.\"), this.collectionParentsCache.has(e)) return Uo.resolve();\n        var r = e.lastSegment(),\n            i = e.popLast();\n        t.addOnCommittedListener(function () {\n          n.collectionParentsCache.add(e);\n        });\n        var o = {\n          collectionId: r,\n          parent: oo(i)\n        };\n        return Qu(t).put(o);\n      }, Ku.prototype.getCollectionParents = function (t, i) {\n        var o = [],\n            e = IDBKeyRange.bound([i, \"\"], [Ii(i), \"\"], !1, !0);\n        return Qu(t).loadAll(e).next(function (t) {\n          for (var e = 0, n = t; e < n.length; e++) {\n            var r = n[e];\n            if (r.collectionId !== i) break;\n            o.push(uo(r.parent));\n          }\n\n          return o;\n        });\n      }, Ku);\n\n      function Ku() {\n        this.collectionParentsCache = new su();\n      }\n\n      function Qu(t) {\n        return fc.getStore(t, Lu.store);\n      }\n\n      (Vu = qu = qu || {})[Vu.Listen = 0] = \"Listen\", Vu[Vu.ExistenceFilterMismatch = 1] = \"ExistenceFilterMismatch\", Vu[Vu.LimboResolution = 2] = \"LimboResolution\";\n      var ju = (Gu.prototype.withSequenceNumber = function (t) {\n        return new Gu(this.target, this.targetId, this.purpose, t, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);\n      }, Gu.prototype.withResumeToken = function (t, e) {\n        return new Gu(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t);\n      }, Gu.prototype.withLastLimboFreeSnapshotVersion = function (t) {\n        return new Gu(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t, this.resumeToken);\n      }, Gu.prototype.isEqual = function (t) {\n        return this.targetId === t.targetId && this.purpose === t.purpose && this.sequenceNumber === t.sequenceNumber && this.snapshotVersion.isEqual(t.snapshotVersion) && this.lastLimboFreeSnapshotVersion.isEqual(t.lastLimboFreeSnapshotVersion) && this.resumeToken === t.resumeToken && this.target.isEqual(t.target);\n      }, Gu);\n\n      function Gu(t, e, n, r, i, o, a) {\n        void 0 === i && (i = lo.MIN), void 0 === o && (o = lo.MIN), void 0 === a && (a = jr()), this.target = t, this.targetId = e, this.purpose = n, this.sequenceNumber = r, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = o, this.resumeToken = a;\n      }\n\n      var Wu = (zu.prototype.fromDbRemoteDocument = function (t) {\n        if (t.document) return this.remoteSerializer.fromDocument(t.document, !!t.hasCommittedMutations);\n\n        if (t.noDocument) {\n          var e = Wi.fromSegments(t.noDocument.path),\n              n = this.fromDbTimestamp(t.noDocument.readTime);\n          return new Ks(e, n, {\n            hasCommittedMutations: !!t.hasCommittedMutations\n          });\n        }\n\n        return t.unknownDocument ? (e = Wi.fromSegments(t.unknownDocument.path), n = this.fromDbTimestamp(t.unknownDocument.version), new Gs(e, n)) : Br(\"Unexpected DbRemoteDocument\");\n      }, zu.prototype.toDbRemoteDocument = function (t, e) {\n        var n = this.toDbTimestampKey(e),\n            r = t.key.path.popLast().toArray();\n\n        if (t instanceof Vs) {\n          var i = t.proto ? t.proto : this.remoteSerializer.toDocument(t),\n              o = t.hasCommittedMutations;\n          return new Eu(null, null, i, o, n, r);\n        }\n\n        if (t instanceof Ks) {\n          var a = t.key.path.toArray(),\n              s = this.toDbTimestamp(t.version);\n          return o = t.hasCommittedMutations, new Eu(null, new Tu(a, s), null, o, n, r);\n        }\n\n        if (t instanceof Gs) {\n          a = t.key.path.toArray();\n          var u = this.toDbTimestamp(t.version);\n          return new Eu(new Su(a, u), null, null, !0, n, r);\n        }\n\n        return Br(\"Unexpected MaybeDocument\");\n      }, zu.prototype.toDbTimestampKey = function (t) {\n        var e = t.toTimestamp();\n        return [e.seconds, e.nanoseconds];\n      }, zu.prototype.fromDbTimestampKey = function (t) {\n        var e = new co(t[0], t[1]);\n        return lo.fromTimestamp(e);\n      }, zu.prototype.toDbTimestamp = function (t) {\n        var e = t.toTimestamp();\n        return new fu(e.seconds, e.nanoseconds);\n      }, zu.prototype.fromDbTimestamp = function (t) {\n        var e = new co(t.seconds, t.nanoseconds);\n        return lo.fromTimestamp(e);\n      }, zu.prototype.toDbMutationBatch = function (t, e) {\n        var n = this,\n            r = e.baseMutations.map(function (t) {\n          return n.remoteSerializer.toMutation(t);\n        }),\n            i = e.mutations.map(function (t) {\n          return n.remoteSerializer.toMutation(t);\n        });\n        return new gu(t, e.batchId, e.localWriteTime.toMillis(), r, i);\n      }, zu.prototype.fromDbMutationBatch = function (t) {\n        var e = this,\n            n = (t.baseMutations || []).map(function (t) {\n          return e.remoteSerializer.fromMutation(t);\n        }),\n            r = t.mutations.map(function (t) {\n          return e.remoteSerializer.fromMutation(t);\n        }),\n            i = co.fromMillis(t.localWriteTimeMs);\n        return new Fo(t.batchId, i, n, r);\n      }, zu.prototype.toDbResourcePaths = function (t) {\n        var e = [];\n        return t.forEach(function (t) {\n          e.push(oo(t.path));\n        }), e;\n      }, zu.prototype.fromDbResourcePaths = function (t) {\n        for (var e = Oo(), n = 0, r = t; n < r.length; n++) {\n          var i = r[n];\n          e = e.add(new Wi(uo(i)));\n        }\n\n        return e;\n      }, zu.prototype.fromDbTarget = function (t) {\n        var e,\n            n = this.fromDbTimestamp(t.readTime),\n            r = void 0 !== t.lastLimboFreeSnapshotVersion ? this.fromDbTimestamp(t.lastLimboFreeSnapshotVersion) : lo.MIN,\n            i = t.resumeToken;\n        return e = function (t) {\n          return void 0 !== t.documents;\n        }(t.query) ? this.remoteSerializer.fromDocumentsTarget(t.query) : this.remoteSerializer.fromQueryTarget(t.query), new ju(e, t.targetId, qu.Listen, t.lastListenSequenceNumber, n, r, i);\n      }, zu.prototype.toDbTarget = function (t) {\n        Ur(qu.Listen === t.purpose, \"Only queries with purpose \" + qu.Listen + \" may be stored, got \" + t.purpose);\n        var e,\n            n,\n            r = this.toDbTimestamp(t.snapshotVersion),\n            i = this.toDbTimestamp(t.lastLimboFreeSnapshotVersion);\n        return e = t.target.isDocumentQuery() ? this.remoteSerializer.toDocumentsTarget(t.target) : this.remoteSerializer.toQueryTarget(t.target), n = t.resumeToken instanceof Uint8Array ? (Ur(jo.isMockPersistence(), \"Persisting non-string stream tokens is only supported with mock persistence .\"), t.resumeToken.toString()) : t.resumeToken, new Nu(t.targetId, t.target.canonicalId(), r, n, t.sequenceNumber, i, e);\n      }, zu);\n\n      function zu(t) {\n        this.remoteSerializer = t;\n      }\n\n      function Hu(t, e) {\n        var n = t[0],\n            r = t[1],\n            i = e[0],\n            o = e[1],\n            a = Si(n, i);\n        return 0 === a ? Si(r, o) : a;\n      }\n\n      var Yu = (Ju.prototype.nextIndex = function () {\n        return ++this.previousIndex;\n      }, Ju.prototype.addElement = function (t) {\n        var e = [t, this.nextIndex()];\n        if (this.buffer.size < this.maxElements) this.buffer = this.buffer.add(e);else {\n          var n = this.buffer.last();\n          Hu(e, n) < 0 && (this.buffer = this.buffer.delete(n).add(e));\n        }\n      }, Object.defineProperty(Ju.prototype, \"maxValue\", {\n        get: function () {\n          return this.buffer.last()[0];\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Ju);\n\n      function Ju(t) {\n        this.maxElements = t, this.buffer = new So(Hu), this.previousIndex = 0;\n      }\n\n      var Xu = {\n        didRun: !1,\n        sequenceNumbersCollected: 0,\n        targetsRemoved: 0,\n        documentsRemoved: 0\n      },\n          Zu = ($u.withCacheSize = function (t) {\n        return new $u(t, $u.DEFAULT_COLLECTION_PERCENTILE, $u.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);\n      }, $u.COLLECTION_DISABLED = -1, $u.MINIMUM_CACHE_SIZE_BYTES = 1048576, $u.DEFAULT = new $u($u.DEFAULT_CACHE_SIZE_BYTES = 41943040, $u.DEFAULT_COLLECTION_PERCENTILE = 10, $u.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3), $u.DISABLED = new $u($u.COLLECTION_DISABLED, 0, 0), $u);\n\n      function $u(t, e, n) {\n        this.cacheSizeCollectionThreshold = t, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;\n      }\n\n      var tc = (ec.prototype.start = function () {\n        Ur(null === this.gcTask, \"Cannot start an already started LruScheduler\"), this.garbageCollector.params.cacheSizeCollectionThreshold !== Zu.COLLECTION_DISABLED && this.scheduleGC();\n      }, ec.prototype.stop = function () {\n        this.gcTask && (this.gcTask.cancel(), this.gcTask = null);\n      }, Object.defineProperty(ec.prototype, \"started\", {\n        get: function () {\n          return null !== this.gcTask;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), ec.prototype.scheduleGC = function () {\n        var t = this;\n        Ur(null === this.gcTask, \"Cannot schedule GC while a task is pending\");\n        var e = this.hasRun ? 3e5 : 6e4;\n        Fr(\"LruGarbageCollector\", \"Garbage collection scheduled in \" + e + \"ms\"), this.gcTask = this.asyncQueue.enqueueAfterDelay(Hi.LruGarbageCollection, e, function () {\n          return t.gcTask = null, t.hasRun = !0, t.localStore.collectGarbage(t.garbageCollector).then(function () {\n            return t.scheduleGC();\n          }).catch(dc);\n        });\n      }, ec);\n\n      function ec(t, e, n) {\n        this.garbageCollector = t, this.asyncQueue = e, this.localStore = n, this.hasRun = !1, this.gcTask = null;\n      }\n\n      var nc = (rc.prototype.calculateTargetCount = function (t, e) {\n        return this.delegate.getSequenceNumberCount(t).next(function (t) {\n          return Math.floor(e / 100 * t);\n        });\n      }, rc.prototype.nthSequenceNumber = function (t, e) {\n        var n = this;\n        if (0 === e) return Uo.resolve(Oi.INVALID);\n        var r = new Yu(e);\n        return this.delegate.forEachTarget(t, function (t) {\n          return r.addElement(t.sequenceNumber);\n        }).next(function () {\n          return n.delegate.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n            return r.addElement(t);\n          });\n        }).next(function () {\n          return r.maxValue;\n        });\n      }, rc.prototype.removeTargets = function (t, e, n) {\n        return this.delegate.removeTargets(t, e, n);\n      }, rc.prototype.removeOrphanedDocuments = function (t, e) {\n        return this.delegate.removeOrphanedDocuments(t, e);\n      }, rc.prototype.collect = function (e, n) {\n        var r = this;\n        return this.params.cacheSizeCollectionThreshold === Zu.COLLECTION_DISABLED ? (Fr(\"LruGarbageCollector\", \"Garbage collection skipped; disabled\"), Uo.resolve(Xu)) : this.getCacheSize(e).next(function (t) {\n          return t < r.params.cacheSizeCollectionThreshold ? (Fr(\"LruGarbageCollector\", \"Garbage collection skipped; Cache size \" + t + \" is lower than threshold \" + r.params.cacheSizeCollectionThreshold), Xu) : r.runGarbageCollection(e, n);\n        });\n      }, rc.prototype.getCacheSize = function (t) {\n        return this.delegate.getCacheSize(t);\n      }, rc.prototype.runGarbageCollection = function (e, n) {\n        var r,\n            i,\n            o,\n            a,\n            s,\n            u,\n            c,\n            h = this,\n            l = Date.now();\n        return this.calculateTargetCount(e, this.params.percentileToCollect).next(function (t) {\n          return i = t > h.params.maximumSequenceNumbersToCollect ? (Fr(\"LruGarbageCollector\", \"Capping sequence numbers to collect down to the maximum of \" + h.params.maximumSequenceNumbersToCollect + \" from \" + t), h.params.maximumSequenceNumbersToCollect) : t, a = Date.now(), h.nthSequenceNumber(e, i);\n        }).next(function (t) {\n          return r = t, s = Date.now(), h.removeTargets(e, r, n);\n        }).next(function (t) {\n          return o = t, u = Date.now(), h.removeOrphanedDocuments(e, r);\n        }).next(function (t) {\n          return c = Date.now(), Pr() <= Cr.DEBUG && Fr(\"LruGarbageCollector\", \"LRU Garbage Collection\\n\\tCounted targets in \" + (a - l) + \"ms\\n\\tDetermined least recently used \" + i + \" in \" + (s - a) + \"ms\\n\\tRemoved \" + o + \" targets in \" + (u - s) + \"ms\\n\\tRemoved \" + t + \" documents in \" + (c - u) + \"ms\\nTotal Duration: \" + (c - l) + \"ms\"), Uo.resolve({\n            didRun: !0,\n            sequenceNumbersCollected: i,\n            targetsRemoved: o,\n            documentsRemoved: t\n          });\n        });\n      }, rc);\n\n      function rc(t, e) {\n        this.delegate = t, this.params = e;\n      }\n\n      var ic = (oc.prototype.addOnCommittedListener = function (t) {\n        this.onCommittedListeners.push(t);\n      }, oc.prototype.raiseOnCommittedEvent = function () {\n        this.onCommittedListeners.forEach(function (t) {\n          return t();\n        });\n      }, oc);\n\n      function oc() {\n        this.onCommittedListeners = [];\n      }\n\n      var ac,\n          sc = \"IndexedDbPersistence\",\n          uc = \"The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.\",\n          cc = \"Another tab has exclusive access to the persistence layer. To allow shared access, make sure to invoke `enablePersistence()` with `synchronizeTabs:true` in all tabs.\",\n          hc = (t(lc, ac = ic), lc);\n\n      function lc(t, e) {\n        var n = ac.call(this) || this;\n        return n.simpleDbTransaction = t, n.currentSequenceNumber = e, n;\n      }\n\n      var fc = (pc.getStore = function (t, e) {\n        if (t instanceof hc) return jo.getStore(t.simpleDbTransaction, e);\n        throw Br(\"IndexedDbPersistence must use instances of IndexedDbTransaction\");\n      }, pc.createIndexedDbPersistence = function (n) {\n        return p(this, void 0, void 0, function () {\n          var e;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                if (!pc.isAvailable()) throw new zr(Wr.UNIMPLEMENTED, \"This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.\");\n                return [4, (e = new pc(n.allowTabSynchronization, n.persistenceKey, n.clientId, n.platform, n.lruParams, n.queue, n.serializer, n.sequenceNumberSyncer)).start()];\n\n              case 1:\n                return t.sent(), [2, e];\n            }\n          });\n        });\n      }, pc.prototype.start = function () {\n        var e = this;\n        return Ur(!this.started, \"IndexedDbPersistence double-started!\"), Ur(null !== this.window, \"Expected 'window' to be defined\"), jo.openOrCreate(this.dbName, cu, new hu(this.serializer)).then(function (t) {\n          return e.simpleDb = t, e.updateClientMetadataAndTryBecomePrimary();\n        }).then(function () {\n          return e.attachVisibilityHandler(), e.attachWindowUnloadHook(), e.scheduleClientMetadataAndPrimaryLeaseRefreshes(), e.simpleDb.runTransaction(\"readonly-idempotent\", [Mu.store], function (t) {\n            return ga(t);\n          });\n        }).then(function (t) {\n          e.listenSequence = new Oi(t, e.sequenceNumberSyncer);\n        }).then(function () {\n          e._started = !0;\n        }).catch(function (t) {\n          return e.simpleDb && e.simpleDb.close(), Promise.reject(t);\n        });\n      }, pc.prototype.setPrimaryStateListener = function (n) {\n        var t = this;\n        return this.primaryStateListener = function (e) {\n          return p(t, void 0, void 0, function () {\n            return m(this, function (t) {\n              return this.started ? [2, n(e)] : [2];\n            });\n          });\n        }, n(this.isPrimary);\n      }, pc.prototype.setDatabaseDeletedListener = function (n) {\n        var t = this;\n        this.simpleDb.setVersionChangeListener(function (e) {\n          return p(t, void 0, void 0, function () {\n            return m(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return null !== e.newVersion ? [3, 2] : [4, n()];\n\n                case 1:\n                  t.sent(), t.label = 2;\n\n                case 2:\n                  return [2];\n              }\n            });\n          });\n        });\n      }, pc.prototype.setNetworkEnabled = function (t) {\n        var e = this;\n        this.networkEnabled !== t && (this.networkEnabled = t, this.queue.enqueueAndForget(function () {\n          return p(e, void 0, void 0, function () {\n            return m(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.started ? [4, this.updateClientMetadataAndTryBecomePrimary()] : [3, 2];\n\n                case 1:\n                  t.sent(), t.label = 2;\n\n                case 2:\n                  return [2];\n              }\n            });\n          });\n        }));\n      }, pc.prototype.updateClientMetadataAndTryBecomePrimary = function () {\n        var n = this;\n        return this.simpleDb.runTransaction(\"readwrite-idempotent\", Bu, function (e) {\n          return yc(e).put(new xu(n.clientId, Date.now(), n.networkEnabled, n.inForeground)).next(function () {\n            if (n.isPrimary) return n.verifyPrimaryLease(e).next(function (t) {\n              t || (n.isPrimary = !1, n.queue.enqueueAndForget(function () {\n                return n.primaryStateListener(!1);\n              }));\n            });\n          }).next(function () {\n            return n.canActAsPrimary(e);\n          }).next(function (t) {\n            return n.isPrimary && !t ? n.releasePrimaryLeaseIfHeld(e).next(function () {\n              return !1;\n            }) : !!t && n.acquireOrExtendPrimaryLease(e).next(function () {\n              return !0;\n            });\n          });\n        }).catch(function (t) {\n          if (!n.allowTabSynchronization) throw t;\n          return Fr(sc, \"Releasing owner lease after error during lease refresh\", t), !1;\n        }).then(function (t) {\n          n.isPrimary !== t && n.queue.enqueueAndForget(function () {\n            return n.primaryStateListener(t);\n          }), n.isPrimary = t;\n        });\n      }, pc.prototype.verifyPrimaryLease = function (t) {\n        var e = this;\n        return mc(t).get(pu.key).next(function (t) {\n          return Uo.resolve(e.isLocalClient(t));\n        });\n      }, pc.prototype.removeClientMetadata = function (t) {\n        return yc(t).delete(this.clientId);\n      }, pc.prototype.maybeGarbageCollectMultiClientState = function () {\n        return p(this, void 0, void 0, function () {\n          var i = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return !this.isPrimary || this.isWithinAge(this.lastGarbageCollectionTime, 18e5) ? [3, 2] : (this.lastGarbageCollectionTime = Date.now(), [4, this.runTransaction(\"maybeGarbageCollectMultiClientState\", \"readwrite-primary-idempotent\", function (t) {\n                  var r = pc.getStore(t, xu.store);\n                  return r.loadAll().next(function (t) {\n                    var e = i.filterActiveClients(t, 18e5),\n                        n = t.filter(function (t) {\n                      return -1 === e.indexOf(t);\n                    });\n                    return Uo.forEach(n, function (t) {\n                      return r.delete(t.clientId);\n                    }).next(function () {\n                      return n;\n                    });\n                  });\n                })]);\n\n              case 1:\n                t.sent().forEach(function (t) {\n                  i.window.localStorage.removeItem(i.zombiedClientLocalStorageKey(t.clientId));\n                }), t.label = 2;\n\n              case 2:\n                return [2];\n            }\n          });\n        });\n      }, pc.prototype.scheduleClientMetadataAndPrimaryLeaseRefreshes = function () {\n        var t = this;\n        this.clientMetadataRefresher = this.queue.enqueueAfterDelay(Hi.ClientMetadataRefresh, 4e3, function () {\n          return t.updateClientMetadataAndTryBecomePrimary().then(function () {\n            return t.maybeGarbageCollectMultiClientState();\n          }).then(function () {\n            return t.scheduleClientMetadataAndPrimaryLeaseRefreshes();\n          });\n        });\n      }, pc.prototype.isLocalClient = function (t) {\n        return !!t && t.ownerId === this.clientId;\n      }, pc.prototype.canActAsPrimary = function (e) {\n        var i = this;\n        return mc(e).get(pu.key).next(function (t) {\n          if (null !== t && i.isWithinAge(t.leaseTimestampMs, 5e3) && !i.isClientZombied(t.ownerId)) {\n            if (i.isLocalClient(t) && i.networkEnabled) return !0;\n\n            if (!i.isLocalClient(t)) {\n              if (!t.allowTabSynchronization) throw new zr(Wr.FAILED_PRECONDITION, cc);\n              return !1;\n            }\n          }\n\n          return !(!i.networkEnabled || !i.inForeground) || yc(e).loadAll().next(function (t) {\n            return void 0 === i.filterActiveClients(t, 5e3).find(function (t) {\n              if (i.clientId !== t.clientId) {\n                var e = !i.networkEnabled && t.networkEnabled,\n                    n = !i.inForeground && t.inForeground,\n                    r = i.networkEnabled === t.networkEnabled;\n                if (e || n && r) return !0;\n              }\n\n              return !1;\n            });\n          });\n        }).next(function (t) {\n          return i.isPrimary !== t && Fr(sc, \"Client \" + (t ? \"is\" : \"is not\") + \" eligible for a primary lease.\"), t;\n        });\n      }, pc.prototype.shutdown = function () {\n        return p(this, void 0, void 0, function () {\n          var e = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this._started = !1, this.markClientZombied(), this.clientMetadataRefresher && (this.clientMetadataRefresher.cancel(), this.clientMetadataRefresher = null), this.detachVisibilityHandler(), this.detachWindowUnloadHook(), [4, this.simpleDb.runTransaction(\"readwrite-idempotent\", [pu.store, xu.store], function (t) {\n                  return e.releasePrimaryLeaseIfHeld(t).next(function () {\n                    return e.removeClientMetadata(t);\n                  });\n                })];\n\n              case 1:\n                return t.sent(), this.simpleDb.close(), this.removeClientZombiedEntry(), [2];\n            }\n          });\n        });\n      }, pc.prototype.filterActiveClients = function (t, e) {\n        var n = this;\n        return t.filter(function (t) {\n          return n.isWithinAge(t.updateTimeMs, e) && !n.isClientZombied(t.clientId);\n        });\n      }, pc.prototype.getActiveClients = function () {\n        var e = this;\n        return this.simpleDb.runTransaction(\"readonly-idempotent\", [xu.store], function (t) {\n          return yc(t).loadAll().next(function (t) {\n            return e.filterActiveClients(t, 18e5).map(function (t) {\n              return t.clientId;\n            });\n          });\n        });\n      }, pc.clearPersistence = function (n) {\n        return p(this, void 0, void 0, function () {\n          var e;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return pc.isAvailable() ? (e = n + pc.MAIN_DATABASE, [4, jo.delete(e)]) : [2, Promise.resolve()];\n\n              case 1:\n                return t.sent(), [2];\n            }\n          });\n        });\n      }, Object.defineProperty(pc.prototype, \"started\", {\n        get: function () {\n          return this._started;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), pc.prototype.getMutationQueue = function (t) {\n        return Ur(this.started, \"Cannot initialize MutationQueue before persistence is started.\"), ea.forUser(t, this.serializer, this.indexManager, this.referenceDelegate);\n      }, pc.prototype.getTargetCache = function () {\n        return Ur(this.started, \"Cannot initialize TargetCache before persistence is started.\"), this.targetCache;\n      }, pc.prototype.getRemoteDocumentCache = function () {\n        return Ur(this.started, \"Cannot initialize RemoteDocumentCache before persistence is started.\"), this.remoteDocumentCache;\n      }, pc.prototype.getIndexManager = function () {\n        return Ur(this.started, \"Cannot initialize IndexManager before persistence is started.\"), this.indexManager;\n      }, pc.prototype.runTransaction = function (n, t, r) {\n        var i = this;\n        Fr(sc, \"Starting transaction:\", n);\n        var o,\n            e = t.endsWith(\"idempotent\"),\n            a = t.startsWith(\"readonly\") ? e ? \"readonly-idempotent\" : \"readonly\" : e ? \"readwrite-idempotent\" : \"readwrite\";\n        return this.simpleDb.runTransaction(a, Bu, function (e) {\n          return o = new hc(e, i.listenSequence.next()), \"readwrite-primary\" === t || \"readwrite-primary-idempotent\" === t ? i.verifyPrimaryLease(e).next(function (t) {\n            return !!t || i.canActAsPrimary(e);\n          }).next(function (t) {\n            if (!t) throw qr(\"Failed to obtain primary lease for action '\" + n + \"'.\"), i.isPrimary = !1, i.queue.enqueueAndForget(function () {\n              return i.primaryStateListener(!1);\n            }), new zr(Wr.FAILED_PRECONDITION, uc);\n            return r(o);\n          }).next(function (t) {\n            return i.acquireOrExtendPrimaryLease(e).next(function () {\n              return t;\n            });\n          }) : i.verifyAllowTabSynchronization(e).next(function () {\n            return r(o);\n          });\n        }).then(function (t) {\n          return o.raiseOnCommittedEvent(), t;\n        });\n      }, pc.prototype.verifyAllowTabSynchronization = function (t) {\n        var e = this;\n        return mc(t).get(pu.key).next(function (t) {\n          if (null !== t && e.isWithinAge(t.leaseTimestampMs, 5e3) && !e.isClientZombied(t.ownerId) && !e.isLocalClient(t) && !t.allowTabSynchronization) throw new zr(Wr.FAILED_PRECONDITION, cc);\n        });\n      }, pc.prototype.acquireOrExtendPrimaryLease = function (t) {\n        var e = new pu(this.clientId, this.allowTabSynchronization, Date.now());\n        return mc(t).put(pu.key, e);\n      }, pc.isAvailable = function () {\n        return jo.isAvailable();\n      }, pc.buildStoragePrefix = function (t) {\n        var e = t.databaseId.projectId;\n        return t.databaseId.isDefaultDatabase || (e += \".\" + t.databaseId.database), \"firestore/\" + t.persistenceKey + \"/\" + e + \"/\";\n      }, pc.prototype.releasePrimaryLeaseIfHeld = function (t) {\n        var e = this,\n            n = mc(t);\n        return n.get(pu.key).next(function (t) {\n          return e.isLocalClient(t) ? (Fr(sc, \"Releasing primary lease.\"), n.delete(pu.key)) : Uo.resolve();\n        });\n      }, pc.prototype.isWithinAge = function (t, e) {\n        var n = Date.now();\n        return !(t < n - e || n < t && (qr(\"Detected an update time that is in the future: \" + t + \" > \" + n), 1));\n      }, pc.prototype.attachVisibilityHandler = function () {\n        var t = this;\n        null !== this.document && \"function\" == typeof this.document.addEventListener && (this.documentVisibilityHandler = function () {\n          t.queue.enqueueAndForget(function () {\n            return t.inForeground = \"visible\" === t.document.visibilityState, t.updateClientMetadataAndTryBecomePrimary();\n          });\n        }, this.document.addEventListener(\"visibilitychange\", this.documentVisibilityHandler), this.inForeground = \"visible\" === this.document.visibilityState);\n      }, pc.prototype.detachVisibilityHandler = function () {\n        this.documentVisibilityHandler && (Ur(null !== this.document && \"function\" == typeof this.document.addEventListener, \"Expected 'document.addEventListener' to be a function\"), this.document.removeEventListener(\"visibilitychange\", this.documentVisibilityHandler), this.documentVisibilityHandler = null);\n      }, pc.prototype.attachWindowUnloadHook = function () {\n        var t = this;\n        \"function\" == typeof this.window.addEventListener && (this.windowUnloadHandler = function () {\n          t.markClientZombied(), t.queue.enqueueAndForget(function () {\n            return t.shutdown();\n          });\n        }, this.window.addEventListener(\"unload\", this.windowUnloadHandler));\n      }, pc.prototype.detachWindowUnloadHook = function () {\n        this.windowUnloadHandler && (Ur(\"function\" == typeof this.window.removeEventListener, \"Expected 'window.removeEventListener' to be a function\"), this.window.removeEventListener(\"unload\", this.windowUnloadHandler), this.windowUnloadHandler = null);\n      }, pc.prototype.isClientZombied = function (t) {\n        try {\n          var e = null !== this.webStorage.getItem(this.zombiedClientLocalStorageKey(t));\n          return Fr(sc, \"Client '\" + t + \"' \" + (e ? \"is\" : \"is not\") + \" zombied in LocalStorage\"), e;\n        } catch (t) {\n          return qr(sc, \"Failed to get zombied client id.\", t), !1;\n        }\n      }, pc.prototype.markClientZombied = function () {\n        try {\n          this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));\n        } catch (t) {\n          qr(\"Failed to set zombie client id.\", t);\n        }\n      }, pc.prototype.removeClientZombiedEntry = function () {\n        try {\n          this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));\n        } catch (t) {}\n      }, pc.prototype.zombiedClientLocalStorageKey = function (t) {\n        return \"firestore_zombie_\" + this.persistenceKey + \"_\" + t;\n      }, pc.MAIN_DATABASE = \"main\", pc);\n\n      function pc(t, e, n, r, i, o, a, s) {\n        if (this.allowTabSynchronization = t, this.persistenceKey = e, this.clientId = n, this.queue = o, this.sequenceNumberSyncer = s, this._started = !1, this.isPrimary = !1, this.networkEnabled = !0, this.windowUnloadHandler = null, this.inForeground = !1, this.documentVisibilityHandler = null, this.clientMetadataRefresher = null, this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY, this.primaryStateListener = function (t) {\n          return Promise.resolve();\n        }, this.referenceDelegate = new gc(this, i), this.dbName = e + pc.MAIN_DATABASE, this.serializer = new Wu(a), this.document = r.document, this.targetCache = new pa(this.referenceDelegate, this.serializer), this.indexManager = new Uu(), this.remoteDocumentCache = new Zs(this.serializer, this.indexManager), !r.window || !r.window.localStorage) throw new zr(Wr.UNIMPLEMENTED, \"IndexedDB persistence is only available on platforms that support LocalStorage.\");\n        this.window = r.window, this.webStorage = this.window.localStorage;\n      }\n\n      function dc(e) {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            if (!function (t) {\n              return t.code === Wr.FAILED_PRECONDITION && t.message === uc;\n            }(e)) throw e;\n            return Fr(sc, \"Unexpectedly lost primary lease\"), [2];\n          });\n        });\n      }\n\n      function mc(t) {\n        return t.store(pu.store);\n      }\n\n      function yc(t) {\n        return t.store(xu.store);\n      }\n\n      var gc = (vc.prototype.getSequenceNumberCount = function (t) {\n        var n = this.orphanedDocmentCount(t);\n        return this.db.getTargetCache().getTargetCount(t).next(function (e) {\n          return n.next(function (t) {\n            return e + t;\n          });\n        });\n      }, vc.prototype.orphanedDocmentCount = function (t) {\n        var e = 0;\n        return this.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n          e++;\n        }).next(function () {\n          return e;\n        });\n      }, vc.prototype.forEachTarget = function (t, e) {\n        return this.db.getTargetCache().forEachTarget(t, e);\n      }, vc.prototype.forEachOrphanedDocumentSequenceNumber = function (t, n) {\n        return this.forEachOrphanedDocument(t, function (t, e) {\n          return n(e);\n        });\n      }, vc.prototype.setInMemoryPins = function (t) {\n        this.inMemoryPins = t;\n      }, vc.prototype.addReference = function (t, e) {\n        return bc(t, e);\n      }, vc.prototype.removeReference = function (t, e) {\n        return bc(t, e);\n      }, vc.prototype.removeTargets = function (t, e, n) {\n        return this.db.getTargetCache().removeTargets(t, e, n);\n      }, vc.prototype.removeMutationReference = function (t, e) {\n        return bc(t, e);\n      }, vc.prototype.isPinned = function (t, e) {\n        return this.inMemoryPins.containsKey(e) ? Uo.resolve(!0) : function (e, n) {\n          var r = !1;\n          return ua(e).iterateSerial(function (t) {\n            return ra(e, t, n).next(function (t) {\n              return t && (r = !0), Uo.resolve(!t);\n            });\n          }).next(function () {\n            return r;\n          });\n        }(t, e);\n      }, vc.prototype.removeOrphanedDocuments = function (r, i) {\n        var o = this,\n            a = this.db.getRemoteDocumentCache().newChangeBuffer(),\n            s = [],\n            u = 0;\n        return this.forEachOrphanedDocument(r, function (e, t) {\n          if (t <= i) {\n            var n = o.isPinned(r, e).next(function (t) {\n              if (!t) return u++, a.getEntry(r, e).next(function () {\n                return a.removeEntry(e), va(r).delete(function (t) {\n                  return [0, oo(t.path)];\n                }(e));\n              });\n            });\n            s.push(n);\n          }\n        }).next(function () {\n          return Uo.waitFor(s);\n        }).next(function () {\n          return a.apply(r);\n        }).next(function () {\n          return u;\n        });\n      }, vc.prototype.removeTarget = function (t, e) {\n        var n = e.withSequenceNumber(t.currentSequenceNumber);\n        return this.db.getTargetCache().updateTargetData(t, n);\n      }, vc.prototype.updateLimboDocument = function (t, e) {\n        return bc(t, e);\n      }, vc.prototype.forEachOrphanedDocument = function (t, o) {\n        var a,\n            e = va(t),\n            s = Oi.INVALID;\n        return e.iterate({\n          index: ku.documentTargetsIndex\n        }, function (t, e) {\n          var n = t[0],\n              r = (t[1], e.path),\n              i = e.sequenceNumber;\n          0 === n ? (s !== Oi.INVALID && o(new Wi(uo(a)), s), s = i, a = r) : s = Oi.INVALID;\n        }).next(function () {\n          s !== Oi.INVALID && o(new Wi(uo(a)), s);\n        });\n      }, vc.prototype.getCacheSize = function (t) {\n        return this.db.getRemoteDocumentCache().getSize(t);\n      }, vc);\n\n      function vc(t, e) {\n        this.db = t, this.inMemoryPins = null, this.garbageCollector = new nc(this, e);\n      }\n\n      function bc(t, e) {\n        return va(t).put(function (t, e) {\n          return new ku(0, oo(t.path), e);\n        }(e, t.currentSequenceNumber));\n      }\n\n      var wc = Number,\n          Tc = wc.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1),\n          Sc = wc.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1,\n          Ec = wc.isInteger || function (t) {\n        return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n      };\n\n      function Ic(t) {\n        return null == t;\n      }\n\n      function Cc(t) {\n        return Ec(t) && t <= Sc && Tc <= t;\n      }\n\n      var Dc,\n          Nc,\n          Ac = (kc.prototype.canonicalId = function () {\n        if (null === this.memoizedCanonicalId) {\n          var t = this.path.canonicalString();\n          null !== this.collectionGroup && (t += \"|cg:\" + this.collectionGroup), t += \"|f:\";\n\n          for (var e = 0, n = this.filters; e < n.length; e++) t += n[e].canonicalId(), t += \",\";\n\n          t += \"|ob:\";\n\n          for (var r = 0, i = this.orderBy; r < i.length; r++) t += i[r].canonicalId(), t += \",\";\n\n          Ic(this.limit) || (t += \"|l:\", t += this.limit), this.startAt && (t += \"|lb:\", t += this.startAt.canonicalId()), this.endAt && (t += \"|ub:\", t += this.endAt.canonicalId()), this.memoizedCanonicalId = t;\n        }\n\n        return this.memoizedCanonicalId;\n      }, kc.prototype.toString = function () {\n        var t = this.path.canonicalString();\n        return null !== this.collectionGroup && (t += \" collectionGroup=\" + this.collectionGroup), 0 < this.filters.length && (t += \", filters: [\" + this.filters.join(\", \") + \"]\"), Ic(this.limit) || (t += \", limit: \" + this.limit), 0 < this.orderBy.length && (t += \", orderBy: [\" + this.orderBy.join(\", \") + \"]\"), this.startAt && (t += \", startAt: \" + this.startAt.canonicalId()), this.endAt && (t += \", endAt: \" + this.endAt.canonicalId()), \"Target(\" + t + \")\";\n      }, kc.prototype.isEqual = function (t) {\n        if (this.limit !== t.limit) return !1;\n        if (this.orderBy.length !== t.orderBy.length) return !1;\n\n        for (var e = 0; e < this.orderBy.length; e++) if (!this.orderBy[e].isEqual(t.orderBy[e])) return !1;\n\n        if (this.filters.length !== t.filters.length) return !1;\n\n        for (e = 0; e < this.filters.length; e++) if (!this.filters[e].isEqual(t.filters[e])) return !1;\n\n        return this.collectionGroup === t.collectionGroup && !!this.path.isEqual(t.path) && !(null !== this.startAt ? !this.startAt.isEqual(t.startAt) : null !== t.startAt) && (null !== this.endAt ? this.endAt.isEqual(t.endAt) : null === t.endAt);\n      }, kc.prototype.isDocumentQuery = function () {\n        return Wi.isDocumentKey(this.path) && null === this.collectionGroup && 0 === this.filters.length;\n      }, kc);\n\n      function kc(t, e, n, r, i, o, a) {\n        void 0 === e && (e = null), void 0 === n && (n = []), void 0 === r && (r = []), void 0 === i && (i = null), void 0 === o && (o = null), void 0 === a && (a = null), this.path = t, this.collectionGroup = e, this.orderBy = n, this.filters = r, this.limit = i, this.startAt = o, this.endAt = a, this.memoizedCanonicalId = null;\n      }\n\n      (Nc = Dc = Dc || {}).First = \"F\", Nc.Last = \"L\";\n      var Rc = (Mc.atPath = function (t) {\n        return new Mc(t);\n      }, Object.defineProperty(Mc.prototype, \"orderBy\", {\n        get: function () {\n          if (null === this.memoizedOrderBy) {\n            var t = this.getInequalityFilterField(),\n                e = this.getFirstOrderByField();\n            if (null !== t && null === e) t.isKeyField() ? this.memoizedOrderBy = [oh] : this.memoizedOrderBy = [new rh(t), oh];else {\n              Ur(null === t || null !== e && t.isEqual(e), \"First orderBy should match inequality field.\");\n\n              for (var n = !(this.memoizedOrderBy = []), r = 0, i = this.explicitOrderBy; r < i.length; r++) {\n                var o = i[r];\n                this.memoizedOrderBy.push(o), o.field.isKeyField() && (n = !0);\n              }\n\n              if (!n) {\n                var a = 0 < this.explicitOrderBy.length ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir : $c.ASCENDING;\n                this.memoizedOrderBy.push(a === $c.ASCENDING ? oh : ah);\n              }\n            }\n          }\n\n          return this.memoizedOrderBy;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Mc.prototype.addFilter = function (t) {\n        Ur(null == this.getInequalityFilterField() || !(t instanceof xc) || !t.isInequality() || t.field.isEqual(this.getInequalityFilterField()), \"Query must only have one inequality field.\"), Ur(!this.isDocumentQuery(), \"No filtering allowed for document query\");\n        var e = this.filters.concat([t]);\n        return new Mc(this.path, this.collectionGroup, this.explicitOrderBy.slice(), e, this.limit, this.limitType, this.startAt, this.endAt);\n      }, Mc.prototype.addOrderBy = function (t) {\n        Ur(!this.startAt && !this.endAt, \"Bounds must be set after orderBy\");\n        var e = this.explicitOrderBy.concat([t]);\n        return new Mc(this.path, this.collectionGroup, e, this.filters.slice(), this.limit, this.limitType, this.startAt, this.endAt);\n      }, Mc.prototype.withLimitToFirst = function (t) {\n        return new Mc(this.path, this.collectionGroup, this.explicitOrderBy.slice(), this.filters.slice(), t, Dc.First, this.startAt, this.endAt);\n      }, Mc.prototype.withLimitToLast = function (t) {\n        return new Mc(this.path, this.collectionGroup, this.explicitOrderBy.slice(), this.filters.slice(), t, Dc.Last, this.startAt, this.endAt);\n      }, Mc.prototype.withStartAt = function (t) {\n        return new Mc(this.path, this.collectionGroup, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.limitType, t, this.endAt);\n      }, Mc.prototype.withEndAt = function (t) {\n        return new Mc(this.path, this.collectionGroup, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.limitType, this.startAt, t);\n      }, Mc.prototype.asCollectionQueryAtPath = function (t) {\n        return new Mc(t, null, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.limitType, this.startAt, this.endAt);\n      }, Mc.prototype.matchesAllDocuments = function () {\n        return 0 === this.filters.length && null === this.limit && null == this.startAt && null == this.endAt && (0 === this.explicitOrderBy.length || 1 === this.explicitOrderBy.length && this.explicitOrderBy[0].field.isKeyField());\n      }, Mc.prototype.canonicalId = function () {\n        return this.toTarget().canonicalId() + \"|lt:\" + this.limitType;\n      }, Mc.prototype.toString = function () {\n        return \"Query(target=\" + this.toTarget().toString() + \"; limitType=\" + this.limitType + \")\";\n      }, Mc.prototype.isEqual = function (t) {\n        return this.toTarget().isEqual(t.toTarget()) && this.limitType === t.limitType;\n      }, Mc.prototype.docComparator = function (t, e) {\n        for (var n = !1, r = 0, i = this.orderBy; r < i.length; r++) {\n          var o = i[r],\n              a = o.compare(t, e);\n          if (0 !== a) return a;\n          n = n || o.field.isKeyField();\n        }\n\n        return Ur(n, \"orderBy used that doesn't compare on key field\"), 0;\n      }, Mc.prototype.matches = function (t) {\n        return this.matchesPathAndCollectionGroup(t) && this.matchesOrderBy(t) && this.matchesFilters(t) && this.matchesBounds(t);\n      }, Mc.prototype.hasLimitToFirst = function () {\n        return !Ic(this.limit) && this.limitType === Dc.First;\n      }, Mc.prototype.hasLimitToLast = function () {\n        return !Ic(this.limit) && this.limitType === Dc.Last;\n      }, Mc.prototype.getFirstOrderByField = function () {\n        return 0 < this.explicitOrderBy.length ? this.explicitOrderBy[0].field : null;\n      }, Mc.prototype.getInequalityFilterField = function () {\n        for (var t = 0, e = this.filters; t < e.length; t++) {\n          var n = e[t];\n          if (n instanceof xc && n.isInequality()) return n.field;\n        }\n\n        return null;\n      }, Mc.prototype.findFilterOperator = function (t) {\n        for (var e = 0, n = this.filters; e < n.length; e++) {\n          var r = n[e];\n          if (r instanceof xc && 0 <= t.indexOf(r.op)) return r.op;\n        }\n\n        return null;\n      }, Mc.prototype.isDocumentQuery = function () {\n        return this.toTarget().isDocumentQuery();\n      }, Mc.prototype.isCollectionGroupQuery = function () {\n        return null !== this.collectionGroup;\n      }, Mc.prototype.toTarget = function () {\n        if (!this.memoizedTarget) if (this.limitType === Dc.First) this.memoizedTarget = new Ac(this.path, this.collectionGroup, this.orderBy, this.filters, this.limit, this.startAt, this.endAt);else {\n          for (var t = [], e = 0, n = this.orderBy; e < n.length; e++) {\n            var r = n[e],\n                i = r.dir === $c.DESCENDING ? $c.ASCENDING : $c.DESCENDING;\n            t.push(new rh(r.field, i));\n          }\n\n          var o = this.endAt ? new eh(this.endAt.position, !this.endAt.before) : null,\n              a = this.startAt ? new eh(this.startAt.position, !this.startAt.before) : null;\n          this.memoizedTarget = new Ac(this.path, this.collectionGroup, t, this.filters, this.limit, o, a);\n        }\n        return this.memoizedTarget;\n      }, Mc.prototype.matchesPathAndCollectionGroup = function (t) {\n        var e = t.key.path;\n        return null !== this.collectionGroup ? t.key.hasCollectionId(this.collectionGroup) && this.path.isPrefixOf(e) : Wi.isDocumentKey(this.path) ? this.path.isEqual(e) : this.path.isImmediateParentOf(e);\n      }, Mc.prototype.matchesOrderBy = function (t) {\n        for (var e = 0, n = this.explicitOrderBy; e < n.length; e++) {\n          var r = n[e];\n          if (!r.field.isKeyField() && null === t.field(r.field)) return !1;\n        }\n\n        return !0;\n      }, Mc.prototype.matchesFilters = function (t) {\n        for (var e = 0, n = this.filters; e < n.length; e++) if (!n[e].matches(t)) return !1;\n\n        return !0;\n      }, Mc.prototype.matchesBounds = function (t) {\n        return !(this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, t) || this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, t));\n      }, Mc.prototype.assertValidBound = function (t) {\n        Ur(t.position.length <= this.orderBy.length, \"Bound is longer than orderBy\");\n      }, Mc);\n\n      function Mc(t, e, n, r, i, o, a, s) {\n        void 0 === e && (e = null), void 0 === n && (n = []), void 0 === r && (r = []), void 0 === i && (i = null), void 0 === o && (o = Dc.First), void 0 === a && (a = null), void 0 === s && (s = null), this.path = t, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = r, this.limit = i, this.limitType = o, this.startAt = a, this.endAt = s, this.memoizedOrderBy = null, this.memoizedTarget = null, this.startAt && this.assertValidBound(this.startAt), this.endAt && this.assertValidBound(this.endAt);\n      }\n\n      function _c() {}\n\n      var Lc = (Oc.fromString = function (t) {\n        switch (t) {\n          case \"<\":\n            return Oc.LESS_THAN;\n\n          case \"<=\":\n            return Oc.LESS_THAN_OR_EQUAL;\n\n          case \"==\":\n            return Oc.EQUAL;\n\n          case \">=\":\n            return Oc.GREATER_THAN_OR_EQUAL;\n\n          case \">\":\n            return Oc.GREATER_THAN;\n\n          case \"array-contains\":\n            return Oc.ARRAY_CONTAINS;\n\n          case \"in\":\n            return Oc.IN;\n\n          case \"array-contains-any\":\n            return Oc.ARRAY_CONTAINS_ANY;\n\n          default:\n            return Br(\"Unknown FieldFilter operator: \" + t);\n        }\n      }, Oc.prototype.toString = function () {\n        return this.name;\n      }, Oc.prototype.isEqual = function (t) {\n        return this.name === t.name;\n      }, Oc.LESS_THAN = new Oc(\"<\"), Oc.LESS_THAN_OR_EQUAL = new Oc(\"<=\"), Oc.EQUAL = new Oc(\"==\"), Oc.GREATER_THAN = new Oc(\">\"), Oc.GREATER_THAN_OR_EQUAL = new Oc(\">=\"), Oc.ARRAY_CONTAINS = new Oc(\"array-contains\"), Oc.IN = new Oc(\"in\"), Oc.ARRAY_CONTAINS_ANY = new Oc(\"array-contains-any\"), Oc);\n\n      function Oc(t) {\n        this.name = t;\n      }\n\n      var Pc,\n          xc = (t(Fc, Pc = _c), Fc.create = function (t, e, n) {\n        if (t.isKeyField()) return e === Lc.IN ? (Ur(n instanceof Os, \"Comparing on key with IN, but filter value not an ArrayValue\"), Ur(n.internalValue.every(function (t) {\n          return t instanceof Cs;\n        }), \"Comparing on key with IN, but an array value was not a RefValue\"), new Kc(t, n)) : (Ur(n instanceof Cs, \"Comparing on key, but filter value not a RefValue\"), Ur(e !== Lc.ARRAY_CONTAINS && e !== Lc.ARRAY_CONTAINS_ANY, \"'\" + e.toString() + \"' queries don't make sense on document keys.\"), new Vc(t, e, n));\n\n        if (n.isEqual(Xa.INSTANCE)) {\n          if (e !== Lc.EQUAL) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. Null supports only equality comparisons.\");\n          return new Fc(t, e, n);\n        }\n\n        if (n.isEqual(hs.NAN)) {\n          if (e !== Lc.EQUAL) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. NaN supports only equality comparisons.\");\n          return new Fc(t, e, n);\n        }\n\n        return e === Lc.ARRAY_CONTAINS ? new Gc(t, n) : e === Lc.IN ? (Ur(n instanceof Os, \"IN filter has invalid value: \" + n.toString()), new Hc(t, n)) : e === Lc.ARRAY_CONTAINS_ANY ? (Ur(n instanceof Os, \"ARRAY_CONTAINS_ANY filter has invalid value: \" + n.toString()), new Xc(t, n)) : new Fc(t, e, n);\n      }, Fc.prototype.matches = function (t) {\n        var e = t.field(this.field);\n        return null !== e && this.value.typeOrder === e.typeOrder && this.matchesComparison(e.compareTo(this.value));\n      }, Fc.prototype.matchesComparison = function (t) {\n        switch (this.op) {\n          case Lc.LESS_THAN:\n            return t < 0;\n\n          case Lc.LESS_THAN_OR_EQUAL:\n            return t <= 0;\n\n          case Lc.EQUAL:\n            return 0 === t;\n\n          case Lc.GREATER_THAN:\n            return 0 < t;\n\n          case Lc.GREATER_THAN_OR_EQUAL:\n            return 0 <= t;\n\n          default:\n            return Br(\"Unknown FieldFilter operator: \" + this.op);\n        }\n      }, Fc.prototype.isInequality = function () {\n        return 0 <= [Lc.LESS_THAN, Lc.LESS_THAN_OR_EQUAL, Lc.GREATER_THAN, Lc.GREATER_THAN_OR_EQUAL].indexOf(this.op);\n      }, Fc.prototype.canonicalId = function () {\n        return this.field.canonicalString() + this.op.toString() + this.value.toString();\n      }, Fc.prototype.isEqual = function (t) {\n        return t instanceof Fc && this.op.isEqual(t.op) && this.field.isEqual(t.field) && this.value.isEqual(t.value);\n      }, Fc.prototype.toString = function () {\n        return this.field.canonicalString() + \" \" + this.op + \" \" + this.value.value();\n      }, Fc);\n\n      function Fc(t, e, n) {\n        var r = Pc.call(this) || this;\n        return r.field = t, r.op = e, r.value = n, r;\n      }\n\n      var qc,\n          Vc = (t(Bc, qc = xc), Bc.prototype.matches = function (t) {\n        var e = this.value,\n            n = Wi.comparator(t.key, e.key);\n        return this.matchesComparison(n);\n      }, Bc);\n\n      function Bc() {\n        return null !== qc && qc.apply(this, arguments) || this;\n      }\n\n      var Uc,\n          Kc = (t(Qc, Uc = xc), Qc.prototype.matches = function (e) {\n        return this.value.internalValue.some(function (t) {\n          return e.key.isEqual(t.key);\n        });\n      }, Qc);\n\n      function Qc(t, e) {\n        var n = Uc.call(this, t, Lc.IN, e) || this;\n        return n.value = e, n;\n      }\n\n      var jc,\n          Gc = (t(Wc, jc = xc), Wc.prototype.matches = function (t) {\n        var e = t.field(this.field);\n        return e instanceof Os && e.contains(this.value);\n      }, Wc);\n\n      function Wc(t, e) {\n        return jc.call(this, t, Lc.ARRAY_CONTAINS, e) || this;\n      }\n\n      var zc,\n          Hc = (t(Yc, zc = xc), Yc.prototype.matches = function (t) {\n        var e = this.value,\n            n = t.field(this.field);\n        return null !== n && e.contains(n);\n      }, Yc);\n\n      function Yc(t, e) {\n        var n = zc.call(this, t, Lc.IN, e) || this;\n        return n.value = e, n;\n      }\n\n      var Jc,\n          Xc = (t(Zc, Jc = xc), Zc.prototype.matches = function (t) {\n        var e = this,\n            n = t.field(this.field);\n        return n instanceof Os && n.internalValue.some(function (t) {\n          return e.value.contains(t);\n        });\n      }, Zc);\n\n      function Zc(t, e) {\n        var n = Jc.call(this, t, Lc.ARRAY_CONTAINS_ANY, e) || this;\n        return n.value = e, n;\n      }\n\n      var $c = (th.prototype.toString = function () {\n        return this.name;\n      }, th.ASCENDING = new th(\"asc\"), th.DESCENDING = new th(\"desc\"), th);\n\n      function th(t) {\n        this.name = t;\n      }\n\n      var eh = (nh.prototype.canonicalId = function () {\n        for (var t = this.before ? \"b:\" : \"a:\", e = 0, n = this.position; e < n.length; e++) t += n[e].toString();\n\n        return t;\n      }, nh.prototype.sortsBeforeDocument = function (t, e) {\n        Ur(this.position.length <= t.length, \"Bound has more components than query's orderBy\");\n\n        for (var n = 0, r = 0; r < this.position.length; r++) {\n          var i = t[r],\n              o = this.position[r];\n          if (i.field.isKeyField()) Ur(o instanceof Cs, \"Bound has a non-key value where the key path is being used.\"), n = Wi.comparator(o.key, e.key);else {\n            var a = e.field(i.field);\n            Ur(null !== a, \"Field should exist since document matched the orderBy already.\"), n = o.compareTo(a);\n          }\n          if (i.dir === $c.DESCENDING && (n *= -1), 0 !== n) break;\n        }\n\n        return this.before ? n <= 0 : n < 0;\n      }, nh.prototype.isEqual = function (t) {\n        if (null === t) return !1;\n        if (this.before !== t.before || this.position.length !== t.position.length) return !1;\n\n        for (var e = 0; e < this.position.length; e++) {\n          var n = this.position[e],\n              r = t.position[e];\n          if (!n.isEqual(r)) return !1;\n        }\n\n        return !0;\n      }, nh);\n\n      function nh(t, e) {\n        this.position = t, this.before = e;\n      }\n\n      var rh = (ih.prototype.compare = function (t, e) {\n        var n = this.isKeyOrderBy ? Vs.compareByKey(t, e) : Vs.compareByField(this.field, t, e);\n\n        switch (this.dir) {\n          case $c.ASCENDING:\n            return n;\n\n          case $c.DESCENDING:\n            return -1 * n;\n\n          default:\n            return Br(\"Unknown direction: \" + this.dir);\n        }\n      }, ih.prototype.canonicalId = function () {\n        return this.field.canonicalString() + this.dir.toString();\n      }, ih.prototype.toString = function () {\n        return this.field.canonicalString() + \" (\" + this.dir + \")\";\n      }, ih.prototype.isEqual = function (t) {\n        return this.dir === t.dir && this.field.isEqual(t.field);\n      }, ih);\n\n      function ih(t, e) {\n        this.field = t, void 0 === e && (e = $c.ASCENDING), this.dir = e, this.isKeyOrderBy = t.isKeyField();\n      }\n\n      var oh = new rh(ji.keyField(), $c.ASCENDING),\n          ah = new rh(ji.keyField(), $c.DESCENDING),\n          sh = (uh.prototype.setLocalDocumentsView = function (t) {\n        this.localDocumentsView = t;\n      }, uh.prototype.getDocumentsMatchingQuery = function (e, r, i, o) {\n        var a = this;\n        return Ur(void 0 !== this.localDocumentsView, \"setLocalDocumentsView() not called\"), r.matchesAllDocuments() ? this.executeFullCollectionScan(e, r) : i.isEqual(lo.MIN) ? this.executeFullCollectionScan(e, r) : this.localDocumentsView.getDocuments(e, o).next(function (t) {\n          var n = a.applyQuery(r, t);\n          return (r.hasLimitToFirst() || r.hasLimitToLast()) && a.needsRefill(r.limitType, n, o, i) ? a.executeFullCollectionScan(e, r) : (Pr() <= Cr.DEBUG && Fr(\"IndexFreeQueryEngine\", \"Re-using previous result from %s to execute query: %s\", i.toString(), r.toString()), a.localDocumentsView.getDocumentsMatchingQuery(e, r, i).next(function (e) {\n            return n.forEach(function (t) {\n              e = e.insert(t.key, t);\n            }), e;\n          }));\n        });\n      }, uh.prototype.applyQuery = function (n, t) {\n        var r = new So(function (t, e) {\n          return n.docComparator(t, e);\n        });\n        return t.forEach(function (t, e) {\n          e instanceof Vs && n.matches(e) && (r = r.add(e));\n        }), r;\n      }, uh.prototype.needsRefill = function (t, e, n, r) {\n        if (n.size !== e.size) return !0;\n        var i = t === Dc.First ? e.last() : e.first();\n        return !!i && (i.hasPendingWrites || 0 < i.version.compareTo(r));\n      }, uh.prototype.executeFullCollectionScan = function (t, e) {\n        return Pr() <= Cr.DEBUG && Fr(\"IndexFreeQueryEngine\", \"Using full collection scan to execute query: %s\", e.toString()), this.localDocumentsView.getDocumentsMatchingQuery(t, e, lo.MIN);\n      }, uh);\n\n      function uh() {}\n\n      var ch = (hh.prototype.getDocument = function (e, n) {\n        var r = this;\n        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(e, n).next(function (t) {\n          return r.getDocumentInternal(e, n, t);\n        });\n      }, hh.prototype.getDocumentInternal = function (t, r, i) {\n        return this.remoteDocumentCache.getEntry(t, r).next(function (t) {\n          for (var e = 0, n = i; e < n.length; e++) t = n[e].applyToLocalView(r, t);\n\n          return t;\n        });\n      }, hh.prototype.applyLocalMutationsToDocuments = function (t, e, i) {\n        var o = Ao();\n        return e.forEach(function (t, e) {\n          for (var n = 0, r = i; n < r.length; n++) e = r[n].applyToLocalView(t, e);\n\n          o = o.insert(t, e);\n        }), o;\n      }, hh.prototype.getDocuments = function (e, t) {\n        var n = this;\n        return this.remoteDocumentCache.getEntries(e, t).next(function (t) {\n          return n.getLocalViewOfDocuments(e, t);\n        });\n      }, hh.prototype.getLocalViewOfDocuments = function (r, i) {\n        var o = this;\n        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(r, i).next(function (t) {\n          var e = o.applyLocalMutationsToDocuments(r, i, t),\n              n = No();\n          return e.forEach(function (t, e) {\n            e = e || new Ks(t, lo.forDeletedDoc()), n = n.insert(t, e);\n          }), n;\n        });\n      }, hh.prototype.getDocumentsMatchingQuery = function (t, e, n) {\n        return e.isDocumentQuery() ? this.getDocumentsMatchingDocumentQuery(t, e.path) : e.isCollectionGroupQuery() ? this.getDocumentsMatchingCollectionGroupQuery(t, e, n) : this.getDocumentsMatchingCollectionQuery(t, e, n);\n      }, hh.prototype.getDocumentsMatchingDocumentQuery = function (t, e) {\n        return this.getDocument(t, new Wi(e)).next(function (t) {\n          var e = Ro();\n          return t instanceof Vs && (e = e.insert(t.key, t)), e;\n        });\n      }, hh.prototype.getDocumentsMatchingCollectionGroupQuery = function (n, r, i) {\n        var o = this;\n        Ur(r.path.isEmpty(), \"Currently we only support collection group queries at the root.\");\n        var a = r.collectionGroup,\n            s = Ro();\n        return this.indexManager.getCollectionParents(n, a).next(function (t) {\n          return Uo.forEach(t, function (t) {\n            var e = r.asCollectionQueryAtPath(t.child(a));\n            return o.getDocumentsMatchingCollectionQuery(n, e, i).next(function (t) {\n              t.forEach(function (t, e) {\n                s = s.insert(t, e);\n              });\n            });\n          }).next(function () {\n            return s;\n          });\n        });\n      }, hh.prototype.getDocumentsMatchingCollectionQuery = function (e, n, t) {\n        var h,\n            l,\n            r = this;\n        return this.remoteDocumentCache.getDocumentsMatchingQuery(e, n, t).next(function (t) {\n          return h = t, r.mutationQueue.getAllMutationBatchesAffectingQuery(e, n);\n        }).next(function (t) {\n          return l = t, r.addMissingBaseDocuments(e, l, h).next(function (t) {\n            h = t;\n\n            for (var e = 0, n = l; e < n.length; e++) for (var r = n[e], i = 0, o = r.mutations; i < o.length; i++) {\n              var a = o[i],\n                  s = a.key,\n                  u = h.get(s),\n                  c = a.applyToLocalView(u, u, r.localWriteTime);\n              h = c instanceof Vs ? h.insert(s, c) : h.remove(s);\n            }\n          });\n        }).next(function () {\n          return h.forEach(function (t, e) {\n            n.matches(e) || (h = h.remove(t));\n          }), h;\n        });\n      }, hh.prototype.addMissingBaseDocuments = function (t, e, n) {\n        for (var r = Oo(), i = 0, o = e; i < o.length; i++) for (var a = 0, s = o[i].mutations; a < s.length; a++) {\n          var u = s[a];\n          u instanceof Oa && null === n.get(u.key) && (r = r.add(u.key));\n        }\n\n        var c = n;\n        return this.remoteDocumentCache.getEntries(t, r).next(function (t) {\n          return t.forEach(function (t, e) {\n            null !== e && e instanceof Vs && (c = c.insert(t, e));\n          }), c;\n        });\n      }, hh);\n\n      function hh(t, e, n) {\n        this.remoteDocumentCache = t, this.mutationQueue = e, this.indexManager = n;\n      }\n\n      var lh = (fh.prototype.isEmpty = function () {\n        return this.refsByKey.isEmpty();\n      }, fh.prototype.addReference = function (t, e) {\n        var n = new ph(t, e);\n        this.refsByKey = this.refsByKey.add(n), this.refsByTarget = this.refsByTarget.add(n);\n      }, fh.prototype.addReferences = function (t, e) {\n        var n = this;\n        t.forEach(function (t) {\n          return n.addReference(t, e);\n        });\n      }, fh.prototype.removeReference = function (t, e) {\n        this.removeRef(new ph(t, e));\n      }, fh.prototype.removeReferences = function (t, e) {\n        var n = this;\n        t.forEach(function (t) {\n          return n.removeReference(t, e);\n        });\n      }, fh.prototype.removeReferencesForId = function (t) {\n        var e = this,\n            n = Wi.EMPTY,\n            r = new ph(n, t),\n            i = new ph(n, t + 1),\n            o = [];\n        return this.refsByTarget.forEachInRange([r, i], function (t) {\n          e.removeRef(t), o.push(t.key);\n        }), o;\n      }, fh.prototype.removeAllReferences = function () {\n        var e = this;\n        this.refsByKey.forEach(function (t) {\n          return e.removeRef(t);\n        });\n      }, fh.prototype.removeRef = function (t) {\n        this.refsByKey = this.refsByKey.delete(t), this.refsByTarget = this.refsByTarget.delete(t);\n      }, fh.prototype.referencesForId = function (t) {\n        var e = Wi.EMPTY,\n            n = new ph(e, t),\n            r = new ph(e, t + 1),\n            i = Oo();\n        return this.refsByTarget.forEachInRange([n, r], function (t) {\n          i = i.add(t.key);\n        }), i;\n      }, fh.prototype.containsKey = function (t) {\n        var e = new ph(t, 0),\n            n = this.refsByKey.firstAfterOrEqual(e);\n        return null !== n && t.isEqual(n.key);\n      }, fh);\n\n      function fh() {\n        this.refsByKey = new So(ph.compareByKey), this.refsByTarget = new So(ph.compareByTargetId);\n      }\n\n      var ph = (dh.compareByKey = function (t, e) {\n        return Wi.comparator(t.key, e.key) || Si(t.targetOrBatchId, e.targetOrBatchId);\n      }, dh.compareByTargetId = function (t, e) {\n        return Si(t.targetOrBatchId, e.targetOrBatchId) || Wi.comparator(t.key, e.key);\n      }, dh);\n\n      function dh(t, e) {\n        this.key = t, this.targetOrBatchId = e;\n      }\n\n      var mh = (yh.prototype.start = function () {\n        return this.synchronizeLastDocumentChangeReadTime();\n      }, yh.prototype.handleUserChange = function (i) {\n        return p(this, void 0, void 0, function () {\n          var e,\n              y,\n              n,\n              r = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return e = this.mutationQueue, y = this.localDocuments, [4, this.persistence.runTransaction(\"Handle user change\", \"readonly-idempotent\", function (d) {\n                  var m;\n                  return r.mutationQueue.getAllMutationBatches(d).next(function (t) {\n                    return m = t, e = r.persistence.getMutationQueue(i), y = new ch(r.remoteDocuments, e, r.persistence.getIndexManager()), e.getAllMutationBatches(d);\n                  }).next(function (t) {\n                    for (var e = [], n = [], r = Oo(), i = 0, o = m; i < o.length; i++) {\n                      var a = o[i];\n                      e.push(a.batchId);\n\n                      for (var s = 0, u = a.mutations; s < u.length; s++) {\n                        var c = u[s];\n                        r = r.add(c.key);\n                      }\n                    }\n\n                    for (var h = 0, l = t; h < l.length; h++) {\n                      a = l[h], n.push(a.batchId);\n\n                      for (var f = 0, p = a.mutations; f < p.length; f++) c = p[f], r = r.add(c.key);\n                    }\n\n                    return y.getDocuments(d, r).next(function (t) {\n                      return {\n                        affectedDocuments: t,\n                        removedBatchIds: e,\n                        addedBatchIds: n\n                      };\n                    });\n                  });\n                })];\n\n              case 1:\n                return n = t.sent(), this.mutationQueue = e, this.localDocuments = y, this.queryEngine.setLocalDocumentsView(this.localDocuments), [2, n];\n            }\n          });\n        });\n      }, yh.prototype.localWrite = function (s) {\n        var u,\n            c = this,\n            h = co.now(),\n            t = s.reduce(function (t, e) {\n          return t.add(e.key);\n        }, Oo());\n        return this.persistence.runTransaction(\"Locally write mutations\", \"readwrite-idempotent\", function (a) {\n          return c.localDocuments.getDocuments(a, t).next(function (t) {\n            u = t;\n\n            for (var e = [], n = 0, r = s; n < r.length; n++) {\n              var i = r[n],\n                  o = i.extractBaseValue(u.get(i.key));\n              null != o && e.push(new Oa(i.key, o, o.fieldMask(), Da.exists(!0)));\n            }\n\n            return c.mutationQueue.addMutationBatch(a, h, e, s);\n          });\n        }).then(function (t) {\n          var e = t.applyToLocalDocumentSet(u);\n          return {\n            batchId: t.batchId,\n            changes: e\n          };\n        });\n      }, yh.prototype.lookupMutationDocuments = function (t) {\n        var n = this;\n        return this.persistence.runTransaction(\"Lookup mutation documents\", \"readonly-idempotent\", function (e) {\n          return n.mutationQueue.lookupMutationKeys(e, t).next(function (t) {\n            return t ? n.localDocuments.getDocuments(e, t) : Uo.resolve(null);\n          });\n        });\n      }, yh.prototype.acknowledgeBatch = function (r) {\n        var i = this;\n        return this.persistence.runTransaction(\"Acknowledge batch\", \"readwrite-primary-idempotent\", function (t) {\n          var e = r.batch.keys(),\n              n = i.remoteDocuments.newChangeBuffer({\n            trackRemovals: !0\n          });\n          return i.mutationQueue.acknowledgeBatch(t, r.batch, r.streamToken).next(function () {\n            return i.applyWriteToRemoteDocuments(t, r, n);\n          }).next(function () {\n            return n.apply(t);\n          }).next(function () {\n            return i.mutationQueue.performConsistencyCheck(t);\n          }).next(function () {\n            return i.localDocuments.getDocuments(t, e);\n          });\n        });\n      }, yh.prototype.rejectBatch = function (t) {\n        var r = this;\n        return this.persistence.runTransaction(\"Reject batch\", \"readwrite-primary-idempotent\", function (e) {\n          var n;\n          return r.mutationQueue.lookupMutationBatch(e, t).next(function (t) {\n            return Ur(null !== t, \"Attempt to reject nonexistent batch!\"), n = t.keys(), r.mutationQueue.removeMutationBatch(e, t);\n          }).next(function () {\n            return r.mutationQueue.performConsistencyCheck(e);\n          }).next(function () {\n            return r.localDocuments.getDocuments(e, n);\n          });\n        });\n      }, yh.prototype.getHighestUnacknowledgedBatchId = function () {\n        var e = this;\n        return this.persistence.runTransaction(\"Get highest unacknowledged batch id\", \"readonly-idempotent\", function (t) {\n          return e.mutationQueue.getHighestUnacknowledgedBatchId(t);\n        });\n      }, yh.prototype.getLastStreamToken = function () {\n        var e = this;\n        return this.persistence.runTransaction(\"Get last stream token\", \"readonly-idempotent\", function (t) {\n          return e.mutationQueue.getLastStreamToken(t);\n        });\n      }, yh.prototype.setLastStreamToken = function (e) {\n        var n = this;\n        return this.persistence.runTransaction(\"Set last stream token\", \"readwrite-primary-idempotent\", function (t) {\n          return n.mutationQueue.setLastStreamToken(t, e);\n        });\n      }, yh.prototype.getLastRemoteSnapshotVersion = function () {\n        var e = this;\n        return this.persistence.runTransaction(\"Get last remote snapshot version\", \"readonly-idempotent\", function (t) {\n          return e.targetCache.getLastRemoteSnapshotVersion(t);\n        });\n      }, yh.prototype.applyRemoteEvent = function (u) {\n        var c = this,\n            h = u.snapshotVersion,\n            l = this.targetDataByTarget;\n        return this.persistence.runTransaction(\"Apply remote event\", \"readwrite-primary-idempotent\", function (o) {\n          var i = c.remoteDocuments.newChangeBuffer({\n            trackRemovals: !0\n          });\n          l = c.targetDataByTarget;\n          var a = [];\n          Zr(u.targetChanges, function (t, e) {\n            var n = l.get(t);\n\n            if (n) {\n              a.push(c.targetCache.removeMatchingKeys(o, e.removedDocuments, t).next(function () {\n                return c.targetCache.addMatchingKeys(o, e.addedDocuments, t);\n              }));\n              var r = e.resumeToken;\n\n              if (0 < r.length) {\n                var i = n.withResumeToken(r, h).withSequenceNumber(o.currentSequenceNumber);\n                l = l.insert(t, i), yh.shouldPersistTargetData(n, i, e) && a.push(c.targetCache.updateTargetData(o, i));\n              }\n            }\n          });\n          var s = No(),\n              n = Oo();\n\n          if (u.documentUpdates.forEach(function (t, e) {\n            n = n.add(t);\n          }), a.push(i.getEntries(o, n).next(function (r) {\n            u.documentUpdates.forEach(function (t, e) {\n              var n = r.get(t);\n              e instanceof Ks && e.version.isEqual(lo.MIN) ? (i.removeEntry(t, h), s = s.insert(t, e)) : null == n || 0 < e.version.compareTo(n.version) || 0 === e.version.compareTo(n.version) && n.hasPendingWrites ? (Ur(!lo.MIN.isEqual(h), \"Cannot add a document when the remote version is zero\"), i.addEntry(e, h), s = s.insert(t, e)) : Fr(\"LocalStore\", \"Ignoring outdated watch update for \", t, \". Current version:\", n.version, \" Watch version:\", e.version), u.resolvedLimboDocuments.has(t) && a.push(c.persistence.referenceDelegate.updateLimboDocument(o, t));\n            });\n          })), !h.isEqual(lo.MIN)) {\n            var t = c.targetCache.getLastRemoteSnapshotVersion(o).next(function (t) {\n              return Ur(0 <= h.compareTo(t), \"Watch stream reverted to previous snapshot?? \" + h + \" < \" + t), c.targetCache.setTargetsMetadata(o, o.currentSequenceNumber, h);\n            });\n            a.push(t);\n          }\n\n          return Uo.waitFor(a).next(function () {\n            return i.apply(o);\n          }).next(function () {\n            return c.localDocuments.getLocalViewOfDocuments(o, s);\n          });\n        }).then(function (t) {\n          return c.targetDataByTarget = l, t;\n        });\n      }, yh.shouldPersistTargetData = function (t, e, n) {\n        return Ur(0 < e.resumeToken.length, \"Attempted to persist target data with no resume token\"), 0 === t.resumeToken.length || e.snapshotVersion.toMicroseconds() - t.snapshotVersion.toMicroseconds() >= this.RESUME_TOKEN_MAX_AGE_MICROS || 0 < n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size;\n      }, yh.prototype.notifyLocalViewChanges = function (t) {\n        for (var n = this, e = 0, r = t; e < r.length; e++) {\n          var i = r[e],\n              o = i.targetId;\n\n          if (this.localViewReferences.addReferences(i.addedKeys, o), this.localViewReferences.removeReferences(i.removedKeys, o), !i.fromCache) {\n            var a = this.targetDataByTarget.get(o);\n            Ur(null !== a, \"Can't set limbo-free snapshot version for unknown target: \" + o);\n            var s = a.snapshotVersion,\n                u = a.withLastLimboFreeSnapshotVersion(s);\n            this.targetDataByTarget = this.targetDataByTarget.insert(o, u);\n          }\n        }\n\n        return this.persistence.runTransaction(\"notifyLocalViewChanges\", \"readwrite-idempotent\", function (e) {\n          return Uo.forEach(t, function (t) {\n            return Uo.forEach(t.removedKeys, function (t) {\n              return n.persistence.referenceDelegate.removeReference(e, t);\n            });\n          });\n        });\n      }, yh.prototype.nextMutationBatch = function (e) {\n        var n = this;\n        return this.persistence.runTransaction(\"Get next mutation batch\", \"readonly-idempotent\", function (t) {\n          return void 0 === e && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(t, e);\n        });\n      }, yh.prototype.readDocument = function (e) {\n        var n = this;\n        return this.persistence.runTransaction(\"read document\", \"readonly-idempotent\", function (t) {\n          return n.localDocuments.getDocument(t, e);\n        });\n      }, yh.prototype.allocateTarget = function (r) {\n        var i = this;\n        return this.persistence.runTransaction(\"Allocate target\", \"readwrite-idempotent\", function (e) {\n          var n;\n          return i.targetCache.getTargetData(e, r).next(function (t) {\n            return t ? (n = t, Uo.resolve(n)) : i.targetCache.allocateTargetId(e).next(function (t) {\n              return n = new ju(r, t, qu.Listen, e.currentSequenceNumber), i.targetCache.addTargetData(e, n).next(function () {\n                return n;\n              });\n            });\n          });\n        }).then(function (t) {\n          return null === i.targetDataByTarget.get(t.targetId) && (i.targetDataByTarget = i.targetDataByTarget.insert(t.targetId, t), i.targetIdByTarget.set(r, t.targetId)), t;\n        });\n      }, yh.prototype.getTargetData = function (t, e) {\n        var n = this.targetIdByTarget.get(e);\n        return void 0 !== n ? Uo.resolve(this.targetDataByTarget.get(n)) : this.targetCache.getTargetData(t, e);\n      }, yh.prototype.releaseTarget = function (n, r) {\n        var i = this,\n            o = this.targetDataByTarget.get(n);\n        Ur(null !== o, \"Tried to release nonexistent target: \" + n);\n        var t = r ? \"readwrite-idempotent\" : \"readwrite-primary-idempotent\";\n        return this.persistence.runTransaction(\"Release target\", t, function (e) {\n          var t = i.localViewReferences.removeReferencesForId(n);\n          return r ? Uo.resolve() : Uo.forEach(t, function (t) {\n            return i.persistence.referenceDelegate.removeReference(e, t);\n          }).next(function () {\n            i.persistence.referenceDelegate.removeTarget(e, o);\n          });\n        }).then(function () {\n          i.targetDataByTarget = i.targetDataByTarget.remove(n), i.targetIdByTarget.delete(o.target);\n        });\n      }, yh.prototype.executeQuery = function (t, n) {\n        var r = this,\n            i = lo.MIN,\n            o = Oo();\n        return this.persistence.runTransaction(\"Execute query\", \"readonly-idempotent\", function (e) {\n          return r.getTargetData(e, t.toTarget()).next(function (t) {\n            if (t) return i = t.lastLimboFreeSnapshotVersion, r.targetCache.getMatchingKeysForTargetId(e, t.targetId).next(function (t) {\n              o = t;\n            });\n          }).next(function () {\n            return r.queryEngine.getDocumentsMatchingQuery(e, t, n ? i : lo.MIN, n ? o : Oo());\n          }).next(function (t) {\n            return {\n              documents: t,\n              remoteKeys: o\n            };\n          });\n        });\n      }, yh.prototype.remoteDocumentKeys = function (e) {\n        var n = this;\n        return this.persistence.runTransaction(\"Remote document keys\", \"readonly-idempotent\", function (t) {\n          return n.targetCache.getMatchingKeysForTargetId(t, e);\n        });\n      }, yh.prototype.getActiveClients = function () {\n        return this.persistence.getActiveClients();\n      }, yh.prototype.removeCachedMutationBatchMetadata = function (t) {\n        this.mutationQueue.removeCachedMutationKeys(t);\n      }, yh.prototype.setNetworkEnabled = function (t) {\n        this.persistence.setNetworkEnabled(t);\n      }, yh.prototype.applyWriteToRemoteDocuments = function (t, i, o) {\n        var e = this,\n            a = i.batch,\n            n = a.keys(),\n            s = Uo.resolve();\n        return n.forEach(function (r) {\n          s = s.next(function () {\n            return o.getEntry(t, r);\n          }).next(function (t) {\n            var e = t,\n                n = i.docVersions.get(r);\n            Ur(null !== n, \"ackVersions should contain every doc in the write.\"), (!e || e.version.compareTo(n) < 0) && ((e = a.applyToRemoteDocument(r, e, i)) ? o.addEntry(e, i.commitVersion) : Ur(!t, \"Mutation batch \" + a + \" applied to document \" + t + \" resulted in null\"));\n          });\n        }), s.next(function () {\n          return e.mutationQueue.removeMutationBatch(t, a);\n        });\n      }, yh.prototype.collectGarbage = function (e) {\n        var n = this;\n        return this.persistence.runTransaction(\"Collect garbage\", \"readwrite-primary-idempotent\", function (t) {\n          return e.collect(t, n.targetDataByTarget);\n        });\n      }, yh.prototype.getTarget = function (e) {\n        var n = this,\n            t = this.targetDataByTarget.get(e);\n        return t ? Promise.resolve(t.target) : this.persistence.runTransaction(\"Get target data\", \"readonly-idempotent\", function (t) {\n          return n.targetCache.getTargetDataForTarget(t, e).next(function (t) {\n            return t ? t.target : null;\n          });\n        });\n      }, yh.prototype.getNewDocumentChanges = function () {\n        var r = this;\n        return this.persistence.runTransaction(\"Get new document changes\", \"readonly-idempotent\", function (t) {\n          return r.remoteDocuments.getNewDocumentChanges(t, r.lastDocumentChangeReadTime);\n        }).then(function (t) {\n          var e = t.changedDocs,\n              n = t.readTime;\n          return r.lastDocumentChangeReadTime = n, e;\n        });\n      }, yh.prototype.synchronizeLastDocumentChangeReadTime = function () {\n        return p(this, void 0, void 0, function () {\n          var e,\n              n = this;\n          return m(this, function (t) {\n            return this.remoteDocuments instanceof Zs ? (e = this.remoteDocuments, [2, this.persistence.runTransaction(\"Synchronize last document change read time\", \"readonly-idempotent\", function (t) {\n              return e.getLastDocumentChange(t);\n            }).then(function (t) {\n              var e = t.readTime;\n              n.lastDocumentChangeReadTime = e;\n            })]) : [2];\n          });\n        });\n      }, yh.RESUME_TOKEN_MAX_AGE_MICROS = 3e8, yh);\n\n      function yh(t, e, n) {\n        this.persistence = t, this.queryEngine = e, this.localViewReferences = new lh(), this.targetDataByTarget = new po(Si), this.targetIdByTarget = new zs(function (t) {\n          return t.canonicalId();\n        }), this.lastDocumentChangeReadTime = lo.MIN, Ur(t.started, \"LocalStore was passed an unstarted persistence implementation\"), this.persistence.referenceDelegate.setInMemoryPins(this.localViewReferences), this.mutationQueue = t.getMutationQueue(n), this.remoteDocuments = t.getRemoteDocumentCache(), this.targetCache = t.getTargetCache(), this.localDocuments = new ch(this.remoteDocuments, this.mutationQueue, this.persistence.getIndexManager()), this.queryEngine.setLocalDocumentsView(this.localDocuments);\n      }\n\n      var gh = (vh.prototype.checkEmpty = function (t) {\n        return Uo.resolve(0 === this.mutationQueue.length);\n      }, vh.prototype.acknowledgeBatch = function (t, e, n) {\n        var r = e.batchId,\n            i = this.indexOfExistingBatchId(r, \"acknowledged\");\n        Ur(0 === i, \"Can only acknowledge the first batch in the mutation queue\");\n        var o = this.mutationQueue[i];\n        return Ur(r === o.batchId, \"Queue ordering failure: expected batch \" + r + \", got batch \" + o.batchId), this.lastStreamToken = n, Uo.resolve();\n      }, vh.prototype.getLastStreamToken = function (t) {\n        return Uo.resolve(this.lastStreamToken);\n      }, vh.prototype.setLastStreamToken = function (t, e) {\n        return this.lastStreamToken = e, Uo.resolve();\n      }, vh.prototype.addMutationBatch = function (t, e, n, r) {\n        Ur(0 !== r.length, \"Mutation batches should not be empty\");\n        var i = this.nextBatchId;\n        this.nextBatchId++, 0 < this.mutationQueue.length && Ur(this.mutationQueue[this.mutationQueue.length - 1].batchId < i, \"Mutation batchIDs must be monotonically increasing order\");\n        var o = new Fo(i, e, n, r);\n        this.mutationQueue.push(o);\n\n        for (var a = 0, s = r; a < s.length; a++) {\n          var u = s[a];\n          this.batchesByDocumentKey = this.batchesByDocumentKey.add(new ph(u.key, i)), this.indexManager.addToCollectionParentIndex(t, u.key.path.popLast());\n        }\n\n        return Uo.resolve(o);\n      }, vh.prototype.lookupMutationBatch = function (t, e) {\n        return Uo.resolve(this.findMutationBatch(e));\n      }, vh.prototype.lookupMutationKeys = function (t, e) {\n        var n = this.findMutationBatch(e);\n        return Ur(null != n, \"Failed to find local mutation batch.\"), Uo.resolve(n.keys());\n      }, vh.prototype.getNextMutationBatchAfterBatchId = function (t, e) {\n        var n = e + 1,\n            r = this.indexOfBatchId(n),\n            i = r < 0 ? 0 : r;\n        return Uo.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);\n      }, vh.prototype.getHighestUnacknowledgedBatchId = function () {\n        return Uo.resolve(0 === this.mutationQueue.length ? -1 : this.nextBatchId - 1);\n      }, vh.prototype.getAllMutationBatches = function (t) {\n        return Uo.resolve(this.mutationQueue.slice());\n      }, vh.prototype.getAllMutationBatchesAffectingDocumentKey = function (t, n) {\n        var r = this,\n            e = new ph(n, 0),\n            i = new ph(n, Number.POSITIVE_INFINITY),\n            o = [];\n        return this.batchesByDocumentKey.forEachInRange([e, i], function (t) {\n          Ur(n.isEqual(t.key), \"Should only iterate over a single key's batches\");\n          var e = r.findMutationBatch(t.targetOrBatchId);\n          Ur(null !== e, \"Batches in the index must exist in the main table\"), o.push(e);\n        }), Uo.resolve(o);\n      }, vh.prototype.getAllMutationBatchesAffectingDocumentKeys = function (t, e) {\n        var r = this,\n            i = new So(Si);\n        return e.forEach(function (e) {\n          var t = new ph(e, 0),\n              n = new ph(e, Number.POSITIVE_INFINITY);\n          r.batchesByDocumentKey.forEachInRange([t, n], function (t) {\n            Ur(e.isEqual(t.key), \"For each key, should only iterate over a single key's batches\"), i = i.add(t.targetOrBatchId);\n          });\n        }), Uo.resolve(this.findMutationBatches(i));\n      }, vh.prototype.getAllMutationBatchesAffectingQuery = function (t, e) {\n        Ur(!e.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n        var n = e.path,\n            r = n.length + 1,\n            i = n;\n        Wi.isDocumentKey(i) || (i = i.child(\"\"));\n        var o = new ph(new Wi(i), 0),\n            a = new So(Si);\n        return this.batchesByDocumentKey.forEachWhile(function (t) {\n          var e = t.key.path;\n          return !!n.isPrefixOf(e) && (e.length === r && (a = a.add(t.targetOrBatchId)), !0);\n        }, o), Uo.resolve(this.findMutationBatches(a));\n      }, vh.prototype.findMutationBatches = function (t) {\n        var n = this,\n            r = [];\n        return t.forEach(function (t) {\n          var e = n.findMutationBatch(t);\n          null !== e && r.push(e);\n        }), r;\n      }, vh.prototype.removeMutationBatch = function (n, r) {\n        var i = this;\n        Ur(0 === this.indexOfExistingBatchId(r.batchId, \"removed\"), \"Can only remove the first entry of the mutation queue\"), this.mutationQueue.shift();\n        var o = this.batchesByDocumentKey;\n        return Uo.forEach(r.mutations, function (t) {\n          var e = new ph(t.key, r.batchId);\n          return o = o.delete(e), i.referenceDelegate.removeMutationReference(n, t.key);\n        }).next(function () {\n          i.batchesByDocumentKey = o;\n        });\n      }, vh.prototype.removeCachedMutationKeys = function (t) {}, vh.prototype.containsKey = function (t, e) {\n        var n = new ph(e, 0),\n            r = this.batchesByDocumentKey.firstAfterOrEqual(n);\n        return Uo.resolve(e.isEqual(r && r.key));\n      }, vh.prototype.performConsistencyCheck = function (t) {\n        return 0 === this.mutationQueue.length && Ur(this.batchesByDocumentKey.isEmpty(), \"Document leak -- detected dangling mutation references when queue is empty.\"), Uo.resolve();\n      }, vh.prototype.indexOfExistingBatchId = function (t, e) {\n        var n = this.indexOfBatchId(t);\n        return Ur(0 <= n && n < this.mutationQueue.length, \"Batches must exist to be \" + e), n;\n      }, vh.prototype.indexOfBatchId = function (t) {\n        return 0 === this.mutationQueue.length ? 0 : t - this.mutationQueue[0].batchId;\n      }, vh.prototype.findMutationBatch = function (t) {\n        var e = this.indexOfBatchId(t);\n        if (e < 0 || e >= this.mutationQueue.length) return null;\n        var n = this.mutationQueue[e];\n        return Ur(n.batchId === t, \"If found batch must match\"), n;\n      }, vh);\n\n      function vh(t, e) {\n        this.indexManager = t, this.referenceDelegate = e, this.mutationQueue = [], this.nextBatchId = 1, this.lastStreamToken = jr(), this.batchesByDocumentKey = new So(ph.compareByKey);\n      }\n\n      var bh,\n          wh = (Th.prototype.addEntry = function (t, e, n) {\n        Ur(!n.isEqual(lo.MIN), \"Cannot add a document with a read time of zero\");\n        var r = e.key,\n            i = this.docs.get(r),\n            o = i ? i.size : 0,\n            a = this.sizer(e);\n        return this.docs = this.docs.insert(r, {\n          maybeDocument: e,\n          size: a,\n          readTime: n\n        }), this.size += a - o, this.indexManager.addToCollectionParentIndex(t, r.path.popLast());\n      }, Th.prototype.removeEntry = function (t) {\n        var e = this.docs.get(t);\n        e && (this.docs = this.docs.remove(t), this.size -= e.size);\n      }, Th.prototype.getEntry = function (t, e) {\n        var n = this.docs.get(e);\n        return Uo.resolve(n ? n.maybeDocument : null);\n      }, Th.prototype.getEntries = function (t, e) {\n        var n = this,\n            r = Ao();\n        return e.forEach(function (t) {\n          var e = n.docs.get(t);\n          r = r.insert(t, e ? e.maybeDocument : null);\n        }), Uo.resolve(r);\n      }, Th.prototype.getDocumentsMatchingQuery = function (t, e, n) {\n        Ur(!e.isCollectionGroupQuery(), \"CollectionGroup queries should be handled in LocalDocumentsView\");\n\n        for (var r = Ro(), i = new Wi(e.path.child(\"\")), o = this.docs.getIteratorFrom(i); o.hasNext();) {\n          var a = o.getNext(),\n              s = a.key,\n              u = a.value,\n              c = u.maybeDocument,\n              h = u.readTime;\n          if (!e.path.isPrefixOf(s.path)) break;\n          h.compareTo(n) <= 0 || c instanceof Vs && e.matches(c) && (r = r.insert(c.key, c));\n        }\n\n        return Uo.resolve(r);\n      }, Th.prototype.forEachDocumentKey = function (t, e) {\n        return Uo.forEach(this.docs, function (t) {\n          return e(t);\n        });\n      }, Th.prototype.getNewDocumentChanges = function (t, e) {\n        throw new Error(\"getNewDocumentChanges() is not supported with MemoryPersistence\");\n      }, Th.prototype.newChangeBuffer = function (t) {\n        return new Th.RemoteDocumentChangeBuffer(this);\n      }, Th.prototype.getSize = function (t) {\n        return Uo.resolve(this.size);\n      }, Th.RemoteDocumentChangeBuffer = (t(Sh, bh = Ys), Sh.prototype.applyChanges = function (n) {\n        var r = this,\n            i = [];\n        return this.changes.forEach(function (t, e) {\n          e ? i.push(r.documentCache.addEntry(n, e, r.readTime)) : r.documentCache.removeEntry(t);\n        }), Uo.waitFor(i);\n      }, Sh.prototype.getFromCache = function (t, e) {\n        return this.documentCache.getEntry(t, e);\n      }, Sh.prototype.getAllFromCache = function (t, e) {\n        return this.documentCache.getEntries(t, e);\n      }, Sh), Th);\n\n      function Th(t, e) {\n        this.indexManager = t, this.sizer = e, this.docs = new po(Wi.comparator), this.size = 0;\n      }\n\n      function Sh(t) {\n        var e = bh.call(this) || this;\n        return e.documentCache = t, e;\n      }\n\n      var Eh = (Ih.prototype.forEachTarget = function (t, n) {\n        return this.targets.forEach(function (t, e) {\n          return n(e);\n        }), Uo.resolve();\n      }, Ih.prototype.getLastRemoteSnapshotVersion = function (t) {\n        return Uo.resolve(this.lastRemoteSnapshotVersion);\n      }, Ih.prototype.getHighestSequenceNumber = function (t) {\n        return Uo.resolve(this.highestSequenceNumber);\n      }, Ih.prototype.allocateTargetId = function (t) {\n        var e = this.targetIdGenerator.after(this.highestTargetId);\n        return this.highestTargetId = e, Uo.resolve(e);\n      }, Ih.prototype.setTargetsMetadata = function (t, e, n) {\n        return n && (this.lastRemoteSnapshotVersion = n), e > this.highestSequenceNumber && (this.highestSequenceNumber = e), Uo.resolve();\n      }, Ih.prototype.saveTargetData = function (t) {\n        this.targets.set(t.target, t);\n        var e = t.targetId;\n        e > this.highestTargetId && (this.highestTargetId = e), t.sequenceNumber > this.highestSequenceNumber && (this.highestSequenceNumber = t.sequenceNumber);\n      }, Ih.prototype.addTargetData = function (t, e) {\n        return Ur(!this.targets.has(e.target), \"Adding a target that already exists\"), this.saveTargetData(e), this.targetCount += 1, Uo.resolve();\n      }, Ih.prototype.updateTargetData = function (t, e) {\n        return Ur(this.targets.has(e.target), \"Updating a non-existent target\"), this.saveTargetData(e), Uo.resolve();\n      }, Ih.prototype.removeTargetData = function (t, e) {\n        return Ur(0 < this.targetCount, \"Removing a target from an empty cache\"), Ur(this.targets.has(e.target), \"Removing a non-existent target from the cache\"), this.targets.delete(e.target), this.references.removeReferencesForId(e.targetId), this.targetCount -= 1, Uo.resolve();\n      }, Ih.prototype.removeTargets = function (n, r, i) {\n        var o = this,\n            a = 0,\n            s = [];\n        return this.targets.forEach(function (t, e) {\n          e.sequenceNumber <= r && null === i.get(e.targetId) && (o.targets.delete(t), s.push(o.removeMatchingKeysForTargetId(n, e.targetId)), a++);\n        }), Uo.waitFor(s).next(function () {\n          return a;\n        });\n      }, Ih.prototype.getTargetCount = function (t) {\n        return Uo.resolve(this.targetCount);\n      }, Ih.prototype.getTargetData = function (t, e) {\n        var n = this.targets.get(e) || null;\n        return Uo.resolve(n);\n      }, Ih.prototype.getTargetDataForTarget = function (t, e) {\n        return Br(\"Not yet implemented.\");\n      }, Ih.prototype.addMatchingKeys = function (e, t, n) {\n        this.references.addReferences(t, n);\n        var r = this.persistence.referenceDelegate,\n            i = [];\n        return r && t.forEach(function (t) {\n          i.push(r.addReference(e, t));\n        }), Uo.waitFor(i);\n      }, Ih.prototype.removeMatchingKeys = function (e, t, n) {\n        this.references.removeReferences(t, n);\n        var r = this.persistence.referenceDelegate,\n            i = [];\n        return r && t.forEach(function (t) {\n          i.push(r.removeReference(e, t));\n        }), Uo.waitFor(i);\n      }, Ih.prototype.removeMatchingKeysForTargetId = function (t, e) {\n        return this.references.removeReferencesForId(e), Uo.resolve();\n      }, Ih.prototype.getMatchingKeysForTargetId = function (t, e) {\n        var n = this.references.referencesForId(e);\n        return Uo.resolve(n);\n      }, Ih.prototype.containsKey = function (t, e) {\n        return Uo.resolve(this.references.containsKey(e));\n      }, Ih);\n\n      function Ih(t) {\n        this.persistence = t, this.targets = new zs(function (t) {\n          return t.canonicalId();\n        }), this.lastRemoteSnapshotVersion = lo.MIN, this.highestTargetId = 0, this.highestSequenceNumber = 0, this.references = new lh(), this.targetCount = 0, this.targetIdGenerator = la.forTargetCache();\n      }\n\n      var Ch = (Dh.createLruPersistence = function (t, e, n) {\n        return new Dh(t, function (t) {\n          return new _h(t, new Wu(e), n);\n        });\n      }, Dh.createEagerPersistence = function (t) {\n        return new Dh(t, function (t) {\n          return new Rh(t);\n        });\n      }, Dh.prototype.shutdown = function () {\n        return this._started = !1, Promise.resolve();\n      }, Object.defineProperty(Dh.prototype, \"started\", {\n        get: function () {\n          return this._started;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Dh.prototype.getActiveClients = function () {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            return [2, [this.clientId]];\n          });\n        });\n      }, Dh.prototype.setPrimaryStateListener = function (t) {\n        return t(!0);\n      }, Dh.prototype.setDatabaseDeletedListener = function () {}, Dh.prototype.setNetworkEnabled = function (t) {}, Dh.prototype.getIndexManager = function () {\n        return this.indexManager;\n      }, Dh.prototype.getMutationQueue = function (t) {\n        var e = this.mutationQueues[t.toKey()];\n        return e || (e = new gh(this.indexManager, this.referenceDelegate), this.mutationQueues[t.toKey()] = e), e;\n      }, Dh.prototype.getTargetCache = function () {\n        return this.targetCache;\n      }, Dh.prototype.getRemoteDocumentCache = function () {\n        return this.remoteDocumentCache;\n      }, Dh.prototype.runTransaction = function (t, e, n) {\n        var r = this;\n        Fr(\"MemoryPersistence\", \"Starting transaction:\", t);\n        var i = new Ah(this.listenSequence.next());\n        return this.referenceDelegate.onTransactionStarted(), n(i).next(function (t) {\n          return r.referenceDelegate.onTransactionCommitted(i).next(function () {\n            return t;\n          });\n        }).toPromise().then(function (t) {\n          return i.raiseOnCommittedEvent(), t;\n        });\n      }, Dh.prototype.mutationQueuesContainKey = function (e, n) {\n        return Uo.or(function (t) {\n          var n = [];\n          return $r(t, function (t, e) {\n            return n.push(e);\n          }), n;\n        }(this.mutationQueues).map(function (t) {\n          return function () {\n            return t.containsKey(e, n);\n          };\n        }));\n      }, Dh);\n\n      function Dh(t, e) {\n        var n = this;\n        this.clientId = t, this.mutationQueues = {}, this.listenSequence = new Oi(0), this._started = !1, this._started = !0, this.referenceDelegate = e(this), this.targetCache = new Eh(this);\n        this.indexManager = new ou(), this.remoteDocumentCache = new wh(this.indexManager, function (t) {\n          return n.referenceDelegate.documentSize(t);\n        });\n      }\n\n      var Nh,\n          Ah = (t(kh, Nh = ic), kh);\n\n      function kh(t) {\n        var e = Nh.call(this) || this;\n        return e.currentSequenceNumber = t, e;\n      }\n\n      var Rh = (Object.defineProperty(Mh.prototype, \"orphanedDocuments\", {\n        get: function () {\n          if (this._orphanedDocuments) return this._orphanedDocuments;\n          throw Br(\"orphanedDocuments is only valid during a transaction.\");\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Mh.prototype.setInMemoryPins = function (t) {\n        this.inMemoryPins = t;\n      }, Mh.prototype.addReference = function (t, e) {\n        return this.orphanedDocuments.delete(e), Uo.resolve();\n      }, Mh.prototype.removeReference = function (t, e) {\n        return this.orphanedDocuments.add(e), Uo.resolve();\n      }, Mh.prototype.removeMutationReference = function (t, e) {\n        return this.orphanedDocuments.add(e), Uo.resolve();\n      }, Mh.prototype.removeTarget = function (t, e) {\n        var n = this,\n            r = this.persistence.getTargetCache();\n        return r.getMatchingKeysForTargetId(t, e.targetId).next(function (t) {\n          t.forEach(function (t) {\n            return n.orphanedDocuments.add(t);\n          });\n        }).next(function () {\n          return r.removeTargetData(t, e);\n        });\n      }, Mh.prototype.onTransactionStarted = function () {\n        this._orphanedDocuments = new Set();\n      }, Mh.prototype.onTransactionCommitted = function (t) {\n        var n = this,\n            r = this.persistence.getRemoteDocumentCache().newChangeBuffer();\n        return Uo.forEach(this.orphanedDocuments, function (e) {\n          return n.isReferenced(t, e).next(function (t) {\n            t || r.removeEntry(e);\n          });\n        }).next(function () {\n          return n._orphanedDocuments = null, r.apply(t);\n        });\n      }, Mh.prototype.updateLimboDocument = function (t, e) {\n        var n = this;\n        return this.isReferenced(t, e).next(function (t) {\n          t ? n.orphanedDocuments.delete(e) : n.orphanedDocuments.add(e);\n        });\n      }, Mh.prototype.documentSize = function (t) {\n        return 0;\n      }, Mh.prototype.isReferenced = function (t, e) {\n        var n = this;\n        return Uo.or([function () {\n          return n.persistence.getTargetCache().containsKey(t, e);\n        }, function () {\n          return n.persistence.mutationQueuesContainKey(t, e);\n        }, function () {\n          return Uo.resolve(n.inMemoryPins.containsKey(e));\n        }]);\n      }, Mh);\n\n      function Mh(t) {\n        this.persistence = t, this.inMemoryPins = null, this._orphanedDocuments = null;\n      }\n\n      var _h = (Lh.prototype.onTransactionStarted = function () {}, Lh.prototype.onTransactionCommitted = function (t) {\n        return Uo.resolve();\n      }, Lh.prototype.forEachTarget = function (t, e) {\n        return this.persistence.getTargetCache().forEachTarget(t, e);\n      }, Lh.prototype.getSequenceNumberCount = function (t) {\n        var n = this.orphanedDocumentCount(t);\n        return this.persistence.getTargetCache().getTargetCount(t).next(function (e) {\n          return n.next(function (t) {\n            return e + t;\n          });\n        });\n      }, Lh.prototype.orphanedDocumentCount = function (t) {\n        var e = 0;\n        return this.forEachOrphanedDocumentSequenceNumber(t, function (t) {\n          e++;\n        }).next(function () {\n          return e;\n        });\n      }, Lh.prototype.forEachOrphanedDocumentSequenceNumber = function (n, r) {\n        var i = this;\n        return Uo.forEach(this.orphanedSequenceNumbers, function (t, e) {\n          return i.isPinned(n, t, e).next(function (t) {\n            return t ? Uo.resolve() : r(e);\n          });\n        });\n      }, Lh.prototype.setInMemoryPins = function (t) {\n        this.inMemoryPins = t;\n      }, Lh.prototype.removeTargets = function (t, e, n) {\n        return this.persistence.getTargetCache().removeTargets(t, e, n);\n      }, Lh.prototype.removeOrphanedDocuments = function (t, n) {\n        var r = this,\n            i = 0,\n            e = this.persistence.getRemoteDocumentCache(),\n            o = e.newChangeBuffer();\n        return e.forEachDocumentKey(t, function (e) {\n          return r.isPinned(t, e, n).next(function (t) {\n            t || (i++, o.removeEntry(e));\n          });\n        }).next(function () {\n          return o.apply(t);\n        }).next(function () {\n          return i;\n        });\n      }, Lh.prototype.removeMutationReference = function (t, e) {\n        return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), Uo.resolve();\n      }, Lh.prototype.removeTarget = function (t, e) {\n        var n = e.withSequenceNumber(t.currentSequenceNumber);\n        return this.persistence.getTargetCache().updateTargetData(t, n);\n      }, Lh.prototype.addReference = function (t, e) {\n        return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), Uo.resolve();\n      }, Lh.prototype.removeReference = function (t, e) {\n        return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), Uo.resolve();\n      }, Lh.prototype.updateLimboDocument = function (t, e) {\n        return this.orphanedSequenceNumbers.set(e, t.currentSequenceNumber), Uo.resolve();\n      }, Lh.prototype.documentSize = function (t) {\n        var e,\n            n = this.serializer.toDbRemoteDocument(t, t.version);\n        if (n.document) e = n.document;else if (n.unknownDocument) e = n.unknownDocument;else {\n          if (!n.noDocument) throw Br(\"Unknown remote document type\");\n          e = n.noDocument;\n        }\n        return JSON.stringify(e).length;\n      }, Lh.prototype.isPinned = function (t, e, n) {\n        var r = this;\n        return Uo.or([function () {\n          return r.persistence.mutationQueuesContainKey(t, e);\n        }, function () {\n          return Uo.resolve(r.inMemoryPins.containsKey(e));\n        }, function () {\n          return r.persistence.getTargetCache().containsKey(t, e);\n        }, function () {\n          var t = r.orphanedSequenceNumbers.get(e);\n          return Uo.resolve(void 0 !== t && n < t);\n        }]);\n      }, Lh.prototype.getCacheSize = function (t) {\n        return this.persistence.getRemoteDocumentCache().getSize(t);\n      }, Lh);\n\n      function Lh(t, e, n) {\n        this.persistence = t, this.serializer = e, this.inMemoryPins = null, this.orphanedSequenceNumbers = new zs(function (t) {\n          return oo(t.path);\n        }), this.garbageCollector = new nc(this, n);\n      }\n\n      var Oh = (Ph.prototype.reset = function () {\n        this.currentBaseMs = 0;\n      }, Ph.prototype.resetToMax = function () {\n        this.currentBaseMs = this.maxDelayMs;\n      }, Ph.prototype.backoffAndRun = function (t) {\n        var e = this;\n        this.cancel();\n        var n = Math.floor(this.currentBaseMs + this.jitterDelayMs()),\n            r = Math.max(0, Date.now() - this.lastAttemptTime),\n            i = Math.max(0, n - r);\n        0 < this.currentBaseMs && Fr(\"ExponentialBackoff\", \"Backing off for \" + i + \" ms (base delay: \" + this.currentBaseMs + \" ms, delay with jitter: \" + n + \" ms, last attempt: \" + r + \" ms ago)\"), this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, i, function () {\n          return e.lastAttemptTime = Date.now(), t();\n        }), this.currentBaseMs *= this.backoffFactor, this.currentBaseMs < this.initialDelayMs && (this.currentBaseMs = this.initialDelayMs), this.currentBaseMs > this.maxDelayMs && (this.currentBaseMs = this.maxDelayMs);\n      }, Ph.prototype.cancel = function () {\n        null !== this.timerPromise && (this.timerPromise.cancel(), this.timerPromise = null);\n      }, Ph.prototype.jitterDelayMs = function () {\n        return (Math.random() - .5) * this.currentBaseMs;\n      }, Ph);\n\n      function Ph(t, e, n, r, i) {\n        void 0 === n && (n = 1e3), void 0 === r && (r = 1.5), void 0 === i && (i = 6e4), this.queue = t, this.timerId = e, this.initialDelayMs = n, this.backoffFactor = r, this.maxDelayMs = i, this.currentBaseMs = 0, this.timerPromise = null, this.lastAttemptTime = Date.now(), this.reset();\n      }\n\n      var xh,\n          Fh,\n          qh = \"PersistentStream\";\n      (Fh = xh = xh || {})[Fh.Initial = 0] = \"Initial\", Fh[Fh.Starting = 1] = \"Starting\", Fh[Fh.Open = 2] = \"Open\", Fh[Fh.Error = 3] = \"Error\", Fh[Fh.Backoff = 4] = \"Backoff\";\n      var Vh = (Bh.prototype.isStarted = function () {\n        return this.state === xh.Starting || this.state === xh.Open || this.state === xh.Backoff;\n      }, Bh.prototype.isOpen = function () {\n        return this.state === xh.Open;\n      }, Bh.prototype.start = function () {\n        this.state !== xh.Error ? (Ur(this.state === xh.Initial, \"Already started\"), this.auth()) : this.performBackoff();\n      }, Bh.prototype.stop = function () {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.isStarted() ? [4, this.close(xh.Initial)] : [3, 2];\n\n              case 1:\n                t.sent(), t.label = 2;\n\n              case 2:\n                return [2];\n            }\n          });\n        });\n      }, Bh.prototype.inhibitBackoff = function () {\n        Ur(!this.isStarted(), \"Can only inhibit backoff in a stopped state\"), this.state = xh.Initial, this.backoff.reset();\n      }, Bh.prototype.markIdle = function () {\n        var t = this;\n        this.isOpen() && null === this.idleTimer && (this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, 6e4, function () {\n          return t.handleIdleCloseTimer();\n        }));\n      }, Bh.prototype.sendRequest = function (t) {\n        this.cancelIdleCheck(), this.stream.send(t);\n      }, Bh.prototype.handleIdleCloseTimer = function () {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            return this.isOpen() ? [2, this.close(xh.Initial)] : [2];\n          });\n        });\n      }, Bh.prototype.cancelIdleCheck = function () {\n        this.idleTimer && (this.idleTimer.cancel(), this.idleTimer = null);\n      }, Bh.prototype.close = function (e, n) {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return Ur(this.isStarted(), \"Only started streams should be closed.\"), Ur(e === xh.Error || Ic(n), \"Can't provide an error when not in an error state.\"), this.cancelIdleCheck(), this.backoff.cancel(), this.closeCount++, e !== xh.Error ? this.backoff.reset() : n && n.code === Wr.RESOURCE_EXHAUSTED ? (qr(n.toString()), qr(\"Using maximum backoff delay to prevent overloading the backend.\"), this.backoff.resetToMax()) : n && n.code === Wr.UNAUTHENTICATED && this.credentialsProvider.invalidateToken(), null !== this.stream && (this.tearDown(), this.stream.close(), this.stream = null), this.state = e, [4, this.listener.onClose(n)];\n\n              case 1:\n                return t.sent(), [2];\n            }\n          });\n        });\n      }, Bh.prototype.tearDown = function () {}, Bh.prototype.auth = function () {\n        var n = this;\n        Ur(this.state === xh.Initial, \"Must be in initial state to auth\"), this.state = xh.Starting;\n        var t = this.getCloseGuardedDispatcher(this.closeCount),\n            e = this.closeCount;\n        this.credentialsProvider.getToken().then(function (t) {\n          n.closeCount === e && n.startStream(t);\n        }, function (e) {\n          t(function () {\n            var t = new zr(Wr.UNKNOWN, \"Fetching auth token failed: \" + e.message);\n            return n.handleStreamClose(t);\n          });\n        });\n      }, Bh.prototype.startStream = function (t) {\n        var e = this;\n        Ur(this.state === xh.Starting, \"Trying to start stream in a non-starting state\");\n        var n = this.getCloseGuardedDispatcher(this.closeCount);\n        this.stream = this.startRpc(t), this.stream.onOpen(function () {\n          n(function () {\n            return Ur(e.state === xh.Starting, \"Expected stream to be in state Starting, but was \" + e.state), e.state = xh.Open, e.listener.onOpen();\n          });\n        }), this.stream.onClose(function (t) {\n          n(function () {\n            return e.handleStreamClose(t);\n          });\n        }), this.stream.onMessage(function (t) {\n          n(function () {\n            return e.onMessage(t);\n          });\n        });\n      }, Bh.prototype.performBackoff = function () {\n        var t = this;\n        Ur(this.state === xh.Error, \"Should only perform backoff when in Error state\"), this.state = xh.Backoff, this.backoff.backoffAndRun(function () {\n          return p(t, void 0, void 0, function () {\n            return m(this, function (t) {\n              return Ur(this.state === xh.Backoff, \"Backoff elapsed but state is now: \" + this.state), this.state = xh.Initial, this.start(), Ur(this.isStarted(), \"PersistentStream should have started\"), [2];\n            });\n          });\n        });\n      }, Bh.prototype.handleStreamClose = function (t) {\n        return Ur(this.isStarted(), \"Can't handle server close on non-started stream\"), Fr(qh, \"close with error: \" + t), this.stream = null, this.close(xh.Error, t);\n      }, Bh.prototype.getCloseGuardedDispatcher = function (e) {\n        var n = this;\n        return function (t) {\n          n.queue.enqueueAndForget(function () {\n            return n.closeCount === e ? t() : (Fr(qh, \"stream callback skipped by getCloseGuardedDispatcher.\"), Promise.resolve());\n          });\n        };\n      }, Bh);\n\n      function Bh(t, e, n, r, i, o) {\n        this.queue = t, this.idleTimerId = n, this.connection = r, this.credentialsProvider = i, this.listener = o, this.state = xh.Initial, this.closeCount = 0, this.idleTimer = null, this.stream = null, this.backoff = new Oh(t, e);\n      }\n\n      var Uh,\n          Kh = (t(Qh, Uh = Vh), Qh.prototype.startRpc = function (t) {\n        return this.connection.openStream(\"Listen\", t);\n      }, Qh.prototype.onMessage = function (t) {\n        this.backoff.reset();\n        var e = this.serializer.fromWatchChange(t),\n            n = this.serializer.versionFromListenResponse(t);\n        return this.listener.onWatchChange(e, n);\n      }, Qh.prototype.watch = function (t) {\n        var e = {};\n        e.database = this.serializer.encodedDatabaseId, e.addTarget = this.serializer.toTarget(t);\n        var n = this.serializer.toListenRequestLabels(t);\n        n && (e.labels = n), this.sendRequest(e);\n      }, Qh.prototype.unwatch = function (t) {\n        var e = {};\n        e.database = this.serializer.encodedDatabaseId, e.removeTarget = t, this.sendRequest(e);\n      }, Qh);\n\n      function Qh(t, e, n, r, i) {\n        var o = Uh.call(this, t, Hi.ListenStreamConnectionBackoff, Hi.ListenStreamIdle, e, n, i) || this;\n        return o.serializer = r, o;\n      }\n\n      var jh,\n          Gh = (t(Wh, jh = Vh), Object.defineProperty(Wh.prototype, \"handshakeComplete\", {\n        get: function () {\n          return this.handshakeComplete_;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Wh.prototype.start = function () {\n        this.handshakeComplete_ = !1, jh.prototype.start.call(this);\n      }, Wh.prototype.tearDown = function () {\n        this.handshakeComplete_ && this.writeMutations([]);\n      }, Wh.prototype.startRpc = function (t) {\n        return this.connection.openStream(\"Write\", t);\n      }, Wh.prototype.onMessage = function (t) {\n        if (Ur(!!t.streamToken, \"Got a write response without a stream token\"), this.lastStreamToken = t.streamToken, this.handshakeComplete_) {\n          this.backoff.reset();\n          var e = this.serializer.fromWriteResults(t.writeResults, t.commitTime),\n              n = this.serializer.fromVersion(t.commitTime);\n          return this.listener.onMutationResult(n, e);\n        }\n\n        return Ur(!t.writeResults || 0 === t.writeResults.length, \"Got mutation results for handshake\"), this.handshakeComplete_ = !0, this.listener.onHandshakeComplete();\n      }, Wh.prototype.writeHandshake = function () {\n        Ur(this.isOpen(), \"Writing handshake requires an opened stream\"), Ur(!this.handshakeComplete_, \"Handshake already completed\");\n        var t = {};\n        t.database = this.serializer.encodedDatabaseId, this.sendRequest(t);\n      }, Wh.prototype.writeMutations = function (t) {\n        var e = this;\n        Ur(this.isOpen(), \"Writing mutations requires an opened stream\"), Ur(this.handshakeComplete_, \"Handshake must be complete before writing mutations\"), Ur(0 < this.lastStreamToken.length, \"Trying to write mutation without a token\");\n        var n = {\n          streamToken: this.lastStreamToken,\n          writes: t.map(function (t) {\n            return e.serializer.toMutation(t);\n          })\n        };\n        this.sendRequest(n);\n      }, Wh);\n\n      function Wh(t, e, n, r, i) {\n        var o = jh.call(this, t, Hi.WriteStreamConnectionBackoff, Hi.WriteStreamIdle, e, n, i) || this;\n        return o.serializer = r, o.handshakeComplete_ = !1, o.lastStreamToken = jr(), o;\n      }\n\n      var zh = (Hh.prototype.newPersistentWriteStream = function (t) {\n        return new Gh(this.queue, this.connection, this.credentials, this.serializer, t);\n      }, Hh.prototype.newPersistentWatchStream = function (t) {\n        return new Kh(this.queue, this.connection, this.credentials, this.serializer, t);\n      }, Hh.prototype.commit = function (t) {\n        var e = this,\n            n = {\n          database: this.serializer.encodedDatabaseId,\n          writes: t.map(function (t) {\n            return e.serializer.toMutation(t);\n          })\n        };\n        return this.invokeRPC(\"Commit\", n).then(function (t) {\n          return e.serializer.fromWriteResults(t.writeResults, t.commitTime);\n        });\n      }, Hh.prototype.lookup = function (e) {\n        var i = this,\n            t = {\n          database: this.serializer.encodedDatabaseId,\n          documents: e.map(function (t) {\n            return i.serializer.toName(t);\n          })\n        };\n        return this.invokeStreamingRPC(\"BatchGetDocuments\", t).then(function (t) {\n          var n = No();\n          t.forEach(function (t) {\n            var e = i.serializer.fromMaybeDocument(t);\n            n = n.insert(e.key, e);\n          });\n          var r = [];\n          return e.forEach(function (t) {\n            var e = n.get(t);\n            Ur(!!e, \"Missing entity in write response for \" + t), r.push(e);\n          }), r;\n        });\n      }, Hh.prototype.invokeRPC = function (e, n) {\n        var r = this;\n        return this.credentials.getToken().then(function (t) {\n          return r.connection.invokeRPC(e, n, t);\n        }).catch(function (t) {\n          throw t.code === Wr.UNAUTHENTICATED && r.credentials.invalidateToken(), t;\n        });\n      }, Hh.prototype.invokeStreamingRPC = function (e, n) {\n        var r = this;\n        return this.credentials.getToken().then(function (t) {\n          return r.connection.invokeStreamingRPC(e, n, t);\n        }).catch(function (t) {\n          throw t.code === Wr.UNAUTHENTICATED && r.credentials.invalidateToken(), t;\n        });\n      }, Hh);\n\n      function Hh(t, e, n, r) {\n        this.queue = t, this.connection = e, this.credentials = n, this.serializer = r;\n      }\n\n      var Yh,\n          Jh,\n          Xh,\n          Zh,\n          $h = (tl.prototype.lookup = function (r) {\n        return p(this, void 0, void 0, function () {\n          var e,\n              n = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                if (this.ensureCommitNotCalled(), 0 < this.mutations.length) throw new zr(Wr.INVALID_ARGUMENT, \"Firestore transactions require all reads to be executed before all writes.\");\n                return [4, this.datastore.lookup(r)];\n\n              case 1:\n                return (e = t.sent()).forEach(function (t) {\n                  t instanceof Ks || t instanceof Vs ? n.recordVersion(t) : Br(\"Document in a transaction was a \" + t.constructor.name);\n                }), [2, e];\n            }\n          });\n        });\n      }, tl.prototype.set = function (t, e) {\n        this.write(e.toMutations(t, this.precondition(t))), this.writtenDocs.add(t);\n      }, tl.prototype.update = function (t, e) {\n        try {\n          this.write(e.toMutations(t, this.preconditionForUpdate(t)));\n        } catch (t) {\n          this.lastWriteError = t;\n        }\n\n        this.writtenDocs.add(t);\n      }, tl.prototype.delete = function (t) {\n        this.write([new ja(t, this.precondition(t))]), this.writtenDocs.add(t);\n      }, tl.prototype.commit = function () {\n        return p(this, void 0, void 0, function () {\n          var e;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                if (this.ensureCommitNotCalled(), this.lastWriteError) throw this.lastWriteError;\n                if (e = this.readVersions, this.mutations.forEach(function (t) {\n                  e = e.remove(t.key);\n                }), !e.isEmpty()) throw new zr(Wr.INVALID_ARGUMENT, \"Every document read in a transaction must also be written.\");\n                return [4, this.datastore.commit(this.mutations)];\n\n              case 1:\n                return t.sent(), this.committed = !0, [2];\n            }\n          });\n        });\n      }, tl.prototype.recordVersion = function (t) {\n        var e;\n        if (t instanceof Vs) e = t.version;else {\n          if (!(t instanceof Ks)) throw Br(\"Document in a transaction was a \" + t.constructor.name);\n          e = lo.forDeletedDoc();\n        }\n        var n = this.readVersions.get(t.key);\n\n        if (null !== n) {\n          if (!e.isEqual(n)) throw new zr(Wr.ABORTED, \"Document version changed between two reads.\");\n        } else this.readVersions = this.readVersions.insert(t.key, e);\n      }, tl.prototype.precondition = function (t) {\n        var e = this.readVersions.get(t);\n        return !this.writtenDocs.has(t) && e ? Da.updateTime(e) : Da.NONE;\n      }, tl.prototype.preconditionForUpdate = function (t) {\n        var e = this.readVersions.get(t);\n        if (this.writtenDocs.has(t) || !e) return Da.exists(!0);\n        if (e.isEqual(lo.forDeletedDoc())) throw new zr(Wr.INVALID_ARGUMENT, \"Can't update a document that doesn't exist.\");\n        return Da.updateTime(e);\n      }, tl.prototype.write = function (t) {\n        this.ensureCommitNotCalled(), this.mutations = this.mutations.concat(t);\n      }, tl.prototype.ensureCommitNotCalled = function () {\n        Ur(!this.committed, \"A transaction object cannot be used after its update callback has been invoked.\");\n      }, tl);\n\n      function tl(t) {\n        this.datastore = t, this.readVersions = _o(), this.mutations = [], this.committed = !1, this.lastWriteError = null, this.writtenDocs = new Set();\n      }\n\n      (Jh = Yh = Yh || {})[Jh.Unknown = 0] = \"Unknown\", Jh[Jh.Online = 1] = \"Online\", Jh[Jh.Offline = 2] = \"Offline\", (Zh = Xh = Xh || {})[Zh.RemoteStore = 0] = \"RemoteStore\", Zh[Zh.SharedClientState = 1] = \"SharedClientState\";\n      var el,\n          nl,\n          rl = (il.prototype.handleWatchStreamStart = function () {\n        var t = this;\n        0 === this.watchStreamFailures && (this.setAndBroadcast(Yh.Unknown), Ur(null === this.onlineStateTimer, \"onlineStateTimer shouldn't be started yet\"), this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(Hi.OnlineStateTimeout, 1e4, function () {\n          return t.onlineStateTimer = null, Ur(t.state === Yh.Unknown, \"Timer should be canceled if we transitioned to a different state.\"), t.logClientOfflineWarningIfNecessary(\"Backend didn't respond within 10 seconds.\"), t.setAndBroadcast(Yh.Offline), Promise.resolve();\n        }));\n      }, il.prototype.handleWatchStreamFailure = function (t) {\n        this.state === Yh.Online ? (this.setAndBroadcast(Yh.Unknown), Ur(0 === this.watchStreamFailures, \"watchStreamFailures must be 0\"), Ur(null === this.onlineStateTimer, \"onlineStateTimer must be null\")) : (this.watchStreamFailures++, 1 <= this.watchStreamFailures && (this.clearOnlineStateTimer(), this.logClientOfflineWarningIfNecessary(\"Connection failed 1 times. Most recent error: \" + t.toString()), this.setAndBroadcast(Yh.Offline)));\n      }, il.prototype.set = function (t) {\n        this.clearOnlineStateTimer(), this.watchStreamFailures = 0, t === Yh.Online && (this.shouldWarnClientIsOffline = !1), this.setAndBroadcast(t);\n      }, il.prototype.setAndBroadcast = function (t) {\n        t !== this.state && (this.state = t, this.onlineStateHandler(t));\n      }, il.prototype.logClientOfflineWarningIfNecessary = function (t) {\n        var e = \"Could not reach Cloud Firestore backend. \" + t + \"\\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.\";\n        this.shouldWarnClientIsOffline ? (qr(e), this.shouldWarnClientIsOffline = !1) : Fr(\"OnlineStateTracker\", e);\n      }, il.prototype.clearOnlineStateTimer = function () {\n        null !== this.onlineStateTimer && (this.onlineStateTimer.cancel(), this.onlineStateTimer = null);\n      }, il);\n\n      function il(t, e) {\n        this.asyncQueue = t, this.onlineStateHandler = e, this.state = Yh.Unknown, this.watchStreamFailures = 0, this.onlineStateTimer = null, this.shouldWarnClientIsOffline = !0;\n      }\n\n      function ol(t) {\n        switch (t) {\n          case Wr.OK:\n            return Br(\"Treated status OK as error\");\n\n          case Wr.CANCELLED:\n          case Wr.UNKNOWN:\n          case Wr.DEADLINE_EXCEEDED:\n          case Wr.RESOURCE_EXHAUSTED:\n          case Wr.INTERNAL:\n          case Wr.UNAVAILABLE:\n          case Wr.UNAUTHENTICATED:\n            return !1;\n\n          case Wr.INVALID_ARGUMENT:\n          case Wr.NOT_FOUND:\n          case Wr.ALREADY_EXISTS:\n          case Wr.PERMISSION_DENIED:\n          case Wr.FAILED_PRECONDITION:\n          case Wr.ABORTED:\n          case Wr.OUT_OF_RANGE:\n          case Wr.UNIMPLEMENTED:\n          case Wr.DATA_LOSS:\n            return !0;\n\n          default:\n            return Br(\"Unknown status code: \" + t);\n        }\n      }\n\n      function al(t) {\n        if (void 0 === t) return qr(\"GRPC error has no .code\"), Wr.UNKNOWN;\n\n        switch (t) {\n          case el.OK:\n            return Wr.OK;\n\n          case el.CANCELLED:\n            return Wr.CANCELLED;\n\n          case el.UNKNOWN:\n            return Wr.UNKNOWN;\n\n          case el.DEADLINE_EXCEEDED:\n            return Wr.DEADLINE_EXCEEDED;\n\n          case el.RESOURCE_EXHAUSTED:\n            return Wr.RESOURCE_EXHAUSTED;\n\n          case el.INTERNAL:\n            return Wr.INTERNAL;\n\n          case el.UNAVAILABLE:\n            return Wr.UNAVAILABLE;\n\n          case el.UNAUTHENTICATED:\n            return Wr.UNAUTHENTICATED;\n\n          case el.INVALID_ARGUMENT:\n            return Wr.INVALID_ARGUMENT;\n\n          case el.NOT_FOUND:\n            return Wr.NOT_FOUND;\n\n          case el.ALREADY_EXISTS:\n            return Wr.ALREADY_EXISTS;\n\n          case el.PERMISSION_DENIED:\n            return Wr.PERMISSION_DENIED;\n\n          case el.FAILED_PRECONDITION:\n            return Wr.FAILED_PRECONDITION;\n\n          case el.ABORTED:\n            return Wr.ABORTED;\n\n          case el.OUT_OF_RANGE:\n            return Wr.OUT_OF_RANGE;\n\n          case el.UNIMPLEMENTED:\n            return Wr.UNIMPLEMENTED;\n\n          case el.DATA_LOSS:\n            return Wr.DATA_LOSS;\n\n          default:\n            return Br(\"Unknown status code: \" + t);\n        }\n      }\n\n      (nl = el = el || {})[nl.OK = 0] = \"OK\", nl[nl.CANCELLED = 1] = \"CANCELLED\", nl[nl.UNKNOWN = 2] = \"UNKNOWN\", nl[nl.INVALID_ARGUMENT = 3] = \"INVALID_ARGUMENT\", nl[nl.DEADLINE_EXCEEDED = 4] = \"DEADLINE_EXCEEDED\", nl[nl.NOT_FOUND = 5] = \"NOT_FOUND\", nl[nl.ALREADY_EXISTS = 6] = \"ALREADY_EXISTS\", nl[nl.PERMISSION_DENIED = 7] = \"PERMISSION_DENIED\", nl[nl.UNAUTHENTICATED = 16] = \"UNAUTHENTICATED\", nl[nl.RESOURCE_EXHAUSTED = 8] = \"RESOURCE_EXHAUSTED\", nl[nl.FAILED_PRECONDITION = 9] = \"FAILED_PRECONDITION\", nl[nl.ABORTED = 10] = \"ABORTED\", nl[nl.OUT_OF_RANGE = 11] = \"OUT_OF_RANGE\", nl[nl.UNIMPLEMENTED = 12] = \"UNIMPLEMENTED\", nl[nl.INTERNAL = 13] = \"INTERNAL\", nl[nl.UNAVAILABLE = 14] = \"UNAVAILABLE\", nl[nl.DATA_LOSS = 15] = \"DATA_LOSS\";\n      var sl,\n          ul,\n          cl,\n          hl,\n          ll = (fl.emptySet = function (t) {\n        return new fl(t.comparator);\n      }, fl.prototype.has = function (t) {\n        return null != this.keyedMap.get(t);\n      }, fl.prototype.get = function (t) {\n        return this.keyedMap.get(t);\n      }, fl.prototype.first = function () {\n        return this.sortedSet.minKey();\n      }, fl.prototype.last = function () {\n        return this.sortedSet.maxKey();\n      }, fl.prototype.isEmpty = function () {\n        return this.sortedSet.isEmpty();\n      }, fl.prototype.indexOf = function (t) {\n        var e = this.keyedMap.get(t);\n        return e ? this.sortedSet.indexOf(e) : -1;\n      }, Object.defineProperty(fl.prototype, \"size\", {\n        get: function () {\n          return this.sortedSet.size;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), fl.prototype.forEach = function (n) {\n        this.sortedSet.inorderTraversal(function (t, e) {\n          return n(t), !1;\n        });\n      }, fl.prototype.add = function (t) {\n        var e = this.delete(t.key);\n        return e.copy(e.keyedMap.insert(t.key, t), e.sortedSet.insert(t, null));\n      }, fl.prototype.delete = function (t) {\n        var e = this.get(t);\n        return e ? this.copy(this.keyedMap.remove(t), this.sortedSet.remove(e)) : this;\n      }, fl.prototype.isEqual = function (t) {\n        if (!(t instanceof fl)) return !1;\n        if (this.size !== t.size) return !1;\n\n        for (var e = this.sortedSet.getIterator(), n = t.sortedSet.getIterator(); e.hasNext();) {\n          var r = e.getNext().key,\n              i = n.getNext().key;\n          if (!r.isEqual(i)) return !1;\n        }\n\n        return !0;\n      }, fl.prototype.toString = function () {\n        var e = [];\n        return this.forEach(function (t) {\n          e.push(t.toString());\n        }), 0 === e.length ? \"DocumentSet ()\" : \"DocumentSet (\\n  \" + e.join(\"  \\n\") + \"\\n)\";\n      }, fl.prototype.copy = function (t, e) {\n        var n = new fl();\n        return n.comparator = this.comparator, n.keyedMap = t, n.sortedSet = e, n;\n      }, fl);\n\n      function fl(n) {\n        this.comparator = n ? function (t, e) {\n          return n(t, e) || Wi.comparator(t.key, e.key);\n        } : function (t, e) {\n          return Wi.comparator(t.key, e.key);\n        }, this.keyedMap = Ro(), this.sortedSet = new po(this.comparator);\n      }\n\n      (ul = sl = sl || {})[ul.Added = 0] = \"Added\", ul[ul.Removed = 1] = \"Removed\", ul[ul.Modified = 2] = \"Modified\", ul[ul.Metadata = 3] = \"Metadata\", (hl = cl = cl || {})[hl.Local = 0] = \"Local\", hl[hl.Synced = 1] = \"Synced\";\n      var pl = (dl.prototype.track = function (t) {\n        var e = t.doc.key,\n            n = this.changeMap.get(e);\n        n ? t.type !== sl.Added && n.type === sl.Metadata ? this.changeMap = this.changeMap.insert(e, t) : t.type === sl.Metadata && n.type !== sl.Removed ? this.changeMap = this.changeMap.insert(e, {\n          type: n.type,\n          doc: t.doc\n        }) : t.type === sl.Modified && n.type === sl.Modified ? this.changeMap = this.changeMap.insert(e, {\n          type: sl.Modified,\n          doc: t.doc\n        }) : t.type === sl.Modified && n.type === sl.Added ? this.changeMap = this.changeMap.insert(e, {\n          type: sl.Added,\n          doc: t.doc\n        }) : t.type === sl.Removed && n.type === sl.Added ? this.changeMap = this.changeMap.remove(e) : t.type === sl.Removed && n.type === sl.Modified ? this.changeMap = this.changeMap.insert(e, {\n          type: sl.Removed,\n          doc: n.doc\n        }) : t.type === sl.Added && n.type === sl.Removed ? this.changeMap = this.changeMap.insert(e, {\n          type: sl.Modified,\n          doc: t.doc\n        }) : Br(\"unsupported combination of changes: \" + JSON.stringify(t) + \" after \" + JSON.stringify(n)) : this.changeMap = this.changeMap.insert(e, t);\n      }, dl.prototype.getChanges = function () {\n        var n = [];\n        return this.changeMap.inorderTraversal(function (t, e) {\n          n.push(e);\n        }), n;\n      }, dl);\n\n      function dl() {\n        this.changeMap = new po(Wi.comparator);\n      }\n\n      var ml = (yl.fromInitialDocuments = function (t, e, n, r) {\n        var i = [];\n        return e.forEach(function (t) {\n          i.push({\n            type: sl.Added,\n            doc: t\n          });\n        }), new yl(t, e, ll.emptySet(e), i, n, r, !0, !1);\n      }, Object.defineProperty(yl.prototype, \"hasPendingWrites\", {\n        get: function () {\n          return !this.mutatedKeys.isEmpty();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), yl.prototype.isEqual = function (t) {\n        if (!(this.fromCache === t.fromCache && this.syncStateChanged === t.syncStateChanged && this.mutatedKeys.isEqual(t.mutatedKeys) && this.query.isEqual(t.query) && this.docs.isEqual(t.docs) && this.oldDocs.isEqual(t.oldDocs))) return !1;\n        var e = this.docChanges,\n            n = t.docChanges;\n        if (e.length !== n.length) return !1;\n\n        for (var r = 0; r < e.length; r++) if (e[r].type !== n[r].type || !e[r].doc.isEqual(n[r].doc)) return !1;\n\n        return !0;\n      }, yl);\n\n      function yl(t, e, n, r, i, o, a, s) {\n        this.query = t, this.docs = e, this.oldDocs = n, this.docChanges = r, this.mutatedKeys = i, this.fromCache = o, this.syncStateChanged = a, this.excludesMetadataChanges = s;\n      }\n\n      var gl = (vl.createSynthesizedRemoteEventForCurrentChange = function (t, e) {\n        var n,\n            r = ((n = {})[t] = bl.createSynthesizedTargetChangeForCurrentChange(t, e), n);\n        return new vl(lo.MIN, r, xo(), No(), Oo());\n      }, vl);\n\n      function vl(t, e, n, r, i) {\n        this.snapshotVersion = t, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = r, this.resolvedLimboDocuments = i;\n      }\n\n      var bl = (wl.createSynthesizedTargetChangeForCurrentChange = function (t, e) {\n        return new wl(jr(), e, Oo(), Oo(), Oo());\n      }, wl);\n\n      function wl(t, e, n, r, i) {\n        this.resumeToken = t, this.current = e, this.addedDocuments = n, this.modifiedDocuments = r, this.removedDocuments = i;\n      }\n\n      var Tl,\n          Sl,\n          El = function (t, e, n, r) {\n        this.updatedTargetIds = t, this.removedTargetIds = e, this.key = n, this.newDoc = r;\n      },\n          Il = function (t, e) {\n        this.targetId = t, this.existenceFilter = e;\n      };\n\n      (Sl = Tl = Tl || {})[Sl.NoChange = 0] = \"NoChange\", Sl[Sl.Added = 1] = \"Added\", Sl[Sl.Removed = 2] = \"Removed\", Sl[Sl.Current = 3] = \"Current\", Sl[Sl.Reset = 4] = \"Reset\";\n\n      var Cl = function (t, e, n, r) {\n        void 0 === n && (n = jr()), void 0 === r && (r = null), this.state = t, this.targetIds = e, this.resumeToken = n, this.cause = r;\n      },\n          Dl = (Object.defineProperty(Nl.prototype, \"current\", {\n        get: function () {\n          return this._current;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(Nl.prototype, \"resumeToken\", {\n        get: function () {\n          return this._resumeToken;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(Nl.prototype, \"isPending\", {\n        get: function () {\n          return 0 !== this.pendingResponses;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(Nl.prototype, \"hasPendingChanges\", {\n        get: function () {\n          return this._hasPendingChanges;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Nl.prototype.updateResumeToken = function (t) {\n        0 < t.length && (this._hasPendingChanges = !0, this._resumeToken = t);\n      }, Nl.prototype.toTargetChange = function () {\n        var n = Oo(),\n            r = Oo(),\n            i = Oo();\n        return this.documentChanges.forEach(function (t, e) {\n          switch (e) {\n            case sl.Added:\n              n = n.add(t);\n              break;\n\n            case sl.Modified:\n              r = r.add(t);\n              break;\n\n            case sl.Removed:\n              i = i.add(t);\n              break;\n\n            default:\n              Br(\"Encountered invalid change type: \" + e);\n          }\n        }), new bl(this._resumeToken, this._current, n, r, i);\n      }, Nl.prototype.clearPendingChanges = function () {\n        this._hasPendingChanges = !1, this.documentChanges = Ml();\n      }, Nl.prototype.addDocumentChange = function (t, e) {\n        this._hasPendingChanges = !0, this.documentChanges = this.documentChanges.insert(t, e);\n      }, Nl.prototype.removeDocumentChange = function (t) {\n        this._hasPendingChanges = !0, this.documentChanges = this.documentChanges.remove(t);\n      }, Nl.prototype.recordPendingTargetRequest = function () {\n        this.pendingResponses += 1;\n      }, Nl.prototype.recordTargetResponse = function () {\n        this.pendingResponses -= 1;\n      }, Nl.prototype.markCurrent = function () {\n        this._hasPendingChanges = !0, this._current = !0;\n      }, Nl);\n\n      function Nl() {\n        this.pendingResponses = 0, this.documentChanges = Ml(), this._resumeToken = jr(), this._current = !1, this._hasPendingChanges = !0;\n      }\n\n      var Al = (kl.prototype.handleDocumentChange = function (t) {\n        for (var e = 0, n = t.updatedTargetIds; e < n.length; e++) {\n          var r = n[e];\n          t.newDoc instanceof Vs ? this.addDocumentToTarget(r, t.newDoc) : t.newDoc instanceof Ks && this.removeDocumentFromTarget(r, t.key, t.newDoc);\n        }\n\n        for (var i = 0, o = t.removedTargetIds; i < o.length; i++) r = o[i], this.removeDocumentFromTarget(r, t.key, t.newDoc);\n      }, kl.prototype.handleTargetChange = function (n) {\n        var r = this;\n        this.forEachTarget(n, function (t) {\n          var e = r.ensureTargetState(t);\n\n          switch (n.state) {\n            case Tl.NoChange:\n              r.isActiveTarget(t) && e.updateResumeToken(n.resumeToken);\n              break;\n\n            case Tl.Added:\n              e.recordTargetResponse(), e.isPending || e.clearPendingChanges(), e.updateResumeToken(n.resumeToken);\n              break;\n\n            case Tl.Removed:\n              e.recordTargetResponse(), e.isPending || r.removeTarget(t), Ur(!n.cause, \"WatchChangeAggregator does not handle errored targets\");\n              break;\n\n            case Tl.Current:\n              r.isActiveTarget(t) && (e.markCurrent(), e.updateResumeToken(n.resumeToken));\n              break;\n\n            case Tl.Reset:\n              r.isActiveTarget(t) && (r.resetTarget(t), e.updateResumeToken(n.resumeToken));\n              break;\n\n            default:\n              Br(\"Unknown target watch change state: \" + n.state);\n          }\n        });\n      }, kl.prototype.forEachTarget = function (t, e) {\n        0 < t.targetIds.length ? t.targetIds.forEach(e) : Zr(this.targetStates, e);\n      }, kl.prototype.handleExistenceFilter = function (t) {\n        var e = t.targetId,\n            n = t.existenceFilter.count,\n            r = this.targetDataForActiveTarget(e);\n\n        if (r) {\n          var i = r.target;\n          if (i.isDocumentQuery()) {\n            if (0 === n) {\n              var o = new Wi(i.path);\n              this.removeDocumentFromTarget(e, o, new Ks(o, lo.forDeletedDoc()));\n            } else Ur(1 === n, \"Single document existence filter with count: \" + n);\n          } else this.getCurrentDocumentCountForTarget(e) !== n && (this.resetTarget(e), this.pendingTargetResets = this.pendingTargetResets.add(e));\n        }\n      }, kl.prototype.createRemoteEvent = function (i) {\n        var o = this,\n            a = {};\n        Zr(this.targetStates, function (t, e) {\n          var n = o.targetDataForActiveTarget(t);\n\n          if (n) {\n            if (e.current && n.target.isDocumentQuery()) {\n              var r = new Wi(n.target.path);\n              null !== o.pendingDocumentUpdates.get(r) || o.targetContainsDocument(t, r) || o.removeDocumentFromTarget(t, r, new Ks(r, i));\n            }\n\n            e.hasPendingChanges && (a[t] = e.toTargetChange(), e.clearPendingChanges());\n          }\n        });\n        var r = Oo();\n        this.pendingDocumentTargetMapping.forEach(function (t, e) {\n          var n = !0;\n          e.forEachWhile(function (t) {\n            var e = o.targetDataForActiveTarget(t);\n            return !e || e.purpose === qu.LimboResolution || (n = !1);\n          }), n && (r = r.add(t));\n        });\n        var t = new gl(i, a, this.pendingTargetResets, this.pendingDocumentUpdates, r);\n        return this.pendingDocumentUpdates = No(), this.pendingDocumentTargetMapping = Rl(), this.pendingTargetResets = new So(Si), t;\n      }, kl.prototype.addDocumentToTarget = function (t, e) {\n        if (this.isActiveTarget(t)) {\n          var n = this.targetContainsDocument(t, e.key) ? sl.Modified : sl.Added;\n          this.ensureTargetState(t).addDocumentChange(e.key, n), this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(e.key, e), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(e.key, this.ensureDocumentTargetMapping(e.key).add(t));\n        }\n      }, kl.prototype.removeDocumentFromTarget = function (t, e, n) {\n        if (this.isActiveTarget(t)) {\n          var r = this.ensureTargetState(t);\n          this.targetContainsDocument(t, e) ? r.addDocumentChange(e, sl.Removed) : r.removeDocumentChange(e), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(e, this.ensureDocumentTargetMapping(e).delete(t)), n && (this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(e, n));\n        }\n      }, kl.prototype.removeTarget = function (t) {\n        delete this.targetStates[t];\n      }, kl.prototype.getCurrentDocumentCountForTarget = function (t) {\n        var e = this.ensureTargetState(t).toTargetChange();\n        return this.metadataProvider.getRemoteKeysForTarget(t).size + e.addedDocuments.size - e.removedDocuments.size;\n      }, kl.prototype.recordPendingTargetRequest = function (t) {\n        this.ensureTargetState(t).recordPendingTargetRequest();\n      }, kl.prototype.ensureTargetState = function (t) {\n        return this.targetStates[t] || (this.targetStates[t] = new Dl()), this.targetStates[t];\n      }, kl.prototype.ensureDocumentTargetMapping = function (t) {\n        var e = this.pendingDocumentTargetMapping.get(t);\n        return e || (e = new So(Si), this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(t, e)), e;\n      }, kl.prototype.isActiveTarget = function (t) {\n        var e = null !== this.targetDataForActiveTarget(t);\n        return e || Fr(\"WatchChangeAggregator\", \"Detected inactive target\", t), e;\n      }, kl.prototype.targetDataForActiveTarget = function (t) {\n        var e = this.targetStates[t];\n        return e && e.isPending ? null : this.metadataProvider.getTargetDataForTarget(t);\n      }, kl.prototype.resetTarget = function (e) {\n        var n = this;\n        Ur(!this.targetStates[e].isPending, \"Should only reset active targets\"), this.targetStates[e] = new Dl(), this.metadataProvider.getRemoteKeysForTarget(e).forEach(function (t) {\n          n.removeDocumentFromTarget(e, t, null);\n        });\n      }, kl.prototype.targetContainsDocument = function (t, e) {\n        return this.metadataProvider.getRemoteKeysForTarget(t).has(e);\n      }, kl);\n\n      function kl(t) {\n        this.metadataProvider = t, this.targetStates = {}, this.pendingDocumentUpdates = No(), this.pendingDocumentTargetMapping = Rl(), this.pendingTargetResets = new So(Si);\n      }\n\n      function Rl() {\n        return new po(Wi.comparator);\n      }\n\n      function Ml() {\n        return new po(Wi.comparator);\n      }\n\n      var _l = \"RemoteStore\",\n          Ll = (Ol.prototype.start = function () {\n        return this.enableNetwork();\n      }, Ol.prototype.enableNetwork = function () {\n        return p(this, void 0, void 0, function () {\n          var e;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.networkEnabled = !0, this.canUseNetwork() ? (e = this.writeStream, [4, this.localStore.getLastStreamToken()]) : [3, 3];\n\n              case 1:\n                return e.lastStreamToken = t.sent(), this.shouldStartWatchStream() ? this.startWatchStream() : this.onlineStateTracker.set(Yh.Unknown), [4, this.fillWritePipeline()];\n\n              case 2:\n                t.sent(), t.label = 3;\n\n              case 3:\n                return [2];\n            }\n          });\n        });\n      }, Ol.prototype.disableNetwork = function () {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.networkEnabled = !1, [4, this.disableNetworkInternal()];\n\n              case 1:\n                return t.sent(), this.onlineStateTracker.set(Yh.Offline), [2];\n            }\n          });\n        });\n      }, Ol.prototype.disableNetworkInternal = function () {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return [4, this.writeStream.stop()];\n\n              case 1:\n                return t.sent(), [4, this.watchStream.stop()];\n\n              case 2:\n                return t.sent(), 0 < this.writePipeline.length && (Fr(_l, \"Stopping write stream with \" + this.writePipeline.length + \" pending writes\"), this.writePipeline = []), this.cleanUpWatchStreamState(), [2];\n            }\n          });\n        });\n      }, Ol.prototype.shutdown = function () {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return Fr(_l, \"RemoteStore shutting down.\"), this.networkEnabled = !1, [4, this.disableNetworkInternal()];\n\n              case 1:\n                return t.sent(), this.connectivityMonitor.shutdown(), this.onlineStateTracker.set(Yh.Unknown), [2];\n            }\n          });\n        });\n      }, Ol.prototype.listen = function (t) {\n        Jr(this.listenTargets, t.targetId) || (this.listenTargets[t.targetId] = t, this.shouldStartWatchStream() ? this.startWatchStream() : this.watchStream.isOpen() && this.sendWatchRequest(t));\n      }, Ol.prototype.unlisten = function (t) {\n        Ur(Jr(this.listenTargets, t), \"unlisten called on target no currently watched: \" + t), delete this.listenTargets[t], this.watchStream.isOpen() && this.sendUnwatchRequest(t), ti(this.listenTargets) && (this.watchStream.isOpen() ? this.watchStream.markIdle() : this.canUseNetwork() && this.onlineStateTracker.set(Yh.Unknown));\n      }, Ol.prototype.getTargetDataForTarget = function (t) {\n        return this.listenTargets[t] || null;\n      }, Ol.prototype.getRemoteKeysForTarget = function (t) {\n        return this.syncEngine.getRemoteKeysForTarget(t);\n      }, Ol.prototype.sendWatchRequest = function (t) {\n        this.watchChangeAggregator.recordPendingTargetRequest(t.targetId), this.watchStream.watch(t);\n      }, Ol.prototype.sendUnwatchRequest = function (t) {\n        this.watchChangeAggregator.recordPendingTargetRequest(t), this.watchStream.unwatch(t);\n      }, Ol.prototype.startWatchStream = function () {\n        Ur(this.shouldStartWatchStream(), \"startWatchStream() called when shouldStartWatchStream() is false.\"), this.watchChangeAggregator = new Al(this), this.watchStream.start(), this.onlineStateTracker.handleWatchStreamStart();\n      }, Ol.prototype.shouldStartWatchStream = function () {\n        return this.canUseNetwork() && !this.watchStream.isStarted() && !ti(this.listenTargets);\n      }, Ol.prototype.canUseNetwork = function () {\n        return this.isPrimary && this.networkEnabled;\n      }, Ol.prototype.cleanUpWatchStreamState = function () {\n        this.watchChangeAggregator = null;\n      }, Ol.prototype.onWatchStreamOpen = function () {\n        return p(this, void 0, void 0, function () {\n          var n = this;\n          return m(this, function (t) {\n            return Zr(this.listenTargets, function (t, e) {\n              n.sendWatchRequest(e);\n            }), [2];\n          });\n        });\n      }, Ol.prototype.onWatchStreamClose = function (e) {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            return void 0 === e && Ur(!this.shouldStartWatchStream(), \"Watch stream was stopped gracefully while still needed.\"), this.cleanUpWatchStreamState(), this.shouldStartWatchStream() ? (this.onlineStateTracker.handleWatchStreamFailure(e), this.startWatchStream()) : this.onlineStateTracker.set(Yh.Unknown), [2];\n          });\n        });\n      }, Ol.prototype.onWatchStreamChange = function (n, r) {\n        return p(this, void 0, void 0, function () {\n          var e;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.onlineStateTracker.set(Yh.Online), n instanceof Cl && n.state === Tl.Removed && n.cause ? [2, this.handleTargetError(n)] : (n instanceof El ? this.watchChangeAggregator.handleDocumentChange(n) : n instanceof Il ? this.watchChangeAggregator.handleExistenceFilter(n) : (Ur(n instanceof Cl, \"Expected watchChange to be an instance of WatchTargetChange\"), this.watchChangeAggregator.handleTargetChange(n)), r.isEqual(lo.MIN) ? [3, 3] : [4, this.localStore.getLastRemoteSnapshotVersion()]);\n\n              case 1:\n                return e = t.sent(), 0 <= r.compareTo(e) ? [4, this.raiseWatchSnapshot(r)] : [3, 3];\n\n              case 2:\n                t.sent(), t.label = 3;\n\n              case 3:\n                return [2];\n            }\n          });\n        });\n      }, Ol.prototype.raiseWatchSnapshot = function (r) {\n        var i = this;\n        Ur(!r.isEqual(lo.MIN), \"Can't raise event for unknown SnapshotVersion\");\n        var t = this.watchChangeAggregator.createRemoteEvent(r);\n        return Zr(t.targetChanges, function (t, e) {\n          if (0 < e.resumeToken.length) {\n            var n = i.listenTargets[t];\n            n && (i.listenTargets[t] = n.withResumeToken(e.resumeToken, r));\n          }\n        }), t.targetMismatches.forEach(function (t) {\n          var e = i.listenTargets[t];\n\n          if (e) {\n            i.listenTargets[t] = e.withResumeToken(jr(), e.snapshotVersion), i.sendUnwatchRequest(t);\n            var n = new ju(e.target, t, qu.ExistenceFilterMismatch, e.sequenceNumber);\n            i.sendWatchRequest(n);\n          }\n        }), this.syncEngine.applyRemoteEvent(t);\n      }, Ol.prototype.handleTargetError = function (t) {\n        var n = this;\n        Ur(!!t.cause, \"Handling target error without a cause\");\n        var r = t.cause,\n            i = Promise.resolve();\n        return t.targetIds.forEach(function (e) {\n          i = i.then(function () {\n            return p(n, void 0, void 0, function () {\n              return m(this, function (t) {\n                return Jr(this.listenTargets, e) ? (delete this.listenTargets[e], this.watchChangeAggregator.removeTarget(e), [2, this.syncEngine.rejectListen(e, r)]) : [2];\n              });\n            });\n          });\n        }), i;\n      }, Ol.prototype.fillWritePipeline = function () {\n        return p(this, void 0, void 0, function () {\n          var e, n;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.canAddToWritePipeline() ? (e = 0 < this.writePipeline.length ? this.writePipeline[this.writePipeline.length - 1].batchId : -1, [4, this.localStore.nextMutationBatch(e)]) : [3, 4];\n\n              case 1:\n                return null !== (n = t.sent()) ? [3, 2] : (0 === this.writePipeline.length && this.writeStream.markIdle(), [3, 4]);\n\n              case 2:\n                return this.addToWritePipeline(n), [4, this.fillWritePipeline()];\n\n              case 3:\n                t.sent(), t.label = 4;\n\n              case 4:\n                return this.shouldStartWriteStream() && this.startWriteStream(), [2];\n            }\n          });\n        });\n      }, Ol.prototype.canAddToWritePipeline = function () {\n        return this.canUseNetwork() && this.writePipeline.length < 10;\n      }, Ol.prototype.outstandingWrites = function () {\n        return this.writePipeline.length;\n      }, Ol.prototype.addToWritePipeline = function (t) {\n        Ur(this.canAddToWritePipeline(), \"addToWritePipeline called when pipeline is full\"), this.writePipeline.push(t), this.writeStream.isOpen() && this.writeStream.handshakeComplete && this.writeStream.writeMutations(t.mutations);\n      }, Ol.prototype.shouldStartWriteStream = function () {\n        return this.canUseNetwork() && !this.writeStream.isStarted() && 0 < this.writePipeline.length;\n      }, Ol.prototype.startWriteStream = function () {\n        Ur(this.shouldStartWriteStream(), \"startWriteStream() called when shouldStartWriteStream() is false.\"), this.writeStream.start();\n      }, Ol.prototype.onWriteStreamOpen = function () {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            return this.writeStream.writeHandshake(), [2];\n          });\n        });\n      }, Ol.prototype.onWriteHandshakeComplete = function () {\n        var r = this;\n        return this.localStore.setLastStreamToken(this.writeStream.lastStreamToken).then(function () {\n          for (var t = 0, e = r.writePipeline; t < e.length; t++) {\n            var n = e[t];\n            r.writeStream.writeMutations(n.mutations);\n          }\n        }).catch(dc);\n      }, Ol.prototype.onMutationResult = function (t, e) {\n        var n = this;\n        Ur(0 < this.writePipeline.length, \"Got result for empty write pipeline\");\n        var r = this.writePipeline.shift(),\n            i = Vo.from(r, t, e, this.writeStream.lastStreamToken);\n        return this.syncEngine.applySuccessfulWrite(i).then(function () {\n          return n.fillWritePipeline();\n        });\n      }, Ol.prototype.onWriteStreamClose = function (n) {\n        return p(this, void 0, void 0, function () {\n          var e = this;\n          return m(this, function (t) {\n            return void 0 === n && Ur(!this.shouldStartWriteStream(), \"Write stream was stopped gracefully while still needed.\"), n && 0 < this.writePipeline.length ? [2, (this.writeStream.handshakeComplete ? this.handleWriteError(n) : this.handleHandshakeError(n)).then(function () {\n              e.shouldStartWriteStream() && e.startWriteStream();\n            })] : [2];\n          });\n        });\n      }, Ol.prototype.handleHandshakeError = function (e) {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            return ol(e.code) ? (Fr(_l, \"RemoteStore error before completed handshake; resetting stream token: \", this.writeStream.lastStreamToken), this.writeStream.lastStreamToken = jr(), [2, this.localStore.setLastStreamToken(jr()).catch(dc)]) : [2];\n          });\n        });\n      }, Ol.prototype.handleWriteError = function (r) {\n        return p(this, void 0, void 0, function () {\n          var e,\n              n = this;\n          return m(this, function (t) {\n            return function (t) {\n              return ol(t) && t !== Wr.ABORTED;\n            }(r.code) ? (e = this.writePipeline.shift(), this.writeStream.inhibitBackoff(), [2, this.syncEngine.rejectFailedWrite(e.batchId, r).then(function () {\n              return n.fillWritePipeline();\n            })]) : [2];\n          });\n        });\n      }, Ol.prototype.createTransaction = function () {\n        return new $h(this.datastore);\n      }, Ol.prototype.restartNetwork = function () {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.networkEnabled = !1, [4, this.disableNetworkInternal()];\n\n              case 1:\n                return t.sent(), this.onlineStateTracker.set(Yh.Unknown), [4, this.enableNetwork()];\n\n              case 2:\n                return t.sent(), [2];\n            }\n          });\n        });\n      }, Ol.prototype.handleCredentialChange = function () {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.canUseNetwork() ? (Fr(_l, \"RemoteStore restarting streams for new credential\"), [4, this.restartNetwork()]) : [3, 2];\n\n              case 1:\n                t.sent(), t.label = 2;\n\n              case 2:\n                return [2];\n            }\n          });\n        });\n      }, Ol.prototype.applyPrimaryState = function (e) {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return (this.isPrimary = e) && this.networkEnabled ? [4, this.enableNetwork()] : [3, 2];\n\n              case 1:\n                return t.sent(), [3, 4];\n\n              case 2:\n                return e ? [3, 4] : [4, this.disableNetworkInternal()];\n\n              case 3:\n                t.sent(), this.onlineStateTracker.set(Yh.Unknown), t.label = 4;\n\n              case 4:\n                return [2];\n            }\n          });\n        });\n      }, Ol);\n\n      function Ol(t, e, n, r, i) {\n        var o = this;\n        this.localStore = t, this.datastore = e, this.writePipeline = [], this.listenTargets = {}, this.watchChangeAggregator = null, this.networkEnabled = !1, this.isPrimary = !1, this.connectivityMonitor = i, this.connectivityMonitor.addCallback(function (t) {\n          n.enqueueAndForget(function () {\n            return p(o, void 0, void 0, function () {\n              return m(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    return this.canUseNetwork() ? (Fr(_l, \"Restarting streams for network reachability change.\"), [4, this.restartNetwork()]) : [3, 2];\n\n                  case 1:\n                    t.sent(), t.label = 2;\n\n                  case 2:\n                    return [2];\n                }\n              });\n            });\n          });\n        }), this.onlineStateTracker = new rl(n, r), this.watchStream = this.datastore.newPersistentWatchStream({\n          onOpen: this.onWatchStreamOpen.bind(this),\n          onClose: this.onWatchStreamClose.bind(this),\n          onWatchChange: this.onWatchStreamChange.bind(this)\n        }), this.writeStream = this.datastore.newPersistentWriteStream({\n          onOpen: this.onWriteStreamOpen.bind(this),\n          onClose: this.onWriteStreamClose.bind(this),\n          onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n          onMutationResult: this.onMutationResult.bind(this)\n        });\n      }\n\n      var Pl = (Object.defineProperty(xl.prototype, \"latitude\", {\n        get: function () {\n          return this._lat;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(xl.prototype, \"longitude\", {\n        get: function () {\n          return this._long;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), xl.prototype.isEqual = function (t) {\n        return this._lat === t._lat && this._long === t._long;\n      }, xl.prototype._compareTo = function (t) {\n        return Si(this._lat, t._lat) || Si(this._long, t._long);\n      }, xl);\n\n      function xl(t, e) {\n        if (ni(\"GeoPoint\", arguments, 2), oi(\"GeoPoint\", \"number\", 1, t), oi(\"GeoPoint\", \"number\", 2, e), !isFinite(t) || t < -90 || 90 < t) throw new zr(Wr.INVALID_ARGUMENT, \"Latitude must be a number between -90 and 90, but was: \" + t);\n        if (!isFinite(e) || e < -180 || 180 < e) throw new zr(Wr.INVALID_ARGUMENT, \"Longitude must be a number between -180 and 180, but was: \" + e);\n        this._lat = t, this._long = e;\n      }\n\n      var Fl = (ql.prototype.applyToLocalView = function (t, e) {\n        return new bs(e, t);\n      }, ql.prototype.applyToRemoteDocument = function (t, e) {\n        return e;\n      }, ql.prototype.computeBaseValue = function (t) {\n        return null;\n      }, ql.prototype.isEqual = function (t) {\n        return t instanceof ql;\n      }, ql.instance = new ql(), ql);\n\n      function ql() {}\n\n      var Vl = (Bl.prototype.applyToLocalView = function (t, e) {\n        return this.apply(t);\n      }, Bl.prototype.applyToRemoteDocument = function (t, e) {\n        return this.apply(t);\n      }, Bl.prototype.apply = function (t) {\n        for (var n = Gl(t), e = function (e) {\n          n.find(function (t) {\n            return t.isEqual(e);\n          }) || n.push(e);\n        }, r = 0, i = this.elements; r < i.length; r++) e(i[r]);\n\n        return new Os(n);\n      }, Bl.prototype.computeBaseValue = function (t) {\n        return null;\n      }, Bl.prototype.isEqual = function (t) {\n        return t instanceof Bl && Ei(t.elements, this.elements);\n      }, Bl);\n\n      function Bl(t) {\n        this.elements = t;\n      }\n\n      var Ul = (Kl.prototype.applyToLocalView = function (t, e) {\n        return this.apply(t);\n      }, Kl.prototype.applyToRemoteDocument = function (t, e) {\n        return this.apply(t);\n      }, Kl.prototype.apply = function (t) {\n        for (var n = Gl(t), e = function (e) {\n          n = n.filter(function (t) {\n            return !t.isEqual(e);\n          });\n        }, r = 0, i = this.elements; r < i.length; r++) e(i[r]);\n\n        return new Os(n);\n      }, Kl.prototype.computeBaseValue = function (t) {\n        return null;\n      }, Kl.prototype.isEqual = function (t) {\n        return t instanceof Kl && Ei(t.elements, this.elements);\n      }, Kl);\n\n      function Kl(t) {\n        this.elements = t;\n      }\n\n      var Ql = (jl.prototype.applyToLocalView = function (t, e) {\n        var n = this.computeBaseValue(t);\n\n        if (n instanceof ss && this.operand instanceof ss) {\n          var r = n.internalValue + this.operand.internalValue;\n          return new ss(r);\n        }\n\n        return r = n.internalValue + this.operand.internalValue, new hs(r);\n      }, jl.prototype.applyToRemoteDocument = function (t, e) {\n        return Ur(null !== e, \"Didn't receive transformResult for NUMERIC_ADD transform\"), e;\n      }, jl.prototype.computeBaseValue = function (t) {\n        return t instanceof rs ? t : new ss(0);\n      }, jl.prototype.isEqual = function (t) {\n        return t instanceof jl && this.operand.isEqual(t.operand);\n      }, jl);\n\n      function jl(t) {\n        this.operand = t;\n      }\n\n      function Gl(t) {\n        return t instanceof Os ? t.internalValue.slice() : [];\n      }\n\n      var Wl = (zl.prototype.isEqual = function (t) {\n        return t && t.count === this.count;\n      }, zl);\n\n      function zl(t) {\n        this.count = t;\n      }\n\n      var Hl,\n          Yl,\n          Jl = ((Hl = {})[$c.ASCENDING.name] = \"ASCENDING\", Hl[$c.DESCENDING.name] = \"DESCENDING\", Hl),\n          Xl = ((Yl = {})[Lc.LESS_THAN.name] = \"LESS_THAN\", Yl[Lc.LESS_THAN_OR_EQUAL.name] = \"LESS_THAN_OR_EQUAL\", Yl[Lc.GREATER_THAN.name] = \"GREATER_THAN\", Yl[Lc.GREATER_THAN_OR_EQUAL.name] = \"GREATER_THAN_OR_EQUAL\", Yl[Lc.EQUAL.name] = \"EQUAL\", Yl[Lc.ARRAY_CONTAINS.name] = \"ARRAY_CONTAINS\", Yl[Lc.IN.name] = \"IN\", Yl[Lc.ARRAY_CONTAINS_ANY.name] = \"ARRAY_CONTAINS_ANY\", Yl),\n          Zl = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\n\n      function $l(t, e) {\n        Ur(!Ic(t), e + \" is missing\");\n      }\n\n      function tf(t) {\n        return \"number\" == typeof t ? t : \"string\" == typeof t ? Number(t) : Br(\"can't parse \" + t);\n      }\n\n      var ef = (nf.prototype.emptyByteString = function () {\n        return this.options.useProto3Json ? \"\" : new Uint8Array(0);\n      }, nf.prototype.unsafeCastProtoByteString = function (t) {\n        return t;\n      }, nf.prototype.fromRpcStatus = function (t) {\n        var e = void 0 === t.code ? Wr.UNKNOWN : al(t.code);\n        return new zr(e, t.message || \"\");\n      }, nf.prototype.toInt32Value = function (t) {\n        return this.options.useProto3Json || Ic(t) ? t : {\n          value: t\n        };\n      }, nf.prototype.fromInt32Value = function (t) {\n        var e;\n        return Ic(e = \"object\" == typeof t ? t.value : t) ? null : e;\n      }, nf.prototype.toTimestamp = function (t) {\n        return this.options.useProto3Json ? new Date(1e3 * t.seconds).toISOString().replace(/\\.\\d*/, \"\").replace(\"Z\", \"\") + \".\" + (\"000000000\" + t.nanoseconds).slice(-9) + \"Z\" : {\n          seconds: \"\" + t.seconds,\n          nanos: t.nanoseconds\n        };\n      }, nf.prototype.fromTimestamp = function (t) {\n        if (\"string\" == typeof t) return this.fromIso8601String(t);\n        Ur(!!t, \"Cannot deserialize null or undefined timestamp.\");\n        var e = tf(t.seconds || \"0\"),\n            n = t.nanos || 0;\n        return new co(e, n);\n      }, nf.prototype.fromIso8601String = function (t) {\n        var e = 0,\n            n = Zl.exec(t);\n\n        if (Ur(!!n, \"invalid timestamp: \" + t), n[1]) {\n          var r = n[1];\n          r = (r + \"000000000\").substr(0, 9), e = Number(r);\n        }\n\n        var i = new Date(t),\n            o = Math.floor(i.getTime() / 1e3);\n        return new co(o, e);\n      }, nf.prototype.toBytes = function (t) {\n        return this.options.useProto3Json ? t.toBase64() : this.unsafeCastProtoByteString(t.toUint8Array());\n      }, nf.prototype.fromBlob = function (t) {\n        return \"string\" == typeof t ? (Ur(this.options.useProto3Json, \"Expected bytes to be passed in as Uint8Array, but got a string instead.\"), Ni.fromBase64String(t)) : (Ur(!this.options.useProto3Json, \"Expected bytes to be passed in as Uint8Array, but got a string instead.\"), Ni.fromUint8Array(t));\n      }, nf.prototype.toVersion = function (t) {\n        return this.toTimestamp(t.toTimestamp());\n      }, nf.prototype.fromVersion = function (t) {\n        return Ur(!!t, \"Trying to deserialize version that isn't set\"), lo.fromTimestamp(this.fromTimestamp(t));\n      }, nf.prototype.toResourceName = function (t, e) {\n        return this.fullyQualifiedPrefixPath(t).child(\"documents\").child(e).canonicalString();\n      }, nf.prototype.fromResourceName = function (t) {\n        var e = Bi.fromString(t);\n        return Ur(this.isValidResourceName(e), \"Tried to deserialize invalid key \" + e.toString()), e;\n      }, nf.prototype.toName = function (t) {\n        return this.toResourceName(this.databaseId, t.path);\n      }, nf.prototype.fromName = function (t) {\n        var e = this.fromResourceName(t);\n        return Ur(e.get(1) === this.databaseId.projectId, \"Tried to deserialize key from different project: \" + e.get(1) + \" vs \" + this.databaseId.projectId), Ur(!e.get(3) && !this.databaseId.database || e.get(3) === this.databaseId.database, \"Tried to deserialize key from different database: \" + e.get(3) + \" vs \" + this.databaseId.database), new Wi(this.extractLocalPathFromResourceName(e));\n      }, nf.prototype.toQueryPath = function (t) {\n        return this.toResourceName(this.databaseId, t);\n      }, nf.prototype.fromQueryPath = function (t) {\n        var e = this.fromResourceName(t);\n        return 4 === e.length ? Bi.EMPTY_PATH : this.extractLocalPathFromResourceName(e);\n      }, Object.defineProperty(nf.prototype, \"encodedDatabaseId\", {\n        get: function () {\n          return new Bi([\"projects\", this.databaseId.projectId, \"databases\", this.databaseId.database]).canonicalString();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), nf.prototype.fullyQualifiedPrefixPath = function (t) {\n        return new Bi([\"projects\", t.projectId, \"databases\", t.database]);\n      }, nf.prototype.extractLocalPathFromResourceName = function (t) {\n        return Ur(4 < t.length && \"documents\" === t.get(4), \"tried to deserialize invalid key \" + t.toString()), t.popFirst(5);\n      }, nf.prototype.isValidResourceName = function (t) {\n        return 4 <= t.length && \"projects\" === t.get(0) && \"databases\" === t.get(2);\n      }, nf.prototype.toValue = function (t) {\n        if (t instanceof Xa) return {\n          nullValue: \"NULL_VALUE\"\n        };\n        if (t instanceof ts) return {\n          booleanValue: t.value()\n        };\n        if (t instanceof ss) return {\n          integerValue: \"\" + t.value()\n        };\n\n        if (t instanceof hs) {\n          var e = t.value();\n\n          if (this.options.useProto3Json) {\n            if (isNaN(e)) return {\n              doubleValue: \"NaN\"\n            };\n            if (e === 1 / 0) return {\n              doubleValue: \"Infinity\"\n            };\n            if (e === -1 / 0) return {\n              doubleValue: \"-Infinity\"\n            };\n          }\n\n          return {\n            doubleValue: t.value()\n          };\n        }\n\n        return t instanceof ps ? {\n          stringValue: t.value()\n        } : t instanceof Ms ? {\n          mapValue: this.toMapValue(t)\n        } : t instanceof Os ? {\n          arrayValue: this.toArrayValue(t)\n        } : t instanceof ys ? {\n          timestampValue: this.toTimestamp(t.internalValue)\n        } : t instanceof As ? {\n          geoPointValue: {\n            latitude: t.value().latitude,\n            longitude: t.value().longitude\n          }\n        } : t instanceof Ss ? {\n          bytesValue: this.toBytes(t.value())\n        } : t instanceof Cs ? {\n          referenceValue: this.toResourceName(t.databaseId, t.key.path)\n        } : Br(\"Unknown FieldValue \" + JSON.stringify(t));\n      }, nf.prototype.fromValue = function (t) {\n        var e = this;\n        if (\"nullValue\" in t) return Xa.INSTANCE;\n        if (\"booleanValue\" in t) return ts.of(t.booleanValue);\n        if (\"integerValue\" in t) return new ss(tf(t.integerValue));\n\n        if (\"doubleValue\" in t) {\n          if (this.options.useProto3Json) {\n            if (\"NaN\" === t.doubleValue) return hs.NAN;\n            if (\"Infinity\" === t.doubleValue) return hs.POSITIVE_INFINITY;\n            if (\"-Infinity\" === t.doubleValue) return hs.NEGATIVE_INFINITY;\n          }\n\n          return new hs(t.doubleValue);\n        }\n\n        if (\"stringValue\" in t) return new ps(t.stringValue);\n        if (\"mapValue\" in t) return this.fromFields(t.mapValue.fields || {});\n\n        if (\"arrayValue\" in t) {\n          $l(t.arrayValue, \"arrayValue\");\n          var n = t.arrayValue.values || [];\n          return new Os(n.map(function (t) {\n            return e.fromValue(t);\n          }));\n        }\n\n        if (\"timestampValue\" in t) return $l(t.timestampValue, \"timestampValue\"), new ys(this.fromTimestamp(t.timestampValue));\n\n        if (\"geoPointValue\" in t) {\n          $l(t.geoPointValue, \"geoPointValue\");\n          var r = t.geoPointValue.latitude || 0,\n              i = t.geoPointValue.longitude || 0;\n          return new As(new Pl(r, i));\n        }\n\n        if (\"bytesValue\" in t) {\n          $l(t.bytesValue, \"bytesValue\");\n          var o = this.fromBlob(t.bytesValue);\n          return new Ss(o);\n        }\n\n        if (\"referenceValue\" in t) {\n          $l(t.referenceValue, \"referenceValue\");\n          var a = this.fromResourceName(t.referenceValue),\n              s = new _i(a.get(1), a.get(3)),\n              u = new Wi(this.extractLocalPathFromResourceName(a));\n          return new Cs(s, u);\n        }\n\n        return Br(\"Unknown Value proto \" + JSON.stringify(t));\n      }, nf.prototype.toMutationDocument = function (t, e) {\n        return {\n          name: this.toName(t),\n          fields: this.toFields(e)\n        };\n      }, nf.prototype.toDocument = function (t) {\n        return Ur(!t.hasLocalMutations, \"Can't serialize documents with mutations.\"), {\n          name: this.toName(t.key),\n          fields: this.toFields(t.data()),\n          updateTime: this.toTimestamp(t.version.toTimestamp())\n        };\n      }, nf.prototype.fromDocument = function (t, e) {\n        var n = this,\n            r = this.fromName(t.name),\n            i = this.fromVersion(t.updateTime);\n        return new Vs(r, i, {\n          hasCommittedMutations: !!e\n        }, void 0, t, function (t) {\n          return n.fromValue(t);\n        });\n      }, nf.prototype.toFields = function (t) {\n        var n = this,\n            r = {};\n        return t.forEach(function (t, e) {\n          r[t] = n.toValue(e);\n        }), r;\n      }, nf.prototype.fromFields = function (t) {\n        var n = this,\n            e = t,\n            r = Ms.EMPTY;\n        return $r(e, function (t, e) {\n          r = r.set(new ji([t]), n.fromValue(e));\n        }), r;\n      }, nf.prototype.toMapValue = function (t) {\n        return {\n          fields: this.toFields(t)\n        };\n      }, nf.prototype.toArrayValue = function (t) {\n        var e = this,\n            n = [];\n        return t.forEach(function (t) {\n          n.push(e.toValue(t));\n        }), {\n          values: n\n        };\n      }, nf.prototype.fromFound = function (t) {\n        var e = this;\n        Ur(!!t.found, \"Tried to deserialize a found document from a missing document.\"), $l(t.found.name, \"doc.found.name\"), $l(t.found.updateTime, \"doc.found.updateTime\");\n        var n = this.fromName(t.found.name),\n            r = this.fromVersion(t.found.updateTime);\n        return new Vs(n, r, {}, void 0, t.found, function (t) {\n          return e.fromValue(t);\n        });\n      }, nf.prototype.fromMissing = function (t) {\n        Ur(!!t.missing, \"Tried to deserialize a missing document from a found document.\"), Ur(!!t.readTime, \"Tried to deserialize a missing document without a read time.\");\n        var e = this.fromName(t.missing),\n            n = this.fromVersion(t.readTime);\n        return new Ks(e, n);\n      }, nf.prototype.fromMaybeDocument = function (t) {\n        return \"found\" in t ? this.fromFound(t) : \"missing\" in t ? this.fromMissing(t) : Br(\"invalid batch get response: \" + JSON.stringify(t));\n      }, nf.prototype.toWatchTargetChangeState = function (t) {\n        switch (t) {\n          case Tl.Added:\n            return \"ADD\";\n\n          case Tl.Current:\n            return \"CURRENT\";\n\n          case Tl.NoChange:\n            return \"NO_CHANGE\";\n\n          case Tl.Removed:\n            return \"REMOVE\";\n\n          case Tl.Reset:\n            return \"RESET\";\n\n          default:\n            return Br(\"Unknown WatchTargetChangeState: \" + t);\n        }\n      }, nf.prototype.toTestWatchChange = function (t) {\n        if (t instanceof Il) return {\n          filter: {\n            count: t.existenceFilter.count,\n            targetId: t.targetId\n          }\n        };\n\n        if (t instanceof El) {\n          if (t.newDoc instanceof Vs) {\n            var e = t.newDoc;\n            return {\n              documentChange: {\n                document: {\n                  name: this.toName(e.key),\n                  fields: this.toFields(e.data()),\n                  updateTime: this.toVersion(e.version)\n                },\n                targetIds: t.updatedTargetIds,\n                removedTargetIds: t.removedTargetIds\n              }\n            };\n          }\n\n          if (t.newDoc instanceof Ks) return e = t.newDoc, {\n            documentDelete: {\n              document: this.toName(e.key),\n              readTime: this.toVersion(e.version),\n              removedTargetIds: t.removedTargetIds\n            }\n          };\n          if (null === t.newDoc) return {\n            documentRemove: {\n              document: this.toName(t.key),\n              removedTargetIds: t.removedTargetIds\n            }\n          };\n        }\n\n        if (t instanceof Cl) {\n          var n = void 0;\n          return t.cause && (n = {\n            code: function (t) {\n              if (void 0 === t) return el.OK;\n\n              switch (t) {\n                case Wr.OK:\n                  return el.OK;\n\n                case Wr.CANCELLED:\n                  return el.CANCELLED;\n\n                case Wr.UNKNOWN:\n                  return el.UNKNOWN;\n\n                case Wr.DEADLINE_EXCEEDED:\n                  return el.DEADLINE_EXCEEDED;\n\n                case Wr.RESOURCE_EXHAUSTED:\n                  return el.RESOURCE_EXHAUSTED;\n\n                case Wr.INTERNAL:\n                  return el.INTERNAL;\n\n                case Wr.UNAVAILABLE:\n                  return el.UNAVAILABLE;\n\n                case Wr.UNAUTHENTICATED:\n                  return el.UNAUTHENTICATED;\n\n                case Wr.INVALID_ARGUMENT:\n                  return el.INVALID_ARGUMENT;\n\n                case Wr.NOT_FOUND:\n                  return el.NOT_FOUND;\n\n                case Wr.ALREADY_EXISTS:\n                  return el.ALREADY_EXISTS;\n\n                case Wr.PERMISSION_DENIED:\n                  return el.PERMISSION_DENIED;\n\n                case Wr.FAILED_PRECONDITION:\n                  return el.FAILED_PRECONDITION;\n\n                case Wr.ABORTED:\n                  return el.ABORTED;\n\n                case Wr.OUT_OF_RANGE:\n                  return el.OUT_OF_RANGE;\n\n                case Wr.UNIMPLEMENTED:\n                  return el.UNIMPLEMENTED;\n\n                case Wr.DATA_LOSS:\n                  return el.DATA_LOSS;\n\n                default:\n                  return Br(\"Unknown status code: \" + t);\n              }\n            }(t.cause.code),\n            message: t.cause.message\n          }), {\n            targetChange: {\n              targetChangeType: this.toWatchTargetChangeState(t.state),\n              targetIds: t.targetIds,\n              resumeToken: this.unsafeCastProtoByteString(t.resumeToken),\n              cause: n\n            }\n          };\n        }\n\n        return Br(\"Unrecognized watch change: \" + JSON.stringify(t));\n      }, nf.prototype.fromWatchChange = function (t) {\n        var e,\n            n = this;\n\n        if (\"targetChange\" in t) {\n          $l(t.targetChange, \"targetChange\");\n          var r = this.fromWatchTargetChangeState(t.targetChange.targetChangeType || \"NO_CHANGE\"),\n              i = t.targetChange.targetIds || [],\n              o = t.targetChange.resumeToken || this.emptyByteString(),\n              a = t.targetChange.cause,\n              s = a && this.fromRpcStatus(a);\n          e = new Cl(r, i, o, s || null);\n        } else if (\"documentChange\" in t) {\n          $l(t.documentChange, \"documentChange\");\n          var u = t.documentChange;\n          $l(u.document, \"documentChange.name\"), $l(u.document.name, \"documentChange.document.name\"), $l(u.document.updateTime, \"documentChange.document.updateTime\");\n          var c = this.fromName(u.document.name),\n              h = this.fromVersion(u.document.updateTime),\n              l = new Vs(c, h, {}, void 0, u.document, function (t) {\n            return n.fromValue(t);\n          }),\n              f = u.targetIds || [],\n              p = u.removedTargetIds || [];\n          e = new El(f, p, l.key, l);\n        } else if (\"documentDelete\" in t) {\n          $l(t.documentDelete, \"documentDelete\");\n          var d = t.documentDelete;\n          $l(d.document, \"documentDelete.document\"), c = this.fromName(d.document), h = d.readTime ? this.fromVersion(d.readTime) : lo.forDeletedDoc(), l = new Ks(c, h), p = d.removedTargetIds || [], e = new El([], p, l.key, l);\n        } else if (\"documentRemove\" in t) {\n          $l(t.documentRemove, \"documentRemove\");\n          var m = t.documentRemove;\n          $l(m.document, \"documentRemove\"), c = this.fromName(m.document), p = m.removedTargetIds || [], e = new El([], p, c, null);\n        } else {\n          if (!(\"filter\" in t)) return Br(\"Unknown change type \" + JSON.stringify(t));\n          $l(t.filter, \"filter\");\n          var y = t.filter;\n          $l(y.targetId, \"filter.targetId\");\n          var g = y.count || 0,\n              v = new Wl(g),\n              b = y.targetId;\n          e = new Il(b, v);\n        }\n\n        return e;\n      }, nf.prototype.fromWatchTargetChangeState = function (t) {\n        return \"NO_CHANGE\" === t ? Tl.NoChange : \"ADD\" === t ? Tl.Added : \"REMOVE\" === t ? Tl.Removed : \"CURRENT\" === t ? Tl.Current : \"RESET\" === t ? Tl.Reset : Br(\"Got unexpected TargetChange.state: \" + t);\n      }, nf.prototype.versionFromListenResponse = function (t) {\n        if (!(\"targetChange\" in t)) return lo.MIN;\n        var e = t.targetChange;\n        return e.targetIds && e.targetIds.length ? lo.MIN : e.readTime ? this.fromVersion(e.readTime) : lo.MIN;\n      }, nf.prototype.toMutation = function (t) {\n        var e,\n            n = this;\n        if (t instanceof Ma) e = {\n          update: this.toMutationDocument(t.key, t.value)\n        };else if (t instanceof ja) e = {\n          delete: this.toName(t.key)\n        };else if (t instanceof Oa) e = {\n          update: this.toMutationDocument(t.key, t.data),\n          updateMask: this.toDocumentMask(t.fieldMask)\n        };else {\n          if (!(t instanceof Fa)) return Br(\"Unknown mutation type \" + t.type);\n          e = {\n            transform: {\n              document: this.toName(t.key),\n              fieldTransforms: t.fieldTransforms.map(function (t) {\n                return n.toFieldTransform(t);\n              })\n            }\n          };\n        }\n        return t.precondition.isNone || (e.currentDocument = this.toPrecondition(t.precondition)), e;\n      }, nf.prototype.fromMutation = function (t) {\n        var e = this,\n            n = t.currentDocument ? this.fromPrecondition(t.currentDocument) : Da.NONE;\n\n        if (t.update) {\n          $l(t.update.name, \"name\");\n          var r = this.fromName(t.update.name),\n              i = this.fromFields(t.update.fields || {});\n\n          if (t.updateMask) {\n            var o = this.fromDocumentMask(t.updateMask);\n            return new Oa(r, i, o, n);\n          }\n\n          return new Ma(r, i, n);\n        }\n\n        if (t.delete) return r = this.fromName(t.delete), new ja(r, n);\n\n        if (t.transform) {\n          r = this.fromName(t.transform.document);\n          var a = t.transform.fieldTransforms.map(function (t) {\n            return e.fromFieldTransform(t);\n          });\n          return Ur(!0 === n.exists, 'Transforms only support precondition \"exists == true\"'), new Fa(r, a);\n        }\n\n        return Br(\"unknown mutation proto: \" + JSON.stringify(t));\n      }, nf.prototype.toPrecondition = function (t) {\n        return Ur(!t.isNone, \"Can't serialize an empty precondition\"), void 0 !== t.updateTime ? {\n          updateTime: this.toVersion(t.updateTime)\n        } : void 0 !== t.exists ? {\n          exists: t.exists\n        } : Br(\"Unknown precondition\");\n      }, nf.prototype.fromPrecondition = function (t) {\n        return void 0 !== t.updateTime ? Da.updateTime(this.fromVersion(t.updateTime)) : void 0 !== t.exists ? Da.exists(t.exists) : Da.NONE;\n      }, nf.prototype.fromWriteResult = function (t, e) {\n        var n = this,\n            r = t.updateTime ? this.fromVersion(t.updateTime) : this.fromVersion(e);\n        r.isEqual(lo.MIN) && (r = this.fromVersion(e));\n        var i = null;\n        return t.transformResults && 0 < t.transformResults.length && (i = t.transformResults.map(function (t) {\n          return n.fromValue(t);\n        })), new Ca(r, i);\n      }, nf.prototype.fromWriteResults = function (t, e) {\n        var n = this;\n        return t && 0 < t.length ? (Ur(void 0 !== e, \"Received a write result without a commit time\"), t.map(function (t) {\n          return n.fromWriteResult(t, e);\n        })) : [];\n      }, nf.prototype.toFieldTransform = function (t) {\n        var e = this,\n            n = t.transform;\n        if (n instanceof Fl) return {\n          fieldPath: t.field.canonicalString(),\n          setToServerValue: \"REQUEST_TIME\"\n        };\n        if (n instanceof Vl) return {\n          fieldPath: t.field.canonicalString(),\n          appendMissingElements: {\n            values: n.elements.map(function (t) {\n              return e.toValue(t);\n            })\n          }\n        };\n        if (n instanceof Ul) return {\n          fieldPath: t.field.canonicalString(),\n          removeAllFromArray: {\n            values: n.elements.map(function (t) {\n              return e.toValue(t);\n            })\n          }\n        };\n        if (n instanceof Ql) return {\n          fieldPath: t.field.canonicalString(),\n          increment: this.toValue(n.operand)\n        };\n        throw Br(\"Unknown transform: \" + t.transform);\n      }, nf.prototype.fromFieldTransform = function (t) {\n        var e = this,\n            n = null;\n        if (\"setToServerValue\" in t) Ur(\"REQUEST_TIME\" === t.setToServerValue, \"Unknown server value transform proto: \" + JSON.stringify(t)), n = Fl.instance;else if (\"appendMissingElements\" in t) {\n          var r = t.appendMissingElements.values || [];\n          n = new Vl(r.map(function (t) {\n            return e.fromValue(t);\n          }));\n        } else if (\"removeAllFromArray\" in t) r = t.removeAllFromArray.values || [], n = new Ul(r.map(function (t) {\n          return e.fromValue(t);\n        }));else if (\"increment\" in t) {\n          var i = this.fromValue(t.increment);\n          Ur(i instanceof rs, \"NUMERIC_ADD transform requires a NumberValue\"), n = new Ql(i);\n        } else Br(\"Unknown transform proto: \" + JSON.stringify(t));\n        var o = ji.fromServerFormat(t.fieldPath);\n        return new Ta(o, n);\n      }, nf.prototype.toDocumentsTarget = function (t) {\n        return {\n          documents: [this.toQueryPath(t.path)]\n        };\n      }, nf.prototype.fromDocumentsTarget = function (t) {\n        var e = t.documents.length;\n        Ur(1 === e, \"DocumentsTarget contained other than 1 document: \" + e);\n        var n = t.documents[0];\n        return Rc.atPath(this.fromQueryPath(n)).toTarget();\n      }, nf.prototype.toQueryTarget = function (t) {\n        var e = {\n          structuredQuery: {}\n        },\n            n = t.path;\n        null !== t.collectionGroup ? (Ur(n.length % 2 == 0, \"Collection Group queries should be within a document path or root.\"), e.parent = this.toQueryPath(n), e.structuredQuery.from = [{\n          collectionId: t.collectionGroup,\n          allDescendants: !0\n        }]) : (Ur(n.length % 2 != 0, \"Document queries with filters are not supported.\"), e.parent = this.toQueryPath(n.popLast()), e.structuredQuery.from = [{\n          collectionId: n.lastSegment()\n        }]);\n        var r = this.toFilter(t.filters);\n        r && (e.structuredQuery.where = r);\n        var i = this.toOrder(t.orderBy);\n        i && (e.structuredQuery.orderBy = i);\n        var o = this.toInt32Value(t.limit);\n        return null !== o && (e.structuredQuery.limit = o), t.startAt && (e.structuredQuery.startAt = this.toCursor(t.startAt)), t.endAt && (e.structuredQuery.endAt = this.toCursor(t.endAt)), e;\n      }, nf.prototype.fromQueryTarget = function (t) {\n        var e = this.fromQueryPath(t.parent),\n            n = t.structuredQuery,\n            r = n.from ? n.from.length : 0,\n            i = null;\n\n        if (0 < r) {\n          Ur(1 === r, \"StructuredQuery.from with more than one collection is not supported.\");\n          var o = n.from[0];\n          o.allDescendants ? i = o.collectionId : e = e.child(o.collectionId);\n        }\n\n        var a = [];\n        n.where && (a = this.fromFilter(n.where));\n        var s = [];\n        n.orderBy && (s = this.fromOrder(n.orderBy));\n        var u = null;\n        n.limit && (u = this.fromInt32Value(n.limit));\n        var c = null;\n        n.startAt && (c = this.fromCursor(n.startAt));\n        var h = null;\n        return n.endAt && (h = this.fromCursor(n.endAt)), new Rc(e, i, s, a, u, Dc.First, c, h).toTarget();\n      }, nf.prototype.toListenRequestLabels = function (t) {\n        var e = this.toLabel(t.purpose);\n        return null == e ? null : {\n          \"goog-listen-tags\": e\n        };\n      }, nf.prototype.toLabel = function (t) {\n        switch (t) {\n          case qu.Listen:\n            return null;\n\n          case qu.ExistenceFilterMismatch:\n            return \"existence-filter-mismatch\";\n\n          case qu.LimboResolution:\n            return \"limbo-document\";\n\n          default:\n            return Br(\"Unrecognized query purpose: \" + t);\n        }\n      }, nf.prototype.toTarget = function (t) {\n        var e,\n            n = t.target;\n        return (e = n.isDocumentQuery() ? {\n          documents: this.toDocumentsTarget(n)\n        } : {\n          query: this.toQueryTarget(n)\n        }).targetId = t.targetId, 0 < t.resumeToken.length && (e.resumeToken = this.unsafeCastProtoByteString(t.resumeToken)), e;\n      }, nf.prototype.toFilter = function (t) {\n        var e = this;\n\n        if (0 !== t.length) {\n          var n = t.map(function (t) {\n            return t instanceof xc ? e.toUnaryOrFieldFilter(t) : Br(\"Unrecognized filter: \" + JSON.stringify(t));\n          });\n          return 1 === n.length ? n[0] : {\n            compositeFilter: {\n              op: \"AND\",\n              filters: n\n            }\n          };\n        }\n      }, nf.prototype.fromFilter = function (t) {\n        var e = this;\n        return t ? void 0 !== t.unaryFilter ? [this.fromUnaryFilter(t)] : void 0 !== t.fieldFilter ? [this.fromFieldFilter(t)] : void 0 !== t.compositeFilter ? t.compositeFilter.filters.map(function (t) {\n          return e.fromFilter(t);\n        }).reduce(function (t, e) {\n          return t.concat(e);\n        }) : Br(\"Unknown filter: \" + JSON.stringify(t)) : [];\n      }, nf.prototype.toOrder = function (t) {\n        var e = this;\n        if (0 !== t.length) return t.map(function (t) {\n          return e.toPropertyOrder(t);\n        });\n      }, nf.prototype.fromOrder = function (t) {\n        var e = this;\n        return t.map(function (t) {\n          return e.fromPropertyOrder(t);\n        });\n      }, nf.prototype.toCursor = function (t) {\n        var e = this;\n        return {\n          before: t.before,\n          values: t.position.map(function (t) {\n            return e.toValue(t);\n          })\n        };\n      }, nf.prototype.fromCursor = function (t) {\n        var e = this,\n            n = !!t.before,\n            r = t.values.map(function (t) {\n          return e.fromValue(t);\n        });\n        return new eh(r, n);\n      }, nf.prototype.toDirection = function (t) {\n        return Jl[t.name];\n      }, nf.prototype.fromDirection = function (t) {\n        switch (t) {\n          case \"ASCENDING\":\n            return $c.ASCENDING;\n\n          case \"DESCENDING\":\n            return $c.DESCENDING;\n\n          default:\n            return;\n        }\n      }, nf.prototype.toOperatorName = function (t) {\n        return Xl[t.name];\n      }, nf.prototype.fromOperatorName = function (t) {\n        switch (t) {\n          case \"EQUAL\":\n            return Lc.EQUAL;\n\n          case \"GREATER_THAN\":\n            return Lc.GREATER_THAN;\n\n          case \"GREATER_THAN_OR_EQUAL\":\n            return Lc.GREATER_THAN_OR_EQUAL;\n\n          case \"LESS_THAN\":\n            return Lc.LESS_THAN;\n\n          case \"LESS_THAN_OR_EQUAL\":\n            return Lc.LESS_THAN_OR_EQUAL;\n\n          case \"ARRAY_CONTAINS\":\n            return Lc.ARRAY_CONTAINS;\n\n          case \"IN\":\n            return Lc.IN;\n\n          case \"ARRAY_CONTAINS_ANY\":\n            return Lc.ARRAY_CONTAINS_ANY;\n\n          case \"OPERATOR_UNSPECIFIED\":\n            return Br(\"Unspecified operator\");\n\n          default:\n            return Br(\"Unknown operator\");\n        }\n      }, nf.prototype.toFieldPathReference = function (t) {\n        return {\n          fieldPath: t.canonicalString()\n        };\n      }, nf.prototype.fromFieldPathReference = function (t) {\n        return ji.fromServerFormat(t.fieldPath);\n      }, nf.prototype.toPropertyOrder = function (t) {\n        return {\n          field: this.toFieldPathReference(t.field),\n          direction: this.toDirection(t.dir)\n        };\n      }, nf.prototype.fromPropertyOrder = function (t) {\n        return new rh(this.fromFieldPathReference(t.field), this.fromDirection(t.direction));\n      }, nf.prototype.fromFieldFilter = function (t) {\n        return xc.create(this.fromFieldPathReference(t.fieldFilter.field), this.fromOperatorName(t.fieldFilter.op), this.fromValue(t.fieldFilter.value));\n      }, nf.prototype.toUnaryOrFieldFilter = function (t) {\n        if (t.op === Lc.EQUAL) {\n          if (t.value.isEqual(hs.NAN)) return {\n            unaryFilter: {\n              field: this.toFieldPathReference(t.field),\n              op: \"IS_NAN\"\n            }\n          };\n          if (t.value.isEqual(Xa.INSTANCE)) return {\n            unaryFilter: {\n              field: this.toFieldPathReference(t.field),\n              op: \"IS_NULL\"\n            }\n          };\n        }\n\n        return {\n          fieldFilter: {\n            field: this.toFieldPathReference(t.field),\n            op: this.toOperatorName(t.op),\n            value: this.toValue(t.value)\n          }\n        };\n      }, nf.prototype.fromUnaryFilter = function (t) {\n        switch (t.unaryFilter.op) {\n          case \"IS_NAN\":\n            var e = this.fromFieldPathReference(t.unaryFilter.field);\n            return xc.create(e, Lc.EQUAL, hs.NAN);\n\n          case \"IS_NULL\":\n            var n = this.fromFieldPathReference(t.unaryFilter.field);\n            return xc.create(n, Lc.EQUAL, Xa.INSTANCE);\n\n          case \"OPERATOR_UNSPECIFIED\":\n            return Br(\"Unspecified filter\");\n\n          default:\n            return Br(\"Unknown filter\");\n        }\n      }, nf.prototype.toDocumentMask = function (t) {\n        var e = [];\n        return t.fields.forEach(function (t) {\n          return e.push(t.canonicalString());\n        }), {\n          fieldPaths: e\n        };\n      }, nf.prototype.fromDocumentMask = function (t) {\n        var e = (t.fieldPaths || []).map(function (t) {\n          return ji.fromServerFormat(t);\n        });\n        return ba.fromArray(e);\n      }, nf);\n\n      function nf(t, e) {\n        this.databaseId = t, this.options = e;\n      }\n\n      var rf = function () {\n        this.viewSnap = null, this.targetId = 0, this.listeners = [];\n      },\n          of = (af.prototype.listen = function (t) {\n        var e = t.query,\n            n = !1,\n            r = this.queries.get(e);\n        return r || (n = !0, r = new rf(), this.queries.set(e, r)), r.listeners.push(t), Ur(!t.applyOnlineStateChange(this.onlineState), \"applyOnlineStateChange() shouldn't raise an event for brand-new listeners.\"), !r.viewSnap || t.onViewSnapshot(r.viewSnap) && this.raiseSnapshotsInSyncEvent(), n ? this.syncEngine.listen(e).then(function (t) {\n          return r.targetId = t;\n        }) : Promise.resolve(r.targetId);\n      }, af.prototype.unlisten = function (o) {\n        return p(this, void 0, void 0, function () {\n          var e, n, r, i;\n          return m(this, function (t) {\n            return e = o.query, n = !1, (r = this.queries.get(e)) && 0 <= (i = r.listeners.indexOf(o)) && (r.listeners.splice(i, 1), n = 0 === r.listeners.length), n ? (this.queries.delete(e), [2, this.syncEngine.unlisten(e)]) : [2];\n          });\n        });\n      }, af.prototype.onWatchChange = function (t) {\n        for (var e = !1, n = 0, r = t; n < r.length; n++) {\n          var i = r[n],\n              o = i.query,\n              a = this.queries.get(o);\n\n          if (a) {\n            for (var s = 0, u = a.listeners; s < u.length; s++) u[s].onViewSnapshot(i) && (e = !0);\n\n            a.viewSnap = i;\n          }\n        }\n\n        e && this.raiseSnapshotsInSyncEvent();\n      }, af.prototype.onWatchError = function (t, e) {\n        var n = this.queries.get(t);\n        if (n) for (var r = 0, i = n.listeners; r < i.length; r++) i[r].onError(e);\n        this.queries.delete(t);\n      }, af.prototype.onOnlineStateChange = function (i) {\n        this.onlineState = i;\n        var o = !1;\n        this.queries.forEach(function (t, e) {\n          for (var n = 0, r = e.listeners; n < r.length; n++) r[n].applyOnlineStateChange(i) && (o = !0);\n        }), o && this.raiseSnapshotsInSyncEvent();\n      }, af.prototype.addSnapshotsInSyncListener = function (t) {\n        this.snapshotsInSyncListeners.add(t), t.next();\n      }, af.prototype.removeSnapshotsInSyncListener = function (t) {\n        this.snapshotsInSyncListeners.delete(t);\n      }, af.prototype.raiseSnapshotsInSyncEvent = function () {\n        this.snapshotsInSyncListeners.forEach(function (t) {\n          t.next();\n        });\n      }, af);\n\n      function af(t) {\n        this.syncEngine = t, this.queries = new zs(function (t) {\n          return t.canonicalId();\n        }), this.onlineState = Yh.Unknown, this.snapshotsInSyncListeners = new Set(), this.syncEngine.subscribe(this);\n      }\n\n      var sf = (uf.prototype.onViewSnapshot = function (t) {\n        if (Ur(0 < t.docChanges.length || t.syncStateChanged, \"We got a new snapshot with no changes?\"), !this.options.includeMetadataChanges) {\n          for (var e = [], n = 0, r = t.docChanges; n < r.length; n++) {\n            var i = r[n];\n            i.type !== sl.Metadata && e.push(i);\n          }\n\n          t = new ml(t.query, t.docs, t.oldDocs, e, t.mutatedKeys, t.fromCache, t.syncStateChanged, !0);\n        }\n\n        var o = !1;\n        return this.raisedInitialEvent ? this.shouldRaiseEvent(t) && (this.queryObserver.next(t), o = !0) : this.shouldRaiseInitialEvent(t, this.onlineState) && (this.raiseInitialEvent(t), o = !0), this.snap = t, o;\n      }, uf.prototype.onError = function (t) {\n        this.queryObserver.error(t);\n      }, uf.prototype.applyOnlineStateChange = function (t) {\n        this.onlineState = t;\n        var e = !1;\n        return this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, t) && (this.raiseInitialEvent(this.snap), e = !0), e;\n      }, uf.prototype.shouldRaiseInitialEvent = function (t, e) {\n        if (Ur(!this.raisedInitialEvent, \"Determining whether to raise first event but already had first event\"), !t.fromCache) return !0;\n        var n = e !== Yh.Offline;\n        return this.options.waitForSyncWhenOnline && n ? (Ur(t.fromCache, \"Waiting for sync, but snapshot is not from cache\"), !1) : !t.docs.isEmpty() || e === Yh.Offline;\n      }, uf.prototype.shouldRaiseEvent = function (t) {\n        if (0 < t.docChanges.length) return !0;\n        var e = this.snap && this.snap.hasPendingWrites !== t.hasPendingWrites;\n        return !(!t.syncStateChanged && !e) && !0 === this.options.includeMetadataChanges;\n      }, uf.prototype.raiseInitialEvent = function (t) {\n        Ur(!this.raisedInitialEvent, \"Trying to raise initial events for second time\"), t = ml.fromInitialDocuments(t.query, t.docs, t.mutatedKeys, t.fromCache), this.raisedInitialEvent = !0, this.queryObserver.next(t);\n      }, uf);\n\n      function uf(t, e, n) {\n        this.query = t, this.queryObserver = e, this.raisedInitialEvent = !1, this.snap = null, this.onlineState = Yh.Unknown, this.options = n || {};\n      }\n\n      var cf = (hf.fromSnapshot = function (t, e) {\n        for (var n = Oo(), r = Oo(), i = 0, o = e.docChanges; i < o.length; i++) {\n          var a = o[i];\n\n          switch (a.type) {\n            case sl.Added:\n              n = n.add(a.doc.key);\n              break;\n\n            case sl.Removed:\n              r = r.add(a.doc.key);\n          }\n        }\n\n        return new hf(t, e.fromCache, n, r);\n      }, hf);\n\n      function hf(t, e, n, r) {\n        this.targetId = t, this.fromCache = e, this.addedKeys = n, this.removedKeys = r;\n      }\n\n      var lf = function (t) {\n        this.key = t;\n      },\n          ff = function (t) {\n        this.key = t;\n      },\n          pf = (Object.defineProperty(df.prototype, \"syncedDocuments\", {\n        get: function () {\n          return this._syncedDocuments;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), df.prototype.computeDocChanges = function (t, e) {\n        var s = this,\n            u = e ? e.changeSet : new pl(),\n            c = e ? e.documentSet : this.documentSet,\n            h = e ? e.mutatedKeys : this.mutatedKeys,\n            l = c,\n            f = !1,\n            p = this.query.hasLimitToFirst() && c.size === this.query.limit ? c.last() : null,\n            d = this.query.hasLimitToLast() && c.size === this.query.limit ? c.first() : null;\n        if (t.inorderTraversal(function (t, e) {\n          var n = c.get(t),\n              r = e instanceof Vs ? e : null;\n          r && (Ur(t.isEqual(r.key), \"Mismatching keys found in document changes: \" + t + \" != \" + r.key), r = s.query.matches(r) ? r : null);\n          var i = !!n && s.mutatedKeys.has(n.key),\n              o = !!r && (r.hasLocalMutations || s.mutatedKeys.has(r.key) && r.hasCommittedMutations),\n              a = !1;\n          n && r ? n.data().isEqual(r.data()) ? i !== o && (u.track({\n            type: sl.Metadata,\n            doc: r\n          }), a = !0) : s.shouldWaitForSyncedDocument(n, r) || (u.track({\n            type: sl.Modified,\n            doc: r\n          }), a = !0, (p && 0 < s.query.docComparator(r, p) || d && s.query.docComparator(r, d) < 0) && (f = !0)) : !n && r ? (u.track({\n            type: sl.Added,\n            doc: r\n          }), a = !0) : n && !r && (u.track({\n            type: sl.Removed,\n            doc: n\n          }), a = !0, (p || d) && (f = !0)), a && (h = r ? (l = l.add(r), o ? h.add(t) : h.delete(t)) : (l = l.delete(t), h.delete(t)));\n        }), this.query.hasLimitToFirst() || this.query.hasLimitToLast()) for (; l.size > this.query.limit;) {\n          var n = this.query.hasLimitToFirst() ? l.last() : l.first();\n          l = l.delete(n.key), h = h.delete(n.key), u.track({\n            type: sl.Removed,\n            doc: n\n          });\n        }\n        return Ur(!f || !e, \"View was refilled using docs that themselves needed refilling.\"), {\n          documentSet: l,\n          changeSet: u,\n          needsRefill: f,\n          mutatedKeys: h\n        };\n      }, df.prototype.shouldWaitForSyncedDocument = function (t, e) {\n        return t.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;\n      }, df.prototype.applyChanges = function (t, e, n) {\n        var r = this;\n        Ur(!t.needsRefill, \"Cannot apply changes that need a refill\");\n        var i = this.documentSet;\n        this.documentSet = t.documentSet, this.mutatedKeys = t.mutatedKeys;\n        var o = t.changeSet.getChanges();\n        o.sort(function (t, e) {\n          return function (t, e) {\n            function n(t) {\n              switch (t) {\n                case sl.Added:\n                  return 1;\n\n                case sl.Modified:\n                case sl.Metadata:\n                  return 2;\n\n                case sl.Removed:\n                  return 0;\n\n                default:\n                  return Br(\"Unknown ChangeType: \" + t);\n              }\n            }\n\n            return n(t) - n(e);\n          }(t.type, e.type) || r.query.docComparator(t.doc, e.doc);\n        }), this.applyTargetChange(n);\n        var a = e ? this.updateLimboDocuments() : [],\n            s = 0 === this.limboDocuments.size && this.current ? cl.Synced : cl.Local,\n            u = s !== this.syncState;\n        return this.syncState = s, 0 !== o.length || u ? {\n          snapshot: new ml(this.query, t.documentSet, i, o, t.mutatedKeys, s === cl.Local, u, !1),\n          limboChanges: a\n        } : {\n          limboChanges: a\n        };\n      }, df.prototype.applyOnlineStateChange = function (t) {\n        return this.current && t === Yh.Offline ? (this.current = !1, this.applyChanges({\n          documentSet: this.documentSet,\n          changeSet: new pl(),\n          mutatedKeys: this.mutatedKeys,\n          needsRefill: !1\n        }, !1)) : {\n          limboChanges: []\n        };\n      }, df.prototype.shouldBeInLimbo = function (t) {\n        return !this._syncedDocuments.has(t) && !!this.documentSet.has(t) && !this.documentSet.get(t).hasLocalMutations;\n      }, df.prototype.applyTargetChange = function (t) {\n        var e = this;\n        t && (t.addedDocuments.forEach(function (t) {\n          return e._syncedDocuments = e._syncedDocuments.add(t);\n        }), t.modifiedDocuments.forEach(function (t) {\n          return Ur(e._syncedDocuments.has(t), \"Modified document \" + t + \" not found in view.\");\n        }), t.removedDocuments.forEach(function (t) {\n          return e._syncedDocuments = e._syncedDocuments.delete(t);\n        }), this.current = t.current);\n      }, df.prototype.updateLimboDocuments = function () {\n        var e = this;\n        if (!this.current) return [];\n        var n = this.limboDocuments;\n        this.limboDocuments = Oo(), this.documentSet.forEach(function (t) {\n          e.shouldBeInLimbo(t.key) && (e.limboDocuments = e.limboDocuments.add(t.key));\n        });\n        var r = [];\n        return n.forEach(function (t) {\n          e.limboDocuments.has(t) || r.push(new ff(t));\n        }), this.limboDocuments.forEach(function (t) {\n          n.has(t) || r.push(new lf(t));\n        }), r;\n      }, df.prototype.synchronizeWithPersistedState = function (t) {\n        this._syncedDocuments = t.remoteKeys, this.limboDocuments = Oo();\n        var e = this.computeDocChanges(t.documents);\n        return this.applyChanges(e, !0);\n      }, df.prototype.computeInitialSnapshot = function () {\n        return ml.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === cl.Local);\n      }, df);\n\n      function df(t, e) {\n        this.query = t, this._syncedDocuments = e, this.syncState = null, this.current = !1, this.limboDocuments = Oo(), this.mutatedKeys = Oo(), this.documentSet = new ll(t.docComparator.bind(t));\n      }\n\n      var mf = (yf.prototype.run = function () {\n        this.runWithBackOff();\n      }, yf.prototype.runWithBackOff = function () {\n        var t = this;\n        this.backoff.backoffAndRun(function () {\n          return p(t, void 0, void 0, function () {\n            var e,\n                n,\n                r = this;\n            return m(this, function (t) {\n              return e = this.remoteStore.createTransaction(), (n = this.tryRunUpdateFunction(e)) && n.then(function (t) {\n                r.asyncQueue.enqueueAndForget(function () {\n                  return e.commit().then(function () {\n                    r.deferred.resolve(t);\n                  }).catch(function (t) {\n                    r.handleTransactionError(t);\n                  });\n                });\n              }).catch(function (t) {\n                r.handleTransactionError(t);\n              }), [2];\n            });\n          });\n        });\n      }, yf.prototype.tryRunUpdateFunction = function (t) {\n        try {\n          var e = this.updateFunction(t);\n          return !Ic(e) && e.catch && e.then ? e : (this.deferred.reject(Error(\"Transaction callback must return a Promise\")), null);\n        } catch (t) {\n          return this.deferred.reject(t), null;\n        }\n      }, yf.prototype.handleTransactionError = function (t) {\n        var e = this;\n        0 < this.retries && this.isRetryableTransactionError(t) ? (this.retries -= 1, this.asyncQueue.enqueueAndForget(function () {\n          return e.runWithBackOff(), Promise.resolve();\n        })) : this.deferred.reject(t);\n      }, yf.prototype.isRetryableTransactionError = function (t) {\n        if (\"FirebaseError\" !== t.name) return !1;\n        var e = t.code;\n        return \"aborted\" === e || \"failed-precondition\" === e || !ol(e);\n      }, yf);\n\n      function yf(t, e, n, r) {\n        this.asyncQueue = t, this.remoteStore = e, this.updateFunction = n, this.deferred = r, this.retries = 5, this.backoff = new Oh(this.asyncQueue, Hi.RetryTransaction);\n      }\n\n      var gf = \"SyncEngine\",\n          vf = function (t, e, n) {\n        this.query = t, this.targetId = e, this.view = n;\n      },\n          bf = function (t) {\n        this.key = t, this.receivedDocument = !1;\n      },\n          wf = (Object.defineProperty(Tf.prototype, \"isPrimaryClient\", {\n        get: function () {\n          return !0 === this.isPrimary;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Tf.prototype.subscribe = function (t) {\n        Ur(null !== t, \"SyncEngine listener cannot be null\"), Ur(null === this.syncEngineListener, \"SyncEngine already has a subscriber.\"), this.syncEngineListener = t;\n      }, Tf.prototype.listen = function (a) {\n        return p(this, void 0, void 0, function () {\n          var e, n, r, i, o;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.assertSubscribed(\"listen()\"), (r = this.queryViewsByQuery.get(a)) ? (e = r.targetId, this.sharedClientState.addLocalQueryTarget(e), n = r.view.computeInitialSnapshot(), [3, 4]) : [3, 1];\n\n              case 1:\n                return [4, this.localStore.allocateTarget(a.toTarget())];\n\n              case 2:\n                return i = t.sent(), o = this.sharedClientState.addLocalQueryTarget(i.targetId), e = i.targetId, [4, this.initializeViewAndComputeSnapshot(a, e, \"current\" === o)];\n\n              case 3:\n                n = t.sent(), this.isPrimary && this.remoteStore.listen(i), t.label = 4;\n\n              case 4:\n                return this.syncEngineListener.onWatchChange([n]), [2, e];\n            }\n          });\n        });\n      }, Tf.prototype.initializeViewAndComputeSnapshot = function (s, u, c) {\n        return p(this, void 0, void 0, function () {\n          var e, n, r, i, o, a;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return [4, this.localStore.executeQuery(s, !0)];\n\n              case 1:\n                return e = t.sent(), n = new pf(s, e.remoteKeys), r = n.computeDocChanges(e.documents), i = bl.createSynthesizedTargetChangeForCurrentChange(u, c && this.onlineState !== Yh.Offline), Ur(0 === (o = n.applyChanges(r, !0 === this.isPrimary, i)).limboChanges.length, \"View returned limbo docs before target ack from the server.\"), Ur(!!o.snapshot, \"applyChanges for new view should always return a snapshot\"), a = new vf(s, u, n), this.queryViewsByQuery.set(s, a), this.queriesByTarget[u] || (this.queriesByTarget[u] = []), this.queriesByTarget[u].push(s), [2, o.snapshot];\n            }\n          });\n        });\n      }, Tf.prototype.synchronizeViewAndComputeSnapshot = function (r) {\n        return p(this, void 0, void 0, function () {\n          var e, n;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return [4, this.localStore.executeQuery(r.query, !0)];\n\n              case 1:\n                return e = t.sent(), n = r.view.synchronizeWithPersistedState(e), this.isPrimary && this.updateTrackedLimbos(r.targetId, n.limboChanges), [2, n];\n            }\n          });\n        });\n      }, Tf.prototype.unlisten = function (i) {\n        return p(this, void 0, void 0, function () {\n          var e,\n              n,\n              r = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.assertSubscribed(\"unlisten()\"), Ur(!!(e = this.queryViewsByQuery.get(i)), \"Trying to unlisten on query not found:\" + i), 1 < (n = this.queriesByTarget[e.targetId]).length ? (this.queriesByTarget[e.targetId] = n.filter(function (t) {\n                  return !t.isEqual(i);\n                }), this.queryViewsByQuery.delete(i), [2]) : this.isPrimary ? (this.sharedClientState.removeLocalQueryTarget(e.targetId), this.sharedClientState.isActiveQueryTarget(e.targetId) ? [3, 2] : [4, this.localStore.releaseTarget(e.targetId, !1).then(function () {\n                  r.sharedClientState.clearQueryState(e.targetId), r.remoteStore.unlisten(e.targetId), r.removeAndCleanupTarget(e.targetId);\n                }).catch(dc)]) : [3, 3];\n\n              case 1:\n                t.sent(), t.label = 2;\n\n              case 2:\n                return [3, 5];\n\n              case 3:\n                return this.removeAndCleanupTarget(e.targetId), [4, this.localStore.releaseTarget(e.targetId, !0)];\n\n              case 4:\n                t.sent(), t.label = 5;\n\n              case 5:\n                return [2];\n            }\n          });\n        });\n      }, Tf.prototype.write = function (n, r) {\n        return p(this, void 0, void 0, function () {\n          var e;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.assertSubscribed(\"write()\"), [4, this.localStore.localWrite(n)];\n\n              case 1:\n                return e = t.sent(), this.sharedClientState.addPendingMutation(e.batchId), this.addMutationCallback(e.batchId, r), [4, this.emitNewSnapsAndNotifyLocalStore(e.changes)];\n\n              case 2:\n                return t.sent(), [4, this.remoteStore.fillWritePipeline()];\n\n              case 3:\n                return t.sent(), [2];\n            }\n          });\n        });\n      }, Tf.prototype.runTransaction = function (t, e, n) {\n        new mf(t, this.remoteStore, e, n).run();\n      }, Tf.prototype.applyRemoteEvent = function (n) {\n        return p(this, void 0, void 0, function () {\n          var e,\n              r = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                this.assertSubscribed(\"applyRemoteEvent()\"), t.label = 1;\n\n              case 1:\n                return t.trys.push([1, 4,, 6]), [4, this.localStore.applyRemoteEvent(n)];\n\n              case 2:\n                return e = t.sent(), $r(n.targetChanges, function (t, e) {\n                  var n = r.limboResolutionsByTarget[Number(t)];\n                  n && (Ur(e.addedDocuments.size + e.modifiedDocuments.size + e.removedDocuments.size <= 1, \"Limbo resolution for single document contains multiple changes.\"), 0 < e.addedDocuments.size ? n.receivedDocument = !0 : 0 < e.modifiedDocuments.size ? Ur(n.receivedDocument, \"Received change for limbo target document without add.\") : 0 < e.removedDocuments.size && (Ur(n.receivedDocument, \"Received remove for limbo target document without add.\"), n.receivedDocument = !1));\n                }), [4, this.emitNewSnapsAndNotifyLocalStore(e, n)];\n\n              case 3:\n                return t.sent(), [3, 6];\n\n              case 4:\n                return [4, dc(t.sent())];\n\n              case 5:\n                return t.sent(), [3, 6];\n\n              case 6:\n                return [2];\n            }\n          });\n        });\n      }, Tf.prototype.applyOnlineStateChange = function (r, t) {\n        if (this.isPrimary && t === Xh.RemoteStore || !this.isPrimary && t === Xh.SharedClientState) {\n          this.assertSubscribed(\"applyOnlineStateChange()\");\n          var i = [];\n          this.queryViewsByQuery.forEach(function (t, e) {\n            var n = e.view.applyOnlineStateChange(r);\n            Ur(0 === n.limboChanges.length, \"OnlineState should not affect limbo documents.\"), n.snapshot && i.push(n.snapshot);\n          }), this.syncEngineListener.onOnlineStateChange(r), this.syncEngineListener.onWatchChange(i), this.onlineState = r, this.isPrimary && this.sharedClientState.setOnlineState(r);\n        }\n      }, Tf.prototype.rejectListen = function (s, u) {\n        return p(this, void 0, void 0, function () {\n          var e,\n              n,\n              r,\n              i,\n              o,\n              a = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.assertSubscribed(\"rejectListens()\"), this.sharedClientState.updateQueryState(s, \"rejected\", u), e = this.limboResolutionsByTarget[s], (n = e && e.key) ? (this.limboTargetsByKey = this.limboTargetsByKey.remove(n), delete this.limboResolutionsByTarget[s], r = (r = new po(Wi.comparator)).insert(n, new Ks(n, lo.forDeletedDoc())), i = Oo().add(n), o = new gl(lo.MIN, {}, new So(Si), r, i), [2, this.applyRemoteEvent(o)]) : [3, 1];\n\n              case 1:\n                return [4, this.localStore.releaseTarget(s, !1).then(function () {\n                  return a.removeAndCleanupTarget(s, u);\n                }).catch(dc)];\n\n              case 2:\n                t.sent(), t.label = 3;\n\n              case 3:\n                return [2];\n            }\n          });\n        });\n      }, Tf.prototype.applyBatchState = function (n, r, i) {\n        return p(this, void 0, void 0, function () {\n          var e;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.assertSubscribed(\"applyBatchState()\"), [4, this.localStore.lookupMutationDocuments(n)];\n\n              case 1:\n                return null === (e = t.sent()) ? (Fr(gf, \"Cannot apply mutation batch with id: \" + n), [2]) : \"pending\" !== r ? [3, 3] : [4, this.remoteStore.fillWritePipeline()];\n\n              case 2:\n                return t.sent(), [3, 4];\n\n              case 3:\n                \"acknowledged\" === r || \"rejected\" === r ? (this.processUserCallback(n, i || null), this.localStore.removeCachedMutationBatchMetadata(n)) : Br(\"Unknown batchState: \" + r), t.label = 4;\n\n              case 4:\n                return [4, this.emitNewSnapsAndNotifyLocalStore(e)];\n\n              case 5:\n                return t.sent(), [2];\n            }\n          });\n        });\n      }, Tf.prototype.applySuccessfulWrite = function (r) {\n        return p(this, void 0, void 0, function () {\n          var e, n;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                this.assertSubscribed(\"applySuccessfulWrite()\"), e = r.batch.batchId, this.processUserCallback(e, null), this.triggerPendingWritesCallbacks(e), t.label = 1;\n\n              case 1:\n                return t.trys.push([1, 4,, 6]), [4, this.localStore.acknowledgeBatch(r)];\n\n              case 2:\n                return n = t.sent(), this.sharedClientState.updateMutationState(e, \"acknowledged\"), [4, this.emitNewSnapsAndNotifyLocalStore(n)];\n\n              case 3:\n                return t.sent(), [3, 6];\n\n              case 4:\n                return [4, dc(t.sent())];\n\n              case 5:\n                return t.sent(), [3, 6];\n\n              case 6:\n                return [2];\n            }\n          });\n        });\n      }, Tf.prototype.rejectFailedWrite = function (n, r) {\n        return p(this, void 0, void 0, function () {\n          var e;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                this.assertSubscribed(\"rejectFailedWrite()\"), this.processUserCallback(n, r), this.triggerPendingWritesCallbacks(n), t.label = 1;\n\n              case 1:\n                return t.trys.push([1, 4,, 6]), [4, this.localStore.rejectBatch(n)];\n\n              case 2:\n                return e = t.sent(), this.sharedClientState.updateMutationState(n, \"rejected\", r), [4, this.emitNewSnapsAndNotifyLocalStore(e)];\n\n              case 3:\n                return t.sent(), [3, 6];\n\n              case 4:\n                return [4, dc(t.sent())];\n\n              case 5:\n                return t.sent(), [3, 6];\n\n              case 6:\n                return [2];\n            }\n          });\n        });\n      }, Tf.prototype.registerPendingWritesCallback = function (r) {\n        return p(this, void 0, void 0, function () {\n          var e, n;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return this.remoteStore.canUseNetwork() || Fr(gf, \"The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.\"), [4, this.localStore.getHighestUnacknowledgedBatchId()];\n\n              case 1:\n                return -1 === (e = t.sent()) ? r.resolve() : ((n = this.pendingWritesCallbacks.get(e) || []).push(r), this.pendingWritesCallbacks.set(e, n)), [2];\n            }\n          });\n        });\n      }, Tf.prototype.triggerPendingWritesCallbacks = function (t) {\n        (this.pendingWritesCallbacks.get(t) || []).forEach(function (t) {\n          t.resolve();\n        }), this.pendingWritesCallbacks.delete(t);\n      }, Tf.prototype.rejectOutstandingPendingWritesCallbacks = function (e) {\n        this.pendingWritesCallbacks.forEach(function (t) {\n          t.forEach(function (t) {\n            t.reject(new zr(Wr.CANCELLED, e));\n          });\n        }), this.pendingWritesCallbacks.clear();\n      }, Tf.prototype.addMutationCallback = function (t, e) {\n        var n = this.mutationUserCallbacks[this.currentUser.toKey()];\n        n = (n = n || new po(Si)).insert(t, e), this.mutationUserCallbacks[this.currentUser.toKey()] = n;\n      }, Tf.prototype.processUserCallback = function (t, e) {\n        var n = this.mutationUserCallbacks[this.currentUser.toKey()];\n\n        if (n) {\n          var r = n.get(t);\n          r && (Ur(t === n.minKey(), \"Mutation callbacks processed out-of-order?\"), e ? r.reject(e) : r.resolve(), n = n.remove(t)), this.mutationUserCallbacks[this.currentUser.toKey()] = n;\n        }\n      }, Tf.prototype.removeAndCleanupTarget = function (t, e) {\n        var n = this;\n        void 0 === e && (e = null), this.sharedClientState.removeLocalQueryTarget(t), Ur(this.queriesByTarget[t] && 0 !== this.queriesByTarget[t].length, \"There are no queries mapped to target id \" + t);\n\n        for (var r = 0, i = this.queriesByTarget[t]; r < i.length; r++) {\n          var o = i[r];\n          this.queryViewsByQuery.delete(o), e && this.syncEngineListener.onWatchError(o, e);\n        }\n\n        if (delete this.queriesByTarget[t], this.isPrimary) {\n          var a = this.limboDocumentRefs.referencesForId(t);\n          this.limboDocumentRefs.removeReferencesForId(t), a.forEach(function (t) {\n            n.limboDocumentRefs.containsKey(t) || n.removeLimboTarget(t);\n          });\n        }\n      }, Tf.prototype.removeLimboTarget = function (t) {\n        var e = this.limboTargetsByKey.get(t);\n        null !== e && (this.remoteStore.unlisten(e), this.limboTargetsByKey = this.limboTargetsByKey.remove(t), delete this.limboResolutionsByTarget[e]);\n      }, Tf.prototype.updateTrackedLimbos = function (t, e) {\n        for (var n = 0, r = e; n < r.length; n++) {\n          var i = r[n];\n          i instanceof lf ? (this.limboDocumentRefs.addReference(i.key, t), this.trackLimboChange(i)) : i instanceof ff ? (Fr(gf, \"Document no longer in limbo: \" + i.key), this.limboDocumentRefs.removeReference(i.key, t), this.limboDocumentRefs.containsKey(i.key) || this.removeLimboTarget(i.key)) : Br(\"Unknown limbo change: \" + JSON.stringify(i));\n        }\n      }, Tf.prototype.trackLimboChange = function (t) {\n        var e = t.key;\n\n        if (!this.limboTargetsByKey.get(e)) {\n          Fr(gf, \"New document in limbo: \" + e);\n          var n = this.limboTargetIdGenerator.next(),\n              r = Rc.atPath(e.path);\n          this.limboResolutionsByTarget[n] = new bf(e), this.remoteStore.listen(new ju(r.toTarget(), n, qu.LimboResolution, Oi.INVALID)), this.limboTargetsByKey = this.limboTargetsByKey.insert(e, n);\n        }\n      }, Tf.prototype.currentLimboDocs = function () {\n        return this.limboTargetsByKey;\n      }, Tf.prototype.emitNewSnapsAndNotifyLocalStore = function (r, u) {\n        return p(this, void 0, void 0, function () {\n          var o,\n              a,\n              e,\n              s = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return o = [], a = [], e = [], this.queryViewsByQuery.forEach(function (t, i) {\n                  e.push(Promise.resolve().then(function () {\n                    var n = i.view.computeDocChanges(r);\n                    return n.needsRefill ? s.localStore.executeQuery(i.query, !1).then(function (t) {\n                      var e = t.documents;\n                      return i.view.computeDocChanges(e, n);\n                    }) : n;\n                  }).then(function (t) {\n                    var e = u && u.targetChanges[i.targetId],\n                        n = i.view.applyChanges(t, !0 === s.isPrimary, e);\n\n                    if (s.updateTrackedLimbos(i.targetId, n.limboChanges), n.snapshot) {\n                      s.isPrimary && s.sharedClientState.updateQueryState(i.targetId, n.snapshot.fromCache ? \"not-current\" : \"current\"), o.push(n.snapshot);\n                      var r = cf.fromSnapshot(i.targetId, n.snapshot);\n                      a.push(r);\n                    }\n                  }));\n                }), [4, Promise.all(e)];\n\n              case 1:\n                return t.sent(), this.syncEngineListener.onWatchChange(o), [4, this.localStore.notifyLocalViewChanges(a)];\n\n              case 2:\n                return t.sent(), [2];\n            }\n          });\n        });\n      }, Tf.prototype.assertSubscribed = function (t) {\n        Ur(null !== this.syncEngineListener, \"Trying to call \" + t + \" before calling subscribe().\");\n      }, Tf.prototype.handleCredentialChange = function (r) {\n        return p(this, void 0, void 0, function () {\n          var e, n;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return e = !this.currentUser.isEqual(r), this.currentUser = r, e ? (this.rejectOutstandingPendingWritesCallbacks(\"'waitForPendingWrites' promise is rejected due to a user change.\"), [4, this.localStore.handleUserChange(r)]) : [3, 3];\n\n              case 1:\n                return n = t.sent(), this.sharedClientState.handleUserChange(r, n.removedBatchIds, n.addedBatchIds), [4, this.emitNewSnapsAndNotifyLocalStore(n.affectedDocuments)];\n\n              case 2:\n                t.sent(), t.label = 3;\n\n              case 3:\n                return [4, this.remoteStore.handleCredentialChange()];\n\n              case 4:\n                return t.sent(), [2];\n            }\n          });\n        });\n      }, Tf.prototype.applyPrimaryState = function (c) {\n        return p(this, void 0, void 0, function () {\n          var e,\n              n,\n              r,\n              i,\n              o,\n              a,\n              s,\n              u = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return !0 !== c || !0 === this.isPrimary ? [3, 3] : (this.isPrimary = !0, [4, this.remoteStore.applyPrimaryState(!0)]);\n\n              case 1:\n                return t.sent(), e = this.sharedClientState.getAllActiveQueryTargets(), [4, this.synchronizeQueryViewsAndRaiseSnapshots(e.toArray())];\n\n              case 2:\n                for (n = t.sent(), r = 0, i = n; r < i.length; r++) o = i[r], this.remoteStore.listen(o);\n\n                return [3, 7];\n\n              case 3:\n                return !1 !== c || !1 === this.isPrimary ? [3, 7] : (this.isPrimary = !1, a = [], s = Promise.resolve(), Zr(this.queriesByTarget, function (t, e) {\n                  u.sharedClientState.isLocalQueryTarget(t) ? a.push(t) : s = s.then(function () {\n                    return u.removeAndCleanupTarget(t), u.localStore.releaseTarget(t, !0);\n                  }), u.remoteStore.unlisten(t);\n                }), [4, s]);\n\n              case 4:\n                return t.sent(), [4, this.synchronizeQueryViewsAndRaiseSnapshots(a)];\n\n              case 5:\n                return t.sent(), this.resetLimboDocuments(), [4, this.remoteStore.applyPrimaryState(!1)];\n\n              case 6:\n                t.sent(), t.label = 7;\n\n              case 7:\n                return [2];\n            }\n          });\n        });\n      }, Tf.prototype.resetLimboDocuments = function () {\n        var e = this;\n        Zr(this.limboResolutionsByTarget, function (t) {\n          e.remoteStore.unlisten(t);\n        }), this.limboDocumentRefs.removeAllReferences(), this.limboResolutionsByTarget = [], this.limboTargetsByKey = new po(Wi.comparator);\n      }, Tf.prototype.synchronizeQueryViewsAndRaiseSnapshots = function (d) {\n        return p(this, void 0, void 0, function () {\n          var e, n, r, i, o, a, s, u, c, h, l, f, p;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                e = [], n = [], r = 0, i = d, t.label = 1;\n\n              case 1:\n                return r < i.length ? (o = i[r], a = void 0, (s = this.queriesByTarget[o]) && 0 !== s.length ? [4, this.localStore.releaseTarget(o, !0)] : [3, 8]) : [3, 14];\n\n              case 2:\n                return t.sent(), [4, this.localStore.allocateTarget(s[0].toTarget())];\n\n              case 3:\n                a = t.sent(), u = 0, c = s, t.label = 4;\n\n              case 4:\n                return u < c.length ? (h = c[u], Ur(!!(l = this.queryViewsByQuery.get(h)), \"No query view found for \" + h), [4, this.synchronizeViewAndComputeSnapshot(l)]) : [3, 7];\n\n              case 5:\n                (f = t.sent()).snapshot && n.push(f.snapshot), t.label = 6;\n\n              case 6:\n                return u++, [3, 4];\n\n              case 7:\n                return [3, 12];\n\n              case 8:\n                return Ur(!0 === this.isPrimary, \"A secondary tab should never have an active target without an active query.\"), [4, this.localStore.getTarget(o)];\n\n              case 9:\n                return Ur(!!(p = t.sent()), \"Target for id \" + o + \" not found\"), [4, this.localStore.allocateTarget(p)];\n\n              case 10:\n                return a = t.sent(), [4, this.initializeViewAndComputeSnapshot(this.synthesizeTargetToQuery(p), o, !1)];\n\n              case 11:\n                t.sent(), t.label = 12;\n\n              case 12:\n                e.push(a), t.label = 13;\n\n              case 13:\n                return r++, [3, 1];\n\n              case 14:\n                return this.syncEngineListener.onWatchChange(n), [2, e];\n            }\n          });\n        });\n      }, Tf.prototype.synthesizeTargetToQuery = function (t) {\n        return new Rc(t.path, t.collectionGroup, t.orderBy, t.filters, t.limit, Dc.First, t.startAt, t.endAt);\n      }, Tf.prototype.getActiveClients = function () {\n        return this.localStore.getActiveClients();\n      }, Tf.prototype.applyTargetState = function (r, i, o) {\n        return p(this, void 0, void 0, function () {\n          var e, n;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                if (this.isPrimary) return Fr(gf, \"Ignoring unexpected query state notification.\"), [2];\n                if (!this.queriesByTarget[r]) return [3, 7];\n\n                switch (i) {\n                  case \"current\":\n                  case \"not-current\":\n                    return [3, 1];\n\n                  case \"rejected\":\n                    return [3, 4];\n                }\n\n                return [3, 6];\n\n              case 1:\n                return [4, this.localStore.getNewDocumentChanges()];\n\n              case 2:\n                return e = t.sent(), n = gl.createSynthesizedRemoteEventForCurrentChange(r, \"current\" === i), [4, this.emitNewSnapsAndNotifyLocalStore(e, n)];\n\n              case 3:\n                return t.sent(), [3, 7];\n\n              case 4:\n                return [4, this.localStore.releaseTarget(r, !0)];\n\n              case 5:\n                return t.sent(), this.removeAndCleanupTarget(r, o), [3, 7];\n\n              case 6:\n                Br(\"Unexpected target state: \" + i), t.label = 7;\n\n              case 7:\n                return [2];\n            }\n          });\n        });\n      }, Tf.prototype.applyActiveTargetsChange = function (l, f) {\n        return p(this, void 0, void 0, function () {\n          var e,\n              n,\n              r,\n              i,\n              o,\n              a,\n              s,\n              u,\n              c,\n              h = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                if (!this.isPrimary) return [2];\n                e = 0, n = l, t.label = 1;\n\n              case 1:\n                return e < n.length ? (c = n[e], Ur(!this.queriesByTarget[c], \"Trying to add an already active target\"), [4, this.localStore.getTarget(c)]) : [3, 6];\n\n              case 2:\n                return Ur(!!(r = t.sent()), \"Query data for active target \" + c + \" not found\"), [4, this.localStore.allocateTarget(r)];\n\n              case 3:\n                return i = t.sent(), [4, this.initializeViewAndComputeSnapshot(this.synthesizeTargetToQuery(r), i.targetId, !1)];\n\n              case 4:\n                t.sent(), this.remoteStore.listen(i), t.label = 5;\n\n              case 5:\n                return e++, [3, 1];\n\n              case 6:\n                o = function (e) {\n                  return m(this, function (t) {\n                    switch (t.label) {\n                      case 0:\n                        return a.queriesByTarget[e] ? [4, a.localStore.releaseTarget(e, !1).then(function () {\n                          h.remoteStore.unlisten(e), h.removeAndCleanupTarget(e);\n                        }).catch(dc)] : [2, \"continue\"];\n\n                      case 1:\n                        return t.sent(), [2];\n                    }\n                  });\n                }, a = this, s = 0, u = f, t.label = 7;\n\n              case 7:\n                return s < u.length ? (c = u[s], [5, o(c)]) : [3, 10];\n\n              case 8:\n                t.sent(), t.label = 9;\n\n              case 9:\n                return s++, [3, 7];\n\n              case 10:\n                return [2];\n            }\n          });\n        });\n      }, Tf.prototype.enableNetwork = function () {\n        return this.localStore.setNetworkEnabled(!0), this.remoteStore.enableNetwork();\n      }, Tf.prototype.disableNetwork = function () {\n        return this.localStore.setNetworkEnabled(!1), this.remoteStore.disableNetwork();\n      }, Tf.prototype.getRemoteKeysForTarget = function (t) {\n        var e = this.limboResolutionsByTarget[t];\n        if (e && e.receivedDocument) return Oo().add(e.key);\n        var n = Oo(),\n            r = this.queriesByTarget[t];\n        if (!r) return n;\n\n        for (var i = 0, o = r; i < o.length; i++) {\n          var a = o[i],\n              s = this.queryViewsByQuery.get(a);\n          Ur(!!s, \"No query view found for \" + a), n = n.unionWith(s.view.syncedDocuments);\n        }\n\n        return n;\n      }, Tf);\n\n      function Tf(t, e, n, r) {\n        this.localStore = t, this.remoteStore = e, this.sharedClientState = n, this.currentUser = r, this.syncEngineListener = null, this.queryViewsByQuery = new zs(function (t) {\n          return t.canonicalId();\n        }), this.queriesByTarget = {}, this.limboTargetsByKey = new po(Wi.comparator), this.limboResolutionsByTarget = {}, this.limboDocumentRefs = new lh(), this.mutationUserCallbacks = {}, this.pendingWritesCallbacks = new Map(), this.limboTargetIdGenerator = la.forSyncEngine(), this.isPrimary = void 0, this.onlineState = Yh.Unknown;\n      }\n\n      var Sf = (Ef.prototype.isAuthenticated = function () {\n        return null != this.uid;\n      }, Ef.prototype.toKey = function () {\n        return this.isAuthenticated() ? \"uid:\" + this.uid : \"anonymous-user\";\n      }, Ef.prototype.isEqual = function (t) {\n        return t.uid === this.uid;\n      }, Ef.UNAUTHENTICATED = new Ef(null), Ef.GOOGLE_CREDENTIALS = new Ef(\"google-credentials-uid\"), Ef.FIRST_PARTY = new Ef(\"first-party-uid\"), Ef);\n\n      function Ef(t) {\n        this.uid = t;\n      }\n\n      var If = \"firestore_clients\";\n\n      function Cf(t, e) {\n        return Ur(-1 === e.indexOf(\"_\"), \"Client key cannot contain '_', but was '\" + e + \"'\"), If + \"_\" + t + \"_\" + e;\n      }\n\n      var Df = \"firestore_mutations\";\n\n      function Nf(t, e, n) {\n        var r = Df + \"_\" + t + \"_\" + n;\n        return e.isAuthenticated() && (r += \"_\" + e.uid), r;\n      }\n\n      var Af = \"firestore_targets\";\n\n      function kf(t, e) {\n        return Af + \"_\" + t + \"_\" + e;\n      }\n\n      var Rf = \"firestore_online_state\";\n      var Mf = \"firestore_sequence_number\";\n      var _f = \"SharedClientState\",\n          Lf = (Of.fromWebStorageEntry = function (t, e, n) {\n        var r = JSON.parse(n),\n            i = \"object\" == typeof r && -1 !== [\"pending\", \"acknowledged\", \"rejected\"].indexOf(r.state) && (void 0 === r.error || \"object\" == typeof r.error),\n            o = void 0;\n        return i && r.error && (i = \"string\" == typeof r.error.message && \"string\" == typeof r.error.code) && (o = new zr(r.error.code, r.error.message)), i ? new Of(t, e, r.state, o) : (qr(_f, \"Failed to parse mutation state for ID '\" + e + \"': \" + n), null);\n      }, Of.prototype.toWebStorageJSON = function () {\n        var t = {\n          state: this.state,\n          updateTimeMs: Date.now()\n        };\n        return this.error && (t.error = {\n          code: this.error.code,\n          message: this.error.message\n        }), JSON.stringify(t);\n      }, Of);\n\n      function Of(t, e, n, r) {\n        this.user = t, this.batchId = e, this.state = n, Ur(void 0 !== (this.error = r) == (\"rejected\" === n), \"MutationMetadata must contain an error iff state is 'rejected'\");\n      }\n\n      var Pf = (xf.fromWebStorageEntry = function (t, e) {\n        var n = JSON.parse(e),\n            r = \"object\" == typeof n && -1 !== [\"not-current\", \"current\", \"rejected\"].indexOf(n.state) && (void 0 === n.error || \"object\" == typeof n.error),\n            i = void 0;\n        return r && n.error && (r = \"string\" == typeof n.error.message && \"string\" == typeof n.error.code) && (i = new zr(n.error.code, n.error.message)), r ? new xf(t, n.state, i) : (qr(_f, \"Failed to parse target state for ID '\" + t + \"': \" + e), null);\n      }, xf.prototype.toWebStorageJSON = function () {\n        var t = {\n          state: this.state,\n          updateTimeMs: Date.now()\n        };\n        return this.error && (t.error = {\n          code: this.error.code,\n          message: this.error.message\n        }), JSON.stringify(t);\n      }, xf);\n\n      function xf(t, e, n) {\n        this.targetId = t, this.state = e, Ur(void 0 !== (this.error = n) == (\"rejected\" === e), \"QueryTargetMetadata must contain an error iff state is 'rejected'\");\n      }\n\n      var Ff = (qf.fromWebStorageEntry = function (t, e) {\n        for (var n = JSON.parse(e), r = \"object\" == typeof n && n.activeTargetIds instanceof Array, i = xo(), o = 0; r && o < n.activeTargetIds.length; ++o) r = Cc(n.activeTargetIds[o]), i = i.add(n.activeTargetIds[o]);\n\n        return r ? new qf(t, i) : (qr(_f, \"Failed to parse client data for instance '\" + t + \"': \" + e), null);\n      }, qf);\n\n      function qf(t, e) {\n        this.clientId = t, this.activeTargetIds = e;\n      }\n\n      var Vf = (Bf.fromWebStorageEntry = function (t) {\n        var e = JSON.parse(t);\n        return \"object\" == typeof e && e.onlineState in Yh && \"string\" == typeof e.clientId ? new Bf(e.clientId, Yh[e.onlineState]) : (qr(_f, \"Failed to parse online state: \" + t), null);\n      }, Bf);\n\n      function Bf(t, e) {\n        this.clientId = t, this.onlineState = e;\n      }\n\n      var Uf = (Kf.prototype.addQueryTarget = function (t) {\n        this.activeTargetIds = this.activeTargetIds.add(t);\n      }, Kf.prototype.removeQueryTarget = function (t) {\n        this.activeTargetIds = this.activeTargetIds.delete(t);\n      }, Kf.prototype.toWebStorageJSON = function () {\n        var t = {\n          activeTargetIds: this.activeTargetIds.toArray(),\n          updateTimeMs: Date.now()\n        };\n        return JSON.stringify(t);\n      }, Kf);\n\n      function Kf() {\n        this.activeTargetIds = xo();\n      }\n\n      var Qf = (jf.isAvailable = function (t) {\n        return !(!t.window || null == t.window.localStorage);\n      }, jf.prototype.start = function () {\n        return p(this, void 0, void 0, function () {\n          var e,\n              n,\n              r,\n              i,\n              o,\n              a,\n              s,\n              u,\n              c,\n              h,\n              l,\n              f = this;\n          return m(this, function (t) {\n            switch (t.label) {\n              case 0:\n                return Ur(!this.started, \"WebStorageSharedClientState already started\"), Ur(null !== this.syncEngine, \"syncEngine property must be set before calling start()\"), Ur(null !== this.onlineStateHandler, \"onlineStateHandler property must be set before calling start()\"), [4, this.syncEngine.getActiveClients()];\n\n              case 1:\n                for (e = t.sent(), n = 0, r = e; n < r.length; n++) (i = r[n]) !== this.localClientId && (o = this.getItem(Cf(this.persistenceKey, i))) && (a = Ff.fromWebStorageEntry(i, o)) && (this.activeClients[a.clientId] = a);\n\n                for (this.persistClientState(), (s = this.storage.getItem(this.onlineStateKey)) && (u = this.fromWebStorageOnlineState(s)) && this.handleOnlineStateEvent(u), c = 0, h = this.earlyEvents; c < h.length; c++) l = h[c], this.handleWebStorageEvent(l);\n\n                return this.earlyEvents = [], this.platform.window.addEventListener(\"unload\", function () {\n                  return f.shutdown();\n                }), this.started = !0, [2];\n            }\n          });\n        });\n      }, jf.prototype.writeSequenceNumber = function (t) {\n        this.setItem(this.sequenceNumberKey, JSON.stringify(t));\n      }, jf.prototype.getAllActiveQueryTargets = function () {\n        var n = xo();\n        return $r(this.activeClients, function (t, e) {\n          n = n.unionWith(e.activeTargetIds);\n        }), n;\n      }, jf.prototype.isActiveQueryTarget = function (t) {\n        for (var e in this.activeClients) if (this.activeClients.hasOwnProperty(e) && this.activeClients[e].activeTargetIds.has(t)) return !0;\n\n        return !1;\n      }, jf.prototype.addPendingMutation = function (t) {\n        this.persistMutationState(t, \"pending\");\n      }, jf.prototype.updateMutationState = function (t, e, n) {\n        this.persistMutationState(t, e, n), this.removeMutationState(t);\n      }, jf.prototype.addLocalQueryTarget = function (t) {\n        var e = \"not-current\";\n\n        if (this.isActiveQueryTarget(t)) {\n          var n = this.storage.getItem(kf(this.persistenceKey, t));\n\n          if (n) {\n            var r = Pf.fromWebStorageEntry(t, n);\n            r && (e = r.state);\n          }\n        }\n\n        return this.localClientState.addQueryTarget(t), this.persistClientState(), e;\n      }, jf.prototype.removeLocalQueryTarget = function (t) {\n        this.localClientState.removeQueryTarget(t), this.persistClientState();\n      }, jf.prototype.isLocalQueryTarget = function (t) {\n        return this.localClientState.activeTargetIds.has(t);\n      }, jf.prototype.clearQueryState = function (t) {\n        this.removeItem(kf(this.persistenceKey, t));\n      }, jf.prototype.updateQueryState = function (t, e, n) {\n        this.persistQueryTargetState(t, e, n);\n      }, jf.prototype.handleUserChange = function (t, e, n) {\n        var r = this;\n        e.forEach(function (t) {\n          r.removeMutationState(t);\n        }), this.currentUser = t, n.forEach(function (t) {\n          r.addPendingMutation(t);\n        });\n      }, jf.prototype.setOnlineState = function (t) {\n        this.persistOnlineState(t);\n      }, jf.prototype.shutdown = function () {\n        this.started && (this.platform.window.removeEventListener(\"storage\", this.storageListener), this.removeItem(this.localClientStorageKey), this.started = !1);\n      }, jf.prototype.getItem = function (t) {\n        var e = this.storage.getItem(t);\n        return Fr(_f, \"READ\", t, e), e;\n      }, jf.prototype.setItem = function (t, e) {\n        Fr(_f, \"SET\", t, e), this.storage.setItem(t, e);\n      }, jf.prototype.removeItem = function (t) {\n        Fr(_f, \"REMOVE\", t), this.storage.removeItem(t);\n      }, jf.prototype.handleWebStorageEvent = function (s) {\n        var t = this;\n\n        if (s.storageArea === this.storage) {\n          if (Fr(_f, \"EVENT\", s.key, s.newValue), s.key === this.localClientStorageKey) return void qr(\"Received WebStorage notification for local change. Another client might have garbage-collected our state\");\n          this.queue.enqueueAndForget(function () {\n            return p(t, void 0, void 0, function () {\n              var e, n, r, i, o, a;\n              return m(this, function (t) {\n                if (!this.started) return this.earlyEvents.push(s), [2];\n                if (null === s.key) return [2];\n\n                if (this.clientStateKeyRe.test(s.key)) {\n                  if (null == s.newValue) return n = this.fromWebStorageClientStateKey(s.key), [2, this.handleClientStateEvent(n, null)];\n                  if (e = this.fromWebStorageClientState(s.key, s.newValue)) return [2, this.handleClientStateEvent(e.clientId, e)];\n                } else if (this.mutationBatchKeyRe.test(s.key)) {\n                  if (null !== s.newValue && (r = this.fromWebStorageMutationMetadata(s.key, s.newValue))) return [2, this.handleMutationBatchEvent(r)];\n                } else if (this.queryTargetKeyRe.test(s.key)) {\n                  if (null !== s.newValue && (i = this.fromWebStorageQueryTargetMetadata(s.key, s.newValue))) return [2, this.handleQueryTargetEvent(i)];\n                } else if (s.key === this.onlineStateKey) {\n                  if (null !== s.newValue && (o = this.fromWebStorageOnlineState(s.newValue))) return [2, this.handleOnlineStateEvent(o)];\n                } else s.key === this.sequenceNumberKey && (Ur(!!this.sequenceNumberHandler, \"Missing sequenceNumberHandler\"), (a = function (t) {\n                  var e = Oi.INVALID;\n                  if (null != t) try {\n                    var n = JSON.parse(t);\n                    Ur(\"number\" == typeof n, \"Found non-numeric sequence number\"), e = n;\n                  } catch (t) {\n                    qr(_f, \"Failed to read sequence number from WebStorage\", t);\n                  }\n                  return e;\n                }(s.newValue)) !== Oi.INVALID && this.sequenceNumberHandler(a));\n\n                return [2];\n              });\n            });\n          });\n        }\n      }, Object.defineProperty(jf.prototype, \"localClientState\", {\n        get: function () {\n          return this.activeClients[this.localClientId];\n        },\n        enumerable: !0,\n        configurable: !0\n      }), jf.prototype.persistClientState = function () {\n        this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());\n      }, jf.prototype.persistMutationState = function (t, e, n) {\n        var r = new Lf(this.currentUser, t, e, n),\n            i = Nf(this.persistenceKey, this.currentUser, t);\n        this.setItem(i, r.toWebStorageJSON());\n      }, jf.prototype.removeMutationState = function (t) {\n        var e = Nf(this.persistenceKey, this.currentUser, t);\n        this.removeItem(e);\n      }, jf.prototype.persistOnlineState = function (t) {\n        var e = {\n          clientId: this.localClientId,\n          onlineState: Yh[t]\n        };\n        this.storage.setItem(this.onlineStateKey, JSON.stringify(e));\n      }, jf.prototype.persistQueryTargetState = function (t, e, n) {\n        var r = kf(this.persistenceKey, t),\n            i = new Pf(t, e, n);\n        this.setItem(r, i.toWebStorageJSON());\n      }, jf.prototype.fromWebStorageClientStateKey = function (t) {\n        var e = this.clientStateKeyRe.exec(t);\n        return e ? e[1] : null;\n      }, jf.prototype.fromWebStorageClientState = function (t, e) {\n        var n = this.fromWebStorageClientStateKey(t);\n        return Ur(null !== n, \"Cannot parse client state key '\" + t + \"'\"), Ff.fromWebStorageEntry(n, e);\n      }, jf.prototype.fromWebStorageMutationMetadata = function (t, e) {\n        var n = this.mutationBatchKeyRe.exec(t);\n        Ur(null !== n, \"Cannot parse mutation batch key '\" + t + \"'\");\n        var r = Number(n[1]),\n            i = void 0 !== n[2] ? n[2] : null;\n        return Lf.fromWebStorageEntry(new Sf(i), r, e);\n      }, jf.prototype.fromWebStorageQueryTargetMetadata = function (t, e) {\n        var n = this.queryTargetKeyRe.exec(t);\n        Ur(null !== n, \"Cannot parse query target key '\" + t + \"'\");\n        var r = Number(n[1]);\n        return Pf.fromWebStorageEntry(r, e);\n      }, jf.prototype.fromWebStorageOnlineState = function (t) {\n        return Vf.fromWebStorageEntry(t);\n      }, jf.prototype.handleMutationBatchEvent = function (e) {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            return e.user.uid !== this.currentUser.uid ? (Fr(_f, \"Ignoring mutation for non-active user \" + e.user.uid), [2]) : [2, this.syncEngine.applyBatchState(e.batchId, e.state, e.error)];\n          });\n        });\n      }, jf.prototype.handleQueryTargetEvent = function (t) {\n        return this.syncEngine.applyTargetState(t.targetId, t.state, t.error);\n      }, jf.prototype.handleClientStateEvent = function (t, e) {\n        var n = this,\n            r = this.getAllActiveQueryTargets();\n        e ? this.activeClients[t] = e : delete this.activeClients[t];\n        var i = this.getAllActiveQueryTargets(),\n            o = [],\n            a = [];\n        return i.forEach(function (e) {\n          return p(n, void 0, void 0, function () {\n            return m(this, function (t) {\n              return r.has(e) || o.push(e), [2];\n            });\n          });\n        }), r.forEach(function (e) {\n          return p(n, void 0, void 0, function () {\n            return m(this, function (t) {\n              return i.has(e) || a.push(e), [2];\n            });\n          });\n        }), this.syncEngine.applyActiveTargetsChange(o, a);\n      }, jf.prototype.handleOnlineStateEvent = function (t) {\n        this.activeClients[t.clientId] && this.onlineStateHandler(t.onlineState);\n      }, jf);\n\n      function jf(t, e, n, r, i) {\n        if (this.queue = t, this.platform = e, this.persistenceKey = n, this.localClientId = r, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.activeClients = {}, this.storageListener = this.handleWebStorageEvent.bind(this), this.started = !1, this.earlyEvents = [], !jf.isAvailable(this.platform)) throw new zr(Wr.UNIMPLEMENTED, \"LocalStorage is not available on this platform.\");\n        var o = n.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n        this.storage = this.platform.window.localStorage, this.currentUser = i, this.localClientStorageKey = Cf(this.persistenceKey, this.localClientId), this.sequenceNumberKey = function (t) {\n          return Mf + \"_\" + t;\n        }(this.persistenceKey), this.activeClients[this.localClientId] = new Uf(), this.clientStateKeyRe = new RegExp(\"^\" + If + \"_\" + o + \"_([^_]*)$\"), this.mutationBatchKeyRe = new RegExp(\"^\" + Df + \"_\" + o + \"_(\\\\d+)(?:_(.*))?$\"), this.queryTargetKeyRe = new RegExp(\"^\" + Af + \"_\" + o + \"_(\\\\d+)$\"), this.onlineStateKey = function (t) {\n          return Rf + \"_\" + t;\n        }(this.persistenceKey), this.platform.window.addEventListener(\"storage\", this.storageListener);\n      }\n\n      var Gf = (Wf.prototype.addPendingMutation = function (t) {}, Wf.prototype.updateMutationState = function (t, e, n) {}, Wf.prototype.addLocalQueryTarget = function (t) {\n        return this.localState.addQueryTarget(t), this.queryState[t] || \"not-current\";\n      }, Wf.prototype.updateQueryState = function (t, e, n) {\n        this.queryState[t] = e;\n      }, Wf.prototype.removeLocalQueryTarget = function (t) {\n        this.localState.removeQueryTarget(t);\n      }, Wf.prototype.isLocalQueryTarget = function (t) {\n        return this.localState.activeTargetIds.has(t);\n      }, Wf.prototype.clearQueryState = function (t) {\n        delete this.queryState[t];\n      }, Wf.prototype.getAllActiveQueryTargets = function () {\n        return this.localState.activeTargetIds;\n      }, Wf.prototype.isActiveQueryTarget = function (t) {\n        return this.localState.activeTargetIds.has(t);\n      }, Wf.prototype.start = function () {\n        return this.localState = new Uf(), Promise.resolve();\n      }, Wf.prototype.handleUserChange = function (t, e, n) {}, Wf.prototype.setOnlineState = function (t) {}, Wf.prototype.shutdown = function () {}, Wf.prototype.writeSequenceNumber = function (t) {}, Wf);\n\n      function Wf() {\n        this.localState = new Uf(), this.queryState = {}, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null;\n      }\n\n      var zf = \"FirestoreClient\",\n          Hf = (Yf.prototype.lruParams = function () {\n        return Zu.withCacheSize(this.cacheSizeBytes);\n      }, Yf);\n\n      function Yf(t, e) {\n        this.cacheSizeBytes = t, this.synchronizeTabs = e;\n      }\n\n      var Jf = function () {},\n          Xf = (Zf.prototype.start = function (t) {\n        var n = this;\n        this.verifyNotTerminated();\n        var r = new Ji(),\n            i = new Ji(),\n            o = !1;\n        return this.credentials.setChangeListener(function (e) {\n          o ? n.asyncQueue.enqueueAndForget(function () {\n            return n.handleCredentialChange(e);\n          }) : (o = !0, n.initializePersistence(t, i, e).then(function (t) {\n            return n.initializeRest(e, t);\n          }).then(r.resolve, r.reject));\n        }), this.asyncQueue.enqueueAndForget(function () {\n          return r.promise;\n        }), i.promise;\n      }, Zf.prototype.enableNetwork = function () {\n        var t = this;\n        return this.verifyNotTerminated(), this.asyncQueue.enqueue(function () {\n          return t.syncEngine.enableNetwork();\n        });\n      }, Zf.prototype.initializePersistence = function (t, e, n) {\n        var r = this;\n        return t instanceof Hf ? this.startIndexedDbPersistence(n, t).then(function (t) {\n          return e.resolve(), t;\n        }).catch(function (t) {\n          if (e.reject(t), !r.canFallback(t)) throw t;\n          return console.warn(\"Error enabling offline persistence. Falling back to persistence disabled: \" + t), r.startMemoryPersistence();\n        }) : (e.resolve(), this.startMemoryPersistence());\n      }, Zf.prototype.canFallback = function (t) {\n        return t instanceof zr ? t.code === Wr.FAILED_PRECONDITION || t.code === Wr.UNIMPLEMENTED : !(\"undefined\" != typeof DOMException && t instanceof DOMException) || 22 === t.code || 20 === t.code || 11 === t.code;\n      }, Zf.prototype.verifyNotTerminated = function () {\n        if (this.asyncQueue.isShuttingDown) throw new zr(Wr.FAILED_PRECONDITION, \"The client has already been terminated.\");\n      }, Zf.prototype.startIndexedDbPersistence = function (r, i) {\n        var t = this,\n            o = fc.buildStoragePrefix(this.databaseInfo),\n            a = new ef(this.databaseInfo.databaseId, {\n          useProto3Json: !0\n        });\n        return Promise.resolve().then(function () {\n          return p(t, void 0, void 0, function () {\n            var e, n;\n            return m(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  if (i.synchronizeTabs && !Qf.isAvailable(this.platform)) throw new zr(Wr.UNIMPLEMENTED, \"IndexedDB persistence is only available on platforms that support LocalStorage.\");\n                  return e = i.lruParams(), this.sharedClientState = i.synchronizeTabs ? new Qf(this.asyncQueue, this.platform, o, this.clientId, r) : new Gf(), [4, fc.createIndexedDbPersistence({\n                    allowTabSynchronization: i.synchronizeTabs,\n                    persistenceKey: o,\n                    clientId: this.clientId,\n                    platform: this.platform,\n                    queue: this.asyncQueue,\n                    serializer: a,\n                    lruParams: e,\n                    sequenceNumberSyncer: this.sharedClientState\n                  })];\n\n                case 1:\n                  return n = t.sent(), [2, (this.persistence = n).referenceDelegate.garbageCollector];\n              }\n            });\n          });\n        });\n      }, Zf.prototype.startMemoryPersistence = function () {\n        return this.persistence = Ch.createEagerPersistence(this.clientId), this.sharedClientState = new Gf(), Promise.resolve(null);\n      }, Zf.prototype.initializeRest = function (c, h) {\n        var t = this;\n        return Fr(zf, \"Initializing. user=\", c.uid), this.platform.loadConnection(this.databaseInfo).then(function (u) {\n          return p(t, void 0, void 0, function () {\n            var e,\n                n,\n                r,\n                i,\n                o,\n                a,\n                s = this;\n            return m(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return e = new sh(), this.localStore = new mh(this.persistence, e, c), [4, this.localStore.start()];\n\n                case 1:\n                  return t.sent(), h && (this.lruScheduler = new tc(h, this.asyncQueue, this.localStore)), n = this.platform.newConnectivityMonitor(), r = this.platform.newSerializer(this.databaseInfo.databaseId), i = new zh(this.asyncQueue, u, this.credentials, r), o = function (t) {\n                    return s.syncEngine.applyOnlineStateChange(t, Xh.RemoteStore);\n                  }, a = function (t) {\n                    return s.syncEngine.applyOnlineStateChange(t, Xh.SharedClientState);\n                  }, this.remoteStore = new Ll(this.localStore, i, this.asyncQueue, o, n), this.syncEngine = new wf(this.localStore, this.remoteStore, this.sharedClientState, c), this.sharedClientState.onlineStateHandler = a, this.remoteStore.syncEngine = this.syncEngine, this.sharedClientState.syncEngine = this.syncEngine, this.eventMgr = new of(this.syncEngine), [4, this.sharedClientState.start()];\n\n                case 2:\n                  return t.sent(), [4, this.remoteStore.start()];\n\n                case 3:\n                  return t.sent(), [4, this.persistence.setPrimaryStateListener(function (e) {\n                    return p(s, void 0, void 0, function () {\n                      return m(this, function (t) {\n                        switch (t.label) {\n                          case 0:\n                            return [4, this.syncEngine.applyPrimaryState(e)];\n\n                          case 1:\n                            return t.sent(), this.lruScheduler && (e && !this.lruScheduler.started ? this.lruScheduler.start() : e || this.lruScheduler.stop()), [2];\n                        }\n                      });\n                    });\n                  })];\n\n                case 4:\n                  return t.sent(), [4, this.persistence.setDatabaseDeletedListener(function () {\n                    return p(s, void 0, void 0, function () {\n                      return m(this, function (t) {\n                        switch (t.label) {\n                          case 0:\n                            return [4, this.terminate()];\n\n                          case 1:\n                            return t.sent(), [2];\n                        }\n                      });\n                    });\n                  })];\n\n                case 5:\n                  return t.sent(), [2];\n              }\n            });\n          });\n        });\n      }, Zf.prototype.handleCredentialChange = function (t) {\n        return this.asyncQueue.verifyOperationInProgress(), Fr(zf, \"Credential Changed. Current user: \" + t.uid), this.syncEngine.handleCredentialChange(t);\n      }, Zf.prototype.disableNetwork = function () {\n        var t = this;\n        return this.verifyNotTerminated(), this.asyncQueue.enqueue(function () {\n          return t.syncEngine.disableNetwork();\n        });\n      }, Zf.prototype.terminate = function () {\n        var t = this;\n        return this.asyncQueue.enqueueAndInitiateShutdown(function () {\n          return p(t, void 0, void 0, function () {\n            return m(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return this.lruScheduler && this.lruScheduler.stop(), [4, this.remoteStore.shutdown()];\n\n                case 1:\n                  return t.sent(), [4, this.sharedClientState.shutdown()];\n\n                case 2:\n                  return t.sent(), [4, this.persistence.shutdown()];\n\n                case 3:\n                  return t.sent(), this.credentials.removeChangeListener(), [2];\n              }\n            });\n          });\n        });\n      }, Zf.prototype.waitForPendingWrites = function () {\n        var t = this;\n        this.verifyNotTerminated();\n        var e = new Ji();\n        return this.asyncQueue.enqueueAndForget(function () {\n          return t.syncEngine.registerPendingWritesCallback(e);\n        }), e.promise;\n      }, Zf.prototype.listen = function (t, e, n) {\n        var r = this;\n        this.verifyNotTerminated();\n        var i = new sf(t, e, n);\n        return this.asyncQueue.enqueueAndForget(function () {\n          return r.eventMgr.listen(i);\n        }), i;\n      }, Zf.prototype.unlisten = function (t) {\n        var e = this;\n        this.clientTerminated || this.asyncQueue.enqueueAndForget(function () {\n          return e.eventMgr.unlisten(t);\n        });\n      }, Zf.prototype.getDocumentFromLocalCache = function (t) {\n        var e = this;\n        return this.verifyNotTerminated(), this.asyncQueue.enqueue(function () {\n          return e.localStore.readDocument(t);\n        }).then(function (t) {\n          if (t instanceof Vs) return t;\n          if (t instanceof Ks) return null;\n          throw new zr(Wr.UNAVAILABLE, \"Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)\");\n        });\n      }, Zf.prototype.getDocumentsFromLocalCache = function (i) {\n        var t = this;\n        return this.verifyNotTerminated(), this.asyncQueue.enqueue(function () {\n          return p(t, void 0, void 0, function () {\n            var e, n, r;\n            return m(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, this.localStore.executeQuery(i, !0)];\n\n                case 1:\n                  return e = t.sent(), n = new pf(i, e.remoteKeys), r = n.computeDocChanges(e.documents), [2, n.applyChanges(r, !1).snapshot];\n              }\n            });\n          });\n        });\n      }, Zf.prototype.write = function (t) {\n        var e = this;\n        this.verifyNotTerminated();\n        var n = new Ji();\n        return this.asyncQueue.enqueueAndForget(function () {\n          return e.syncEngine.write(t, n);\n        }), n.promise;\n      }, Zf.prototype.databaseId = function () {\n        return this.databaseInfo.databaseId;\n      }, Zf.prototype.addSnapshotsInSyncListener = function (t) {\n        var e = this;\n        this.verifyNotTerminated(), this.asyncQueue.enqueueAndForget(function () {\n          return e.eventMgr.addSnapshotsInSyncListener(t), Promise.resolve();\n        });\n      }, Zf.prototype.removeSnapshotsInSyncListener = function (t) {\n        this.clientTerminated || this.eventMgr.removeSnapshotsInSyncListener(t);\n      }, Object.defineProperty(Zf.prototype, \"clientTerminated\", {\n        get: function () {\n          return this.asyncQueue.isShuttingDown;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Zf.prototype.transaction = function (t) {\n        var e = this;\n        this.verifyNotTerminated();\n        var n = new Ji();\n        return this.asyncQueue.enqueueAndForget(function () {\n          return e.syncEngine.runTransaction(e.asyncQueue, t, n), Promise.resolve();\n        }), n.promise;\n      }, Zf);\n\n      function Zf(t, e, n, r) {\n        this.platform = t, this.databaseInfo = e, this.credentials = n, this.asyncQueue = r, this.clientId = wi.newId();\n      }\n\n      var $f = (tp.prototype.next = function (t) {\n        this.scheduleEvent(this.observer.next, t);\n      }, tp.prototype.error = function (t) {\n        this.scheduleEvent(this.observer.error, t);\n      }, tp.prototype.mute = function () {\n        this.muted = !0;\n      }, tp.prototype.scheduleEvent = function (t, e) {\n        var n = this;\n        this.muted || setTimeout(function () {\n          n.muted || t(e);\n        }, 0);\n      }, tp);\n\n      function tp(t) {\n        this.observer = t, this.muted = !1;\n      }\n\n      var ep = (np.documentId = function () {\n        return np._DOCUMENT_ID;\n      }, np.prototype.isEqual = function (t) {\n        if (!(t instanceof np)) throw yi(\"isEqual\", \"FieldPath\", 1, t);\n        return this._internalPath.isEqual(t._internalPath);\n      }, np._DOCUMENT_ID = new np(ji.keyField().canonicalString()), np);\n\n      function np() {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        !function (t, e, n, r) {\n          if (!(e instanceof Array) || e.length < r) throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() requires its \" + n + \" argument to be an array with at least \" + bi(r, \"element\") + \".\");\n        }(\"FieldPath\", t, \"fieldNames\", 1);\n\n        for (var n = 0; n < t.length; ++n) if (oi(\"FieldPath\", \"string\", n, t[n]), 0 === t[n].length) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid field name at argument $(i + 1). Field names must not be empty.\");\n\n        this._internalPath = new ji(t);\n      }\n\n      var rp = new RegExp(\"[~\\\\*/\\\\[\\\\]]\");\n\n      var ip = function (t, e) {\n        this.user = e, this.type = \"OAuth\", this.authHeaders = {}, this.authHeaders.Authorization = \"Bearer \" + t;\n      },\n          op = (ap.prototype.getToken = function () {\n        return Promise.resolve(null);\n      }, ap.prototype.invalidateToken = function () {}, ap.prototype.setChangeListener = function (t) {\n        Ur(!this.changeListener, \"Can only call setChangeListener() once.\"), (this.changeListener = t)(Sf.UNAUTHENTICATED);\n      }, ap.prototype.removeChangeListener = function () {\n        Ur(null !== this.changeListener, \"removeChangeListener() when no listener registered\"), this.changeListener = null;\n      }, ap);\n\n      function ap() {\n        this.changeListener = null;\n      }\n\n      var sp = (up.prototype.getToken = function () {\n        var e = this;\n        Ur(null != this.tokenListener, \"getToken cannot be called after listener removed.\");\n        var n = this.tokenCounter,\n            t = this.forceRefresh;\n        return this.forceRefresh = !1, this.auth ? this.auth.getToken(t).then(function (t) {\n          if (e.tokenCounter !== n) throw new zr(Wr.ABORTED, \"getToken aborted due to token change.\");\n          return t ? (Ur(\"string\" == typeof t.accessToken, \"Invalid tokenData returned from getToken():\" + t), new ip(t.accessToken, e.currentUser)) : null;\n        }) : Promise.resolve(null);\n      }, up.prototype.invalidateToken = function () {\n        this.forceRefresh = !0;\n      }, up.prototype.setChangeListener = function (t) {\n        Ur(!this.changeListener, \"Can only call setChangeListener() once.\"), this.changeListener = t, this.receivedInitialUser && t(this.currentUser);\n      }, up.prototype.removeChangeListener = function () {\n        Ur(null != this.tokenListener, \"removeChangeListener() called twice\"), Ur(null !== this.changeListener, \"removeChangeListener() called when no listener registered\"), this.auth && this.auth.removeAuthTokenListener(this.tokenListener), this.tokenListener = null, this.changeListener = null;\n      }, up.prototype.getUser = function () {\n        var t = this.auth && this.auth.getUid();\n        return Ur(null === t || \"string\" == typeof t, \"Received invalid UID: \" + t), new Sf(t);\n      }, up);\n\n      function up(t) {\n        var e = this;\n        this.tokenListener = null, this.currentUser = Sf.UNAUTHENTICATED, this.receivedInitialUser = !1, this.tokenCounter = 0, this.changeListener = null, this.forceRefresh = !1, this.tokenListener = function () {\n          e.tokenCounter++, e.currentUser = e.getUser(), e.receivedInitialUser = !0, e.changeListener && e.changeListener(e.currentUser);\n        }, this.tokenCounter = 0, this.auth = t.getImmediate({\n          optional: !0\n        }), this.auth ? this.auth.addAuthTokenListener(this.tokenListener) : (this.tokenListener(null), t.get().then(function (t) {\n          e.auth = t, e.tokenListener && e.auth.addAuthTokenListener(e.tokenListener);\n        }, function () {}));\n      }\n\n      var cp = (Object.defineProperty(hp.prototype, \"authHeaders\", {\n        get: function () {\n          var t = {\n            \"X-Goog-AuthUser\": this.sessionIndex\n          },\n              e = this.gapi.auth.getAuthHeaderValueForFirstParty([]);\n          return e && (t.Authorization = e), t;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), hp);\n\n      function hp(t, e) {\n        this.gapi = t, this.sessionIndex = e, this.type = \"FirstParty\", this.user = Sf.FIRST_PARTY;\n      }\n\n      var lp = (fp.prototype.getToken = function () {\n        return Promise.resolve(new cp(this.gapi, this.sessionIndex));\n      }, fp.prototype.setChangeListener = function (t) {\n        t(Sf.FIRST_PARTY);\n      }, fp.prototype.removeChangeListener = function () {}, fp.prototype.invalidateToken = function () {}, fp);\n\n      function fp(t, e) {\n        this.gapi = t, this.sessionIndex = e;\n      }\n\n      function pp(t) {\n        return function (t, e) {\n          if (\"object\" != typeof t || null === t) return !1;\n\n          for (var n = t, r = 0, i = e; r < i.length; r++) {\n            var o = i[r];\n            if (o in n && \"function\" == typeof n[o]) return !0;\n          }\n\n          return !1;\n        }(t, [\"next\", \"error\", \"complete\"]);\n      }\n\n      var dp = (mp.delete = function () {\n        return ei(\"FieldValue.delete\", arguments), gp.instance;\n      }, mp.serverTimestamp = function () {\n        return ei(\"FieldValue.serverTimestamp\", arguments), wp.instance;\n      }, mp.arrayUnion = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        return ri(\"FieldValue.arrayUnion\", arguments, 1), new Ep(t);\n      }, mp.arrayRemove = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        return ri(\"FieldValue.arrayRemove\", arguments, 1), new Dp(t);\n      }, mp.increment = function (t) {\n        return oi(\"FieldValue.increment\", \"number\", 1, t), ni(\"FieldValue.increment\", arguments, 1), new kp(t);\n      }, mp.prototype.isEqual = function (t) {\n        return this === t;\n      }, mp);\n\n      function mp(t) {\n        this._methodName = t;\n      }\n\n      var yp,\n          gp = (t(vp, yp = dp), vp.instance = new vp(), vp);\n\n      function vp() {\n        return yp.call(this, \"FieldValue.delete\") || this;\n      }\n\n      var bp,\n          wp = (t(Tp, bp = dp), Tp.instance = new Tp(), Tp);\n\n      function Tp() {\n        return bp.call(this, \"FieldValue.serverTimestamp\") || this;\n      }\n\n      var Sp,\n          Ep = (t(Ip, Sp = dp), Ip);\n\n      function Ip(t) {\n        var e = Sp.call(this, \"FieldValue.arrayUnion\") || this;\n        return e._elements = t, e;\n      }\n\n      var Cp,\n          Dp = (t(Np, Cp = dp), Np);\n\n      function Np(t) {\n        var e = Cp.call(this, \"FieldValue.arrayRemove\") || this;\n        return e._elements = t, e;\n      }\n\n      var Ap,\n          kp = (t(Rp, Ap = dp), Rp);\n\n      function Rp(t) {\n        var e = Ap.call(this, \"FieldValue.increment\") || this;\n        return e._operand = t, e;\n      }\n\n      var Mp = Yr(dp, \"Use FieldValue.<field>() instead.\"),\n          _p = /^__.*__$/,\n          Lp = (Op.prototype.toMutations = function (t, e) {\n        var n = [];\n        return null !== this.fieldMask ? n.push(new Oa(t, this.data, this.fieldMask, e)) : n.push(new Ma(t, this.data, e)), 0 < this.fieldTransforms.length && n.push(new Fa(t, this.fieldTransforms)), n;\n      }, Op);\n\n      function Op(t, e, n) {\n        this.data = t, this.fieldMask = e, this.fieldTransforms = n;\n      }\n\n      var Pp,\n          xp,\n          Fp = (qp.prototype.toMutations = function (t, e) {\n        var n = [new Oa(t, this.data, this.fieldMask, e)];\n        return 0 < this.fieldTransforms.length && n.push(new Fa(t, this.fieldTransforms)), n;\n      }, qp);\n\n      function qp(t, e, n) {\n        this.data = t, this.fieldMask = e, this.fieldTransforms = n;\n      }\n\n      function Vp(t) {\n        switch (t) {\n          case Pp.Set:\n          case Pp.MergeSet:\n          case Pp.Update:\n            return !0;\n\n          case Pp.Argument:\n          case Pp.ArrayArgument:\n            return !1;\n\n          default:\n            throw Br(\"Unexpected case for UserDataSource: \" + t);\n        }\n      }\n\n      (xp = Pp = Pp || {})[xp.Set = 0] = \"Set\", xp[xp.Update = 1] = \"Update\", xp[xp.MergeSet = 2] = \"MergeSet\", xp[xp.Argument = 3] = \"Argument\", xp[xp.ArrayArgument = 4] = \"ArrayArgument\";\n      var Bp = (Up.prototype.childContextForField = function (t) {\n        var e = null == this.path ? null : this.path.child(t),\n            n = new Up(this.dataSource, this.methodName, e, !1, this.fieldTransforms, this.fieldMask);\n        return n.validatePathSegment(t), n;\n      }, Up.prototype.childContextForFieldPath = function (t) {\n        var e = null == this.path ? null : this.path.child(t),\n            n = new Up(this.dataSource, this.methodName, e, !1, this.fieldTransforms, this.fieldMask);\n        return n.validatePath(), n;\n      }, Up.prototype.childContextForArray = function (t) {\n        return new Up(this.dataSource, this.methodName, null, !0, this.fieldTransforms, this.fieldMask);\n      }, Up.prototype.createError = function (t) {\n        var e = null === this.path || this.path.isEmpty() ? \"\" : \" (found in field \" + this.path.toString() + \")\";\n        return new zr(Wr.INVALID_ARGUMENT, \"Function \" + this.methodName + \"() called with invalid data. \" + t + e);\n      }, Up.prototype.contains = function (e) {\n        return void 0 !== this.fieldMask.find(function (t) {\n          return e.isPrefixOf(t);\n        }) || void 0 !== this.fieldTransforms.find(function (t) {\n          return e.isPrefixOf(t.field);\n        });\n      }, Up.prototype.validatePath = function () {\n        if (null !== this.path) for (var t = 0; t < this.path.length; t++) this.validatePathSegment(this.path.get(t));\n      }, Up.prototype.validatePathSegment = function (t) {\n        if (0 === t.length) throw this.createError(\"Document fields must not be empty\");\n        if (Vp(this.dataSource) && _p.test(t)) throw this.createError('Document fields cannot begin and end with \"__\"');\n      }, Up);\n\n      function Up(t, e, n, r, i, o) {\n        this.dataSource = t, this.methodName = e, this.path = n, this.arrayElement = r, void 0 === i && this.validatePath(), this.arrayElement = void 0 !== r && r, this.fieldTransforms = i || [], this.fieldMask = o || [];\n      }\n\n      var Kp = function (t, e) {\n        this.databaseId = t, this.key = e;\n      },\n          Qp = (jp.prototype.parseSetData = function (t, e) {\n        var n = new Bp(Pp.Set, t, ji.EMPTY_PATH);\n        Wp(\"Data must be an object, but it was:\", n, e);\n        var r = this.parseData(e, n);\n        return new Lp(r, null, n.fieldTransforms);\n      }, jp.prototype.parseMergeData = function (t, e, n) {\n        var r = new Bp(Pp.MergeSet, t, ji.EMPTY_PATH);\n        Wp(\"Data must be an object, but it was:\", r, e);\n        var i,\n            o,\n            a = this.parseData(e, r);\n\n        if (n) {\n          for (var s = new So(ji.comparator), u = 0, c = n; u < c.length; u++) {\n            var h = c[u],\n                l = void 0;\n            if (h instanceof ep) l = h._internalPath;else {\n              if (\"string\" != typeof h) throw Br(\"Expected stringOrFieldPath to be a string or a FieldPath\");\n              l = Hp(t, h);\n            }\n            if (!r.contains(l)) throw new zr(Wr.INVALID_ARGUMENT, \"Field '\" + l + \"' is specified in your field mask but missing from your input data.\");\n            s = s.add(l);\n          }\n\n          i = ba.fromSet(s), o = r.fieldTransforms.filter(function (t) {\n            return i.covers(t.field);\n          });\n        } else i = ba.fromArray(r.fieldMask), o = r.fieldTransforms;\n\n        return new Lp(a, i, o);\n      }, jp.prototype.parseUpdateData = function (o, t) {\n        var a = this,\n            s = new Bp(Pp.Update, o, ji.EMPTY_PATH);\n        Wp(\"Data must be an object, but it was:\", s, t);\n        var u = new So(ji.comparator),\n            c = Ms.EMPTY;\n        $r(t, function (t, e) {\n          var n = Hp(o, t),\n              r = s.childContextForFieldPath(n);\n          if ((e = a.runPreConverter(e, r)) instanceof gp) u = u.add(n);else {\n            var i = a.parseData(e, r);\n            null != i && (u = u.add(n), c = c.set(n, i));\n          }\n        });\n        var e = ba.fromSet(u);\n        return new Fp(c, e, s.fieldTransforms);\n      }, jp.prototype.parseUpdateVarargs = function (t, e, n, r) {\n        var i = new Bp(Pp.Update, t, ji.EMPTY_PATH),\n            o = [zp(t, e)],\n            a = [n];\n        if (r.length % 2 != 0) throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() needs to be called with an even number of arguments that alternate between field names and values.\");\n\n        for (var s = 0; s < r.length; s += 2) o.push(zp(t, r[s])), a.push(r[s + 1]);\n\n        var u = new So(ji.comparator),\n            c = Ms.EMPTY;\n\n        for (s = 0; s < o.length; ++s) {\n          var h = o[s],\n              l = i.childContextForFieldPath(h),\n              f = this.runPreConverter(a[s], l);\n          if (f instanceof gp) u = u.add(h);else {\n            var p = this.parseData(f, l);\n            null != p && (u = u.add(h), c = c.set(h, p));\n          }\n        }\n\n        var d = ba.fromSet(u);\n        return new Fp(c, d, i.fieldTransforms);\n      }, jp.prototype.parseQueryValue = function (t, e, n) {\n        void 0 === n && (n = !1);\n        var r = new Bp(n ? Pp.ArrayArgument : Pp.Argument, t, ji.EMPTY_PATH),\n            i = this.parseData(e, r);\n        return Ur(null != i, \"Parsed data should not be null.\"), Ur(0 === r.fieldTransforms.length, \"Field transforms should have been disallowed.\"), i;\n      }, jp.prototype.runPreConverter = function (t, e) {\n        try {\n          return this.preConverter(t);\n        } catch (t) {\n          var n = Yp(t);\n          throw e.createError(n);\n        }\n      }, jp.prototype.parseData = function (t, e) {\n        if (Gp(t = this.runPreConverter(t, e))) return Wp(\"Unsupported field value:\", e, t), this.parseObject(t, e);\n        if (t instanceof dp) return this.parseSentinelFieldValue(t, e), null;\n\n        if (e.path && e.fieldMask.push(e.path), t instanceof Array) {\n          if (e.arrayElement && e.dataSource !== Pp.ArrayArgument) throw e.createError(\"Nested arrays are not supported\");\n          return this.parseArray(t, e);\n        }\n\n        return this.parseScalarValue(t, e);\n      }, jp.prototype.parseObject = function (t, r) {\n        var i = this,\n            o = new po(Si);\n        return ti(t) ? r.path && 0 < r.path.length && r.fieldMask.push(r.path) : $r(t, function (t, e) {\n          var n = i.parseData(e, r.childContextForField(t));\n          null != n && (o = o.insert(t, n));\n        }), new Ms(o);\n      }, jp.prototype.parseArray = function (t, e) {\n        for (var n = [], r = 0, i = 0, o = t; i < o.length; i++) {\n          var a = o[i],\n              s = this.parseData(a, e.childContextForArray(r));\n          null == s && (s = Xa.INSTANCE), n.push(s), r++;\n        }\n\n        return new Os(n);\n      }, jp.prototype.parseSentinelFieldValue = function (t, e) {\n        if (!Vp(e.dataSource)) throw e.createError(t._methodName + \"() can only be used with update() and set()\");\n        if (null === e.path) throw e.createError(t._methodName + \"() is not currently supported inside arrays\");\n\n        if (t instanceof gp) {\n          if (e.dataSource !== Pp.MergeSet) throw e.dataSource === Pp.Update ? (Ur(0 < e.path.length, \"FieldValue.delete() at the top level should have already been handled.\"), e.createError(\"FieldValue.delete() can only appear at the top level of your update data\")) : e.createError(\"FieldValue.delete() cannot be used with set() unless you pass {merge:true}\");\n          e.fieldMask.push(e.path);\n        } else if (t instanceof wp) e.fieldTransforms.push(new Ta(e.path, Fl.instance));else if (t instanceof Ep) {\n          var n = this.parseArrayTransformElements(t._methodName, t._elements),\n              r = new Vl(n);\n          e.fieldTransforms.push(new Ta(e.path, r));\n        } else if (t instanceof Dp) {\n          n = this.parseArrayTransformElements(t._methodName, t._elements);\n          var i = new Ul(n);\n          e.fieldTransforms.push(new Ta(e.path, i));\n        } else if (t instanceof kp) {\n          var o = this.parseQueryValue(\"FieldValue.increment\", t._operand),\n              a = new Ql(o);\n          e.fieldTransforms.push(new Ta(e.path, a));\n        } else Br(\"Unknown FieldValue type: \" + t);\n      }, jp.prototype.parseScalarValue = function (t, e) {\n        if (null === t) return Xa.INSTANCE;\n        if (\"number\" == typeof t) return Cc(t) ? new ss(t) : new hs(t);\n        if (\"boolean\" == typeof t) return ts.of(t);\n        if (\"string\" == typeof t) return new ps(t);\n        if (t instanceof Date) return new ys(co.fromDate(t));\n        if (t instanceof co) return new ys(new co(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3)));\n        if (t instanceof Pl) return new As(t);\n        if (t instanceof Ni) return new Ss(t);\n        if (t instanceof Kp) return new Cs(t.databaseId, t.key);\n        throw e.createError(\"Unsupported field value: \" + pi(t));\n      }, jp.prototype.parseArrayTransformElements = function (r, t) {\n        var i = this;\n        return t.map(function (t, e) {\n          var n = new Bp(Pp.Argument, r, ji.EMPTY_PATH);\n          return i.parseData(t, n.childContextForArray(e));\n        });\n      }, jp);\n\n      function jp(t) {\n        this.preConverter = t;\n      }\n\n      function Gp(t) {\n        return !(\"object\" != typeof t || null === t || t instanceof Array || t instanceof Date || t instanceof co || t instanceof Pl || t instanceof Ni || t instanceof Kp || t instanceof dp);\n      }\n\n      function Wp(t, e, n) {\n        if (!Gp(n) || !fi(n)) {\n          var r = pi(n);\n          throw \"an object\" === r ? e.createError(t + \" a custom object\") : e.createError(t + \" \" + r);\n        }\n      }\n\n      function zp(t, e) {\n        if (e instanceof ep) return e._internalPath;\n        if (\"string\" == typeof e) return Hp(t, e);\n        throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + t + \"() called with invalid data. Field path arguments must be of type string or FieldPath.\");\n      }\n\n      function Hp(e, t) {\n        try {\n          return function (e) {\n            if (0 <= e.search(rp)) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid field path (\" + e + \"). Paths must not contain '~', '*', '/', '[', or ']'\");\n\n            try {\n              return new (ep.bind.apply(ep, a([void 0], e.split(\".\"))))();\n            } catch (t) {\n              throw new zr(Wr.INVALID_ARGUMENT, \"Invalid field path (\" + e + \"). Paths must not be empty, begin with '.', end with '.', or contain '..'\");\n            }\n          }(t)._internalPath;\n        } catch (t) {\n          var n = Yp(t);\n          throw new zr(Wr.INVALID_ARGUMENT, \"Function \" + e + \"() called with invalid data. \" + n);\n        }\n      }\n\n      function Yp(t) {\n        return t instanceof Error ? t.message : t.toString();\n      }\n\n      var Jp = Zu.COLLECTION_DISABLED,\n          Xp = (Zp.prototype.isEqual = function (t) {\n        return this.host === t.host && this.ssl === t.ssl && this.timestampsInSnapshots === t.timestampsInSnapshots && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes && this.forceLongPolling === t.forceLongPolling;\n      }, Zp);\n\n      function Zp(t) {\n        if (void 0 === t.host) {\n          if (void 0 !== t.ssl) throw new zr(Wr.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n          this.host = \"firestore.googleapis.com\", this.ssl = !0;\n        } else si(\"settings\", \"non-empty string\", \"host\", t.host), this.host = t.host, ui(\"settings\", \"boolean\", \"ssl\", t.ssl), this.ssl = Xr(t.ssl, !0);\n\n        if (mi(\"settings\", t, [\"host\", \"ssl\", \"credentials\", \"timestampsInSnapshots\", \"cacheSizeBytes\", \"experimentalForceLongPolling\"]), ui(\"settings\", \"object\", \"credentials\", t.credentials), this.credentials = t.credentials, ui(\"settings\", \"boolean\", \"timestampsInSnapshots\", t.timestampsInSnapshots), !0 === t.timestampsInSnapshots ? qr(\"\\n  The timestampsInSnapshots setting now defaults to true and you no\\n  longer need to explicitly set it. In a future release, the setting\\n  will be removed entirely and so it is recommended that you remove it\\n  from your firestore.settings() call now.\") : !1 === t.timestampsInSnapshots && qr(\"\\n  The timestampsInSnapshots setting will soon be removed. YOU MUST UPDATE\\n  YOUR CODE.\\n\\n  To hide this warning, stop using the timestampsInSnapshots setting in your\\n  firestore.settings({ ... }) call.\\n\\n  Once you remove the setting, Timestamps stored in Cloud Firestore will be\\n  read back as Firebase Timestamp objects instead of as system Date objects.\\n  So you will also need to update code expecting a Date to instead expect a\\n  Timestamp. For example:\\n\\n  // Old:\\n  const date = snapshot.get('created_at');\\n  // New:\\n  const timestamp = snapshot.get('created_at'); const date =\\n  timestamp.toDate();\\n\\n  Please audit all existing usages of Date when you enable the new\\n  behavior.\"), this.timestampsInSnapshots = Xr(t.timestampsInSnapshots, !0), ui(\"settings\", \"number\", \"cacheSizeBytes\", t.cacheSizeBytes), void 0 === t.cacheSizeBytes) this.cacheSizeBytes = Zu.DEFAULT_CACHE_SIZE_BYTES;else {\n          if (t.cacheSizeBytes !== Jp && t.cacheSizeBytes < Zu.MINIMUM_CACHE_SIZE_BYTES) throw new zr(Wr.INVALID_ARGUMENT, \"cacheSizeBytes must be at least \" + Zu.MINIMUM_CACHE_SIZE_BYTES);\n          this.cacheSizeBytes = t.cacheSizeBytes;\n        }\n        ui(\"settings\", \"boolean\", \"experimentalForceLongPolling\", t.experimentalForceLongPolling), this.forceLongPolling = void 0 !== t.experimentalForceLongPolling && t.experimentalForceLongPolling;\n      }\n\n      var $p = (td.prototype.settings = function (t) {\n        if (ni(\"Firestore.settings\", arguments, 1), oi(\"Firestore.settings\", \"object\", 1, t), Jr(t, \"persistence\")) throw new zr(Wr.INVALID_ARGUMENT, '\"persistence\" is now specified with a separate call to firestore.enablePersistence().');\n        var e = new Xp(t);\n        if (this._firestoreClient && !this._settings.isEqual(e)) throw new zr(Wr.FAILED_PRECONDITION, \"Firestore has already been started and its settings can no longer be changed. You can only call settings() before calling any other methods on a Firestore object.\");\n        void 0 !== (this._settings = e).credentials && (this._credentials = function (t) {\n          if (!t) return new op();\n\n          switch (t.type) {\n            case \"gapi\":\n              var e = t.client;\n              return Ur(!(\"object\" != typeof e || null === e || !e.auth || !e.auth.getAuthHeaderValueForFirstParty), \"unexpected gapi interface\"), new lp(e, t.sessionIndex || \"0\");\n\n            case \"provider\":\n              return t.client;\n\n            default:\n              throw new zr(Wr.INVALID_ARGUMENT, \"makeCredentialsProvider failed due to invalid credential type\");\n          }\n        }(e.credentials));\n      }, td.prototype.enableNetwork = function () {\n        return this.ensureClientConfigured(), this._firestoreClient.enableNetwork();\n      }, td.prototype.disableNetwork = function () {\n        return this.ensureClientConfigured(), this._firestoreClient.disableNetwork();\n      }, td.prototype.enablePersistence = function (t) {\n        if (this._firestoreClient) throw new zr(Wr.FAILED_PRECONDITION, \"Firestore has already been started and persistence can no longer be enabled. You can only call enablePersistence() before calling any other methods on a Firestore object.\");\n        var e = !1;\n        return t && (void 0 !== t.experimentalTabSynchronization && qr(\"The 'experimentalTabSynchronization' setting has been renamed to 'synchronizeTabs'. In a future release, the setting will be removed and it is recommended that you update your firestore.enablePersistence() call to use 'synchronizeTabs'.\"), e = Xr(void 0 !== t.synchronizeTabs ? t.synchronizeTabs : t.experimentalTabSynchronization, !1)), this.configureClient(new Hf(this._settings.cacheSizeBytes, e));\n      }, td.prototype.clearPersistence = function () {\n        var t = this,\n            n = fc.buildStoragePrefix(this.makeDatabaseInfo()),\n            r = new Ji();\n        return this._queue.enqueueAndForgetEvenAfterShutdown(function () {\n          return p(t, void 0, void 0, function () {\n            var e;\n            return m(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  if (t.trys.push([0, 2,, 3]), void 0 !== this._firestoreClient && !this._firestoreClient.clientTerminated) throw new zr(Wr.FAILED_PRECONDITION, \"Persistence cannot be cleared after this Firestore instance is initialized.\");\n                  return [4, fc.clearPersistence(n)];\n\n                case 1:\n                  return t.sent(), r.resolve(), [3, 3];\n\n                case 2:\n                  return e = t.sent(), r.reject(e), [3, 3];\n\n                case 3:\n                  return [2];\n              }\n            });\n          });\n        }), r.promise;\n      }, td.prototype.terminate = function () {\n        return this.app._removeServiceInstance(\"firestore\"), this.INTERNAL.delete();\n      }, Object.defineProperty(td.prototype, \"_isTerminated\", {\n        get: function () {\n          return this.ensureClientConfigured(), this._firestoreClient.clientTerminated;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), td.prototype.waitForPendingWrites = function () {\n        return this.ensureClientConfigured(), this._firestoreClient.waitForPendingWrites();\n      }, td.prototype.onSnapshotsInSync = function (t) {\n        if (this.ensureClientConfigured(), pp(t)) return this.onSnapshotsInSyncInternal(t);\n        oi(\"Firestore.onSnapshotsInSync\", \"function\", 1, t);\n        var e = {\n          next: t\n        };\n        return this.onSnapshotsInSyncInternal(e);\n      }, td.prototype.onSnapshotsInSyncInternal = function (t) {\n        var e = this,\n            n = new $f({\n          next: function () {\n            t.next && t.next();\n          },\n          error: function (t) {\n            throw Br(\"Uncaught Error in onSnapshotsInSync\");\n          }\n        });\n        return this._firestoreClient.addSnapshotsInSyncListener(n), function () {\n          n.mute(), e._firestoreClient.removeSnapshotsInSyncListener(n);\n        };\n      }, td.prototype.ensureClientConfigured = function () {\n        return this._firestoreClient || this.configureClient(new Jf()), this._firestoreClient;\n      }, td.prototype.makeDatabaseInfo = function () {\n        return new Ri(this._databaseId, this._persistenceKey, this._settings.host, this._settings.ssl, this._settings.forceLongPolling);\n      }, td.prototype.configureClient = function (t) {\n        Ur(!!this._settings.host, \"FirestoreSettings.host is not set\"), Ur(!this._firestoreClient, \"configureClient() called multiple times\");\n        var e = this.makeDatabaseInfo();\n        return this._firestoreClient = new Xf(Kr.getPlatform(), e, this._credentials, this._queue), this._firestoreClient.start(t);\n      }, td.prototype.createDataConverter = function (r) {\n        return new Qp(function (t) {\n          if (t instanceof od) {\n            var e = r,\n                n = t.firestore._databaseId;\n            if (!n.isEqual(e)) throw new zr(Wr.INVALID_ARGUMENT, \"Document reference is for database \" + n.projectId + \"/\" + n.database + \" but should be for database \" + e.projectId + \"/\" + e.database);\n            return new Kp(r, t._key);\n          }\n\n          return t;\n        });\n      }, td.databaseIdFromApp = function (t) {\n        var e = t.options;\n        if (!Jr(e, \"projectId\")) throw new zr(Wr.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n        var n = e.projectId;\n        if (!n || \"string\" != typeof n) throw new zr(Wr.INVALID_ARGUMENT, \"projectId must be a string in FirebaseApp.options\");\n        return new _i(n);\n      }, Object.defineProperty(td.prototype, \"app\", {\n        get: function () {\n          if (!this._firebaseApp) throw new zr(Wr.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is not available\");\n          return this._firebaseApp;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), td.prototype.collection = function (t) {\n        return ni(\"Firestore.collection\", arguments, 1), oi(\"Firestore.collection\", \"non-empty string\", 1, t), this.ensureClientConfigured(), new bd(Bi.fromString(t), this);\n      }, td.prototype.doc = function (t) {\n        return ni(\"Firestore.doc\", arguments, 1), oi(\"Firestore.doc\", \"non-empty string\", 1, t), this.ensureClientConfigured(), od.forPath(Bi.fromString(t), this);\n      }, td.prototype.collectionGroup = function (t) {\n        if (ni(\"Firestore.collectionGroup\", arguments, 1), oi(\"Firestore.collectionGroup\", \"non-empty string\", 1, t), 0 <= t.indexOf(\"/\")) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid collection ID '\" + t + \"' passed to function Firestore.collectionGroup(). Collection IDs must not contain '/'.\");\n        return this.ensureClientConfigured(), new dd(new Rc(Bi.EMPTY_PATH, t), this);\n      }, td.prototype.runTransaction = function (e) {\n        var n = this;\n        return ni(\"Firestore.runTransaction\", arguments, 1), oi(\"Firestore.runTransaction\", \"function\", 1, e), this.ensureClientConfigured().transaction(function (t) {\n          return e(new ed(n, t));\n        });\n      }, td.prototype.batch = function () {\n        return this.ensureClientConfigured(), new rd(this);\n      }, Object.defineProperty(td, \"logLevel\", {\n        get: function () {\n          switch (Pr()) {\n            case Cr.DEBUG:\n              return \"debug\";\n\n            case Cr.ERROR:\n              return \"error\";\n\n            case Cr.SILENT:\n              return \"silent\";\n\n            default:\n              return Br(\"Unknown log level: \" + Pr());\n          }\n        },\n        enumerable: !0,\n        configurable: !0\n      }), td.setLogLevel = function (t) {\n        switch (ni(\"Firestore.setLogLevel\", arguments, 1), oi(\"Firestore.setLogLevel\", \"non-empty string\", 1, t), t) {\n          case \"debug\":\n            xr(Cr.DEBUG);\n            break;\n\n          case \"error\":\n            xr(Cr.ERROR);\n            break;\n\n          case \"silent\":\n            xr(Cr.SILENT);\n            break;\n\n          default:\n            throw new zr(Wr.INVALID_ARGUMENT, \"Invalid log level: \" + t);\n        }\n      }, td.prototype._areTimestampsInSnapshotsEnabled = function () {\n        return this._settings.timestampsInSnapshots;\n      }, td);\n\n      function td(t, e) {\n        var n = this;\n\n        if (this._firebaseApp = null, this._queue = new $i(), this.INTERNAL = {\n          delete: function () {\n            return p(n, void 0, void 0, function () {\n              return m(this, function (t) {\n                switch (t.label) {\n                  case 0:\n                    return this.ensureClientConfigured(), [4, this._firestoreClient.terminate()];\n\n                  case 1:\n                    return t.sent(), [2];\n                }\n              });\n            });\n          }\n        }, \"object\" == typeof t.options) {\n          var r = t;\n          this._firebaseApp = r, this._databaseId = td.databaseIdFromApp(r), this._persistenceKey = r.name, this._credentials = new sp(e);\n        } else {\n          var i = t;\n          if (!i.projectId) throw new zr(Wr.INVALID_ARGUMENT, \"Must provide projectId\");\n          this._databaseId = new _i(i.projectId, i.database), this._persistenceKey = \"[DEFAULT]\", this._credentials = new op();\n        }\n\n        this._settings = new Xp({}), this._dataConverter = this.createDataConverter(this._databaseId);\n      }\n\n      var ed = (nd.prototype.get = function (t) {\n        var n = this;\n        ni(\"Transaction.get\", arguments, 1);\n        var r = Id(\"Transaction.get\", t, this._firestore);\n        return this._transaction.lookup([r._key]).then(function (t) {\n          if (!t || 1 !== t.length) return Br(\"Mismatch in docs returned from document lookup.\");\n          var e = t[0];\n          if (e instanceof Ks) return new cd(n._firestore, r._key, null, !1, !1, r._converter);\n          if (e instanceof Vs) return new cd(n._firestore, r._key, e, !1, !1, r._converter);\n          throw Br(\"BatchGetDocumentsRequest returned unexpected document type: \" + e.constructor.name);\n        });\n      }, nd.prototype.set = function (t, e, n) {\n        ii(\"Transaction.set\", arguments, 2, 3);\n        var r = Id(\"Transaction.set\", t, this._firestore);\n        n = Td(\"Transaction.set\", n);\n        var i = Cd(r._converter, e, \"Transaction.set\"),\n            o = i[0],\n            a = i[1],\n            s = n.merge || n.mergeFields ? this._firestore._dataConverter.parseMergeData(a, o, n.mergeFields) : this._firestore._dataConverter.parseSetData(a, o);\n        return this._transaction.set(r._key, s), this;\n      }, nd.prototype.update = function (t, e, n) {\n        for (var r, i, o = [], a = 3; a < arguments.length; a++) o[a - 3] = arguments[a];\n\n        return i = \"string\" == typeof e || e instanceof ep ? (ri(\"Transaction.update\", arguments, 3), r = Id(\"Transaction.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateVarargs(\"Transaction.update\", e, n, o)) : (ni(\"Transaction.update\", arguments, 2), r = Id(\"Transaction.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateData(\"Transaction.update\", e)), this._transaction.update(r._key, i), this;\n      }, nd.prototype.delete = function (t) {\n        ni(\"Transaction.delete\", arguments, 1);\n        var e = Id(\"Transaction.delete\", t, this._firestore);\n        return this._transaction.delete(e._key), this;\n      }, nd);\n\n      function nd(t, e) {\n        this._firestore = t, this._transaction = e;\n      }\n\n      var rd = (id.prototype.set = function (t, e, n) {\n        ii(\"WriteBatch.set\", arguments, 2, 3), this.verifyNotCommitted();\n        var r = Id(\"WriteBatch.set\", t, this._firestore);\n        n = Td(\"WriteBatch.set\", n);\n        var i = Cd(r._converter, e, \"WriteBatch.set\"),\n            o = i[0],\n            a = i[1],\n            s = n.merge || n.mergeFields ? this._firestore._dataConverter.parseMergeData(a, o, n.mergeFields) : this._firestore._dataConverter.parseSetData(a, o);\n        return this._mutations = this._mutations.concat(s.toMutations(r._key, Da.NONE)), this;\n      }, id.prototype.update = function (t, e, n) {\n        for (var r, i, o = [], a = 3; a < arguments.length; a++) o[a - 3] = arguments[a];\n\n        return this.verifyNotCommitted(), i = \"string\" == typeof e || e instanceof ep ? (ri(\"WriteBatch.update\", arguments, 3), r = Id(\"WriteBatch.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateVarargs(\"WriteBatch.update\", e, n, o)) : (ni(\"WriteBatch.update\", arguments, 2), r = Id(\"WriteBatch.update\", t, this._firestore), this._firestore._dataConverter.parseUpdateData(\"WriteBatch.update\", e)), this._mutations = this._mutations.concat(i.toMutations(r._key, Da.exists(!0))), this;\n      }, id.prototype.delete = function (t) {\n        ni(\"WriteBatch.delete\", arguments, 1), this.verifyNotCommitted();\n        var e = Id(\"WriteBatch.delete\", t, this._firestore);\n        return this._mutations = this._mutations.concat(new ja(e._key, Da.NONE)), this;\n      }, id.prototype.commit = function () {\n        return p(this, void 0, void 0, function () {\n          return m(this, function (t) {\n            return this.verifyNotCommitted(), this._committed = !0, 0 < this._mutations.length ? [2, this._firestore.ensureClientConfigured().write(this._mutations)] : [2];\n          });\n        });\n      }, id.prototype.verifyNotCommitted = function () {\n        if (this._committed) throw new zr(Wr.FAILED_PRECONDITION, \"A write batch can no longer be used after commit() has been called.\");\n      }, id);\n\n      function id(t) {\n        this._firestore = t, this._mutations = [], this._committed = !1;\n      }\n\n      var od = (ad.forPath = function (t, e, n) {\n        if (t.length % 2 != 0) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid document reference. Document references must have an even number of segments, but \" + t.canonicalString() + \" has \" + t.length);\n        return new ad(new Wi(t), e, n);\n      }, Object.defineProperty(ad.prototype, \"id\", {\n        get: function () {\n          return this._key.path.lastSegment();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(ad.prototype, \"parent\", {\n        get: function () {\n          return new bd(this._key.path.popLast(), this.firestore, this._converter);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(ad.prototype, \"path\", {\n        get: function () {\n          return this._key.path.canonicalString();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), ad.prototype.collection = function (t) {\n        if (ni(\"DocumentReference.collection\", arguments, 1), oi(\"DocumentReference.collection\", \"non-empty string\", 1, t), !t) throw new zr(Wr.INVALID_ARGUMENT, \"Must provide a non-empty collection name to collection()\");\n        var e = Bi.fromString(t);\n        return new bd(this._key.path.child(e), this.firestore);\n      }, ad.prototype.isEqual = function (t) {\n        if (!(t instanceof ad)) throw yi(\"isEqual\", \"DocumentReference\", 1, t);\n        return this.firestore === t.firestore && this._key.isEqual(t._key) && this._converter === t._converter;\n      }, ad.prototype.set = function (t, e) {\n        ii(\"DocumentReference.set\", arguments, 1, 2), e = Td(\"DocumentReference.set\", e);\n        var n = Cd(this._converter, t, \"DocumentReference.set\"),\n            r = n[0],\n            i = n[1],\n            o = e.merge || e.mergeFields ? this.firestore._dataConverter.parseMergeData(i, r, e.mergeFields) : this.firestore._dataConverter.parseSetData(i, r);\n        return this._firestoreClient.write(o.toMutations(this._key, Da.NONE));\n      }, ad.prototype.update = function (t, e) {\n        for (var n, r = [], i = 2; i < arguments.length; i++) r[i - 2] = arguments[i];\n\n        return n = \"string\" == typeof t || t instanceof ep ? (ri(\"DocumentReference.update\", arguments, 2), this.firestore._dataConverter.parseUpdateVarargs(\"DocumentReference.update\", t, e, r)) : (ni(\"DocumentReference.update\", arguments, 1), this.firestore._dataConverter.parseUpdateData(\"DocumentReference.update\", t)), this._firestoreClient.write(n.toMutations(this._key, Da.exists(!0)));\n      }, ad.prototype.delete = function () {\n        return ni(\"DocumentReference.delete\", arguments, 0), this._firestoreClient.write([new ja(this._key, Da.NONE)]);\n      }, ad.prototype.onSnapshot = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        ii(\"DocumentReference.onSnapshot\", arguments, 1, 4);\n        var n,\n            r = {\n          includeMetadataChanges: !1\n        },\n            i = 0;\n        \"object\" != typeof t[i] || pp(t[i]) || (mi(\"DocumentReference.onSnapshot\", r = t[i], [\"includeMetadataChanges\"]), ui(\"DocumentReference.onSnapshot\", \"boolean\", \"includeMetadataChanges\", r.includeMetadataChanges), i++);\n        var o = {\n          includeMetadataChanges: r.includeMetadataChanges\n        };\n        return n = pp(t[i]) ? t[i] : (oi(\"DocumentReference.onSnapshot\", \"function\", i, t[i]), ai(\"DocumentReference.onSnapshot\", \"function\", i + 1, t[i + 1]), ai(\"DocumentReference.onSnapshot\", \"function\", i + 2, t[i + 2]), {\n          next: t[i],\n          error: t[i + 1],\n          complete: t[i + 2]\n        }), this.onSnapshotInternal(o, n);\n      }, ad.prototype.onSnapshotInternal = function (t, n) {\n        var r = this,\n            e = function (t) {\n          console.error(\"Uncaught Error in onSnapshot:\", t);\n        };\n\n        n.error && (e = n.error.bind(n));\n\n        var i = new $f({\n          next: function (t) {\n            if (n.next) {\n              Ur(t.docs.size <= 1, \"Too many documents returned on a document query\");\n              var e = t.docs.get(r._key);\n              n.next(new cd(r.firestore, r._key, e, t.fromCache, t.hasPendingWrites, r._converter));\n            }\n          },\n          error: e\n        }),\n            o = this._firestoreClient.listen(Rc.atPath(this._key.path), i, t);\n\n        return function () {\n          i.mute(), r._firestoreClient.unlisten(o);\n        };\n      }, ad.prototype.get = function (n) {\n        var r = this;\n        return ii(\"DocumentReference.get\", arguments, 0, 1), Ed(\"DocumentReference.get\", n), new Promise(function (e, t) {\n          n && \"cache\" === n.source ? r.firestore.ensureClientConfigured().getDocumentFromLocalCache(r._key).then(function (t) {\n            e(new cd(r.firestore, r._key, t, !0, t instanceof Vs && t.hasLocalMutations, r._converter));\n          }, t) : r.getViaSnapshotListener(e, t, n);\n        });\n      }, ad.prototype.getViaSnapshotListener = function (e, n, r) {\n        var i = this.onSnapshotInternal({\n          includeMetadataChanges: !0,\n          waitForSyncWhenOnline: !0\n        }, {\n          next: function (t) {\n            i(), !t.exists && t.metadata.fromCache ? n(new zr(Wr.UNAVAILABLE, \"Failed to get document because the client is offline.\")) : t.exists && t.metadata.fromCache && r && \"server\" === r.source ? n(new zr(Wr.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to \"server\" to retrieve the cached document.)')) : e(t);\n          },\n          error: n\n        });\n      }, ad.prototype.withConverter = function (t) {\n        return new ad(this._key, this.firestore, t);\n      }, ad);\n\n      function ad(t, e, n) {\n        this._key = t, this.firestore = e, this._converter = n, this._firestoreClient = this.firestore.ensureClientConfigured();\n      }\n\n      var sd = (ud.prototype.isEqual = function (t) {\n        return this.hasPendingWrites === t.hasPendingWrites && this.fromCache === t.fromCache;\n      }, ud);\n\n      function ud(t, e) {\n        this.hasPendingWrites = t, this.fromCache = e;\n      }\n\n      var cd = (hd.prototype.data = function (t) {\n        if (ii(\"DocumentSnapshot.data\", arguments, 0, 1), t = Sd(\"DocumentSnapshot.data\", t), this._document) {\n          if (this._converter) {\n            var e = new fd(this._firestore, this._key, this._document, this._fromCache, this._hasPendingWrites);\n            return this._converter.fromFirestore(e, t);\n          }\n\n          return this.toJSObject(this._document.data(), Wa.fromSnapshotOptions(t, this._firestore._areTimestampsInSnapshotsEnabled()));\n        }\n      }, hd.prototype.get = function (t, e) {\n        if (ii(\"DocumentSnapshot.get\", arguments, 1, 2), e = Sd(\"DocumentSnapshot.get\", e), this._document) {\n          var n = this._document.data().field(zp(\"DocumentSnapshot.get\", t));\n\n          if (null !== n) return this.toJSValue(n, Wa.fromSnapshotOptions(e, this._firestore._areTimestampsInSnapshotsEnabled()));\n        }\n      }, Object.defineProperty(hd.prototype, \"id\", {\n        get: function () {\n          return this._key.path.lastSegment();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(hd.prototype, \"ref\", {\n        get: function () {\n          return new od(this._key, this._firestore, this._converter);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(hd.prototype, \"exists\", {\n        get: function () {\n          return null !== this._document;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(hd.prototype, \"metadata\", {\n        get: function () {\n          return new sd(this._hasPendingWrites, this._fromCache);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), hd.prototype.isEqual = function (t) {\n        if (!(t instanceof hd)) throw yi(\"isEqual\", \"DocumentSnapshot\", 1, t);\n        return this._firestore === t._firestore && this._fromCache === t._fromCache && this._key.isEqual(t._key) && (null === this._document ? null === t._document : this._document.isEqual(t._document)) && this._converter === t._converter;\n      }, hd.prototype.toJSObject = function (t, n) {\n        var r = this,\n            i = {};\n        return t.forEach(function (t, e) {\n          i[t] = r.toJSValue(e, n);\n        }), i;\n      }, hd.prototype.toJSValue = function (t, e) {\n        if (t instanceof Ms) return this.toJSObject(t, e);\n        if (t instanceof Os) return this.toJSArray(t, e);\n\n        if (t instanceof Cs) {\n          var n = t.value(e),\n              r = this._firestore.ensureClientConfigured().databaseId();\n\n          return t.databaseId.isEqual(r) || qr(\"Document \" + this._key.path + \" contains a document reference within a different database (\" + t.databaseId.projectId + \"/\" + t.databaseId.database + \") which is not supported. It will be treated as a reference in the current database (\" + r.projectId + \"/\" + r.database + \") instead.\"), new od(n, this._firestore, this._converter);\n        }\n\n        return t.value(e);\n      }, hd.prototype.toJSArray = function (t, e) {\n        var n = this;\n        return t.internalValue.map(function (t) {\n          return n.toJSValue(t, e);\n        });\n      }, hd);\n\n      function hd(t, e, n, r, i, o) {\n        this._firestore = t, this._key = e, this._document = n, this._fromCache = r, this._hasPendingWrites = i, this._converter = o;\n      }\n\n      var ld,\n          fd = (t(pd, ld = cd), pd.prototype.data = function (t) {\n        var e = ld.prototype.data.call(this, t);\n        return Ur(void 0 !== e, \"Document in a QueryDocumentSnapshot should exist\"), e;\n      }, pd);\n\n      function pd() {\n        return null !== ld && ld.apply(this, arguments) || this;\n      }\n\n      var dd = (md.prototype.where = function (t, e, n) {\n        var r;\n        ni(\"Query.where\", arguments, 3), di(\"Query.where\", 3, n), function (t, e, n, r) {\n          if (!e.some(function (t) {\n            return t === r;\n          })) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid value \" + pi(r) + \" provided to function \" + t + \"() for its \" + vi(n) + \" argument. Acceptable values: \" + e.join(\", \"));\n        }(\"Query.where\", [\"<\", \"<=\", \"==\", \">=\", \">\", \"array-contains\", \"in\", \"array-contains-any\"], 2, e);\n        var i = zp(\"Query.where\", t),\n            o = Lc.fromString(e);\n\n        if (i.isKeyField()) {\n          if (o === Lc.ARRAY_CONTAINS || o === Lc.ARRAY_CONTAINS_ANY) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid Query. You can't perform '\" + o.toString() + \"' queries on FieldPath.documentId().\");\n\n          if (o === Lc.IN) {\n            this.validateDisjunctiveFilterElements(n, o);\n\n            for (var a = [], s = 0, u = n; s < u.length; s++) {\n              var c = u[s];\n              a.push(this.parseDocumentIdValue(c));\n            }\n\n            r = new Os(a);\n          } else r = this.parseDocumentIdValue(n);\n        } else o !== Lc.IN && o !== Lc.ARRAY_CONTAINS_ANY || this.validateDisjunctiveFilterElements(n, o), r = this.firestore._dataConverter.parseQueryValue(\"Query.where\", n, o === Lc.IN);\n\n        var h = xc.create(i, o, r);\n        return this.validateNewFilter(h), new md(this._query.addFilter(h), this.firestore, this._converter);\n      }, md.prototype.orderBy = function (t, e) {\n        var n;\n        if (ii(\"Query.orderBy\", arguments, 1, 2), ai(\"Query.orderBy\", \"non-empty string\", 2, e), void 0 === e || \"asc\" === e) n = $c.ASCENDING;else {\n          if (\"desc\" !== e) throw new zr(Wr.INVALID_ARGUMENT, \"Function Query.orderBy() has unknown direction '\" + e + \"', expected 'asc' or 'desc'.\");\n          n = $c.DESCENDING;\n        }\n        if (null !== this._query.startAt) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. You must not call Query.startAt() or Query.startAfter() before calling Query.orderBy().\");\n        if (null !== this._query.endAt) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. You must not call Query.endAt() or Query.endBefore() before calling Query.orderBy().\");\n        var r = zp(\"Query.orderBy\", t),\n            i = new rh(r, n);\n        return this.validateNewOrderBy(i), new md(this._query.addOrderBy(i), this.firestore, this._converter);\n      }, md.prototype.limit = function (t) {\n        return ni(\"Query.limit\", arguments, 1), oi(\"Query.limit\", \"number\", 1, t), gi(\"Query.limit\", 1, t), new md(this._query.withLimitToFirst(t), this.firestore, this._converter);\n      }, md.prototype.limitToLast = function (t) {\n        return ni(\"Query.limitToLast\", arguments, 1), oi(\"Query.limitToLast\", \"number\", 1, t), gi(\"Query.limitToLast\", 1, t), new md(this._query.withLimitToLast(t), this.firestore, this._converter);\n      }, md.prototype.startAt = function (t) {\n        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n        ri(\"Query.startAt\", arguments, 1);\n        var r = this.boundFromDocOrFields(\"Query.startAt\", t, e, !0);\n        return new md(this._query.withStartAt(r), this.firestore, this._converter);\n      }, md.prototype.startAfter = function (t) {\n        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n        ri(\"Query.startAfter\", arguments, 1);\n        var r = this.boundFromDocOrFields(\"Query.startAfter\", t, e, !1);\n        return new md(this._query.withStartAt(r), this.firestore, this._converter);\n      }, md.prototype.endBefore = function (t) {\n        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n        ri(\"Query.endBefore\", arguments, 1);\n        var r = this.boundFromDocOrFields(\"Query.endBefore\", t, e, !0);\n        return new md(this._query.withEndAt(r), this.firestore, this._converter);\n      }, md.prototype.endAt = function (t) {\n        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n\n        ri(\"Query.endAt\", arguments, 1);\n        var r = this.boundFromDocOrFields(\"Query.endAt\", t, e, !1);\n        return new md(this._query.withEndAt(r), this.firestore, this._converter);\n      }, md.prototype.isEqual = function (t) {\n        if (!(t instanceof md)) throw yi(\"isEqual\", \"Query\", 1, t);\n        return this.firestore === t.firestore && this._query.isEqual(t._query);\n      }, md.prototype.withConverter = function (t) {\n        return new md(this._query, this.firestore, t);\n      }, md.prototype.boundFromDocOrFields = function (t, e, n, r) {\n        if (di(t, 1, e), e instanceof cd) {\n          if (0 < n.length) throw new zr(Wr.INVALID_ARGUMENT, \"Too many arguments provided to \" + t + \"().\");\n          var i = e;\n          if (!i.exists) throw new zr(Wr.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \" + t + \"().\");\n          return this.boundFromDocument(t, i._document, r);\n        }\n\n        var o = [e].concat(n);\n        return this.boundFromFields(t, o, r);\n      }, md.prototype.boundFromDocument = function (t, e, n) {\n        for (var r = [], i = 0, o = this._query.orderBy; i < o.length; i++) {\n          var a = o[i];\n          if (a.field.isKeyField()) r.push(new Cs(this.firestore._databaseId, e.key));else {\n            var s = e.field(a.field);\n            if (s instanceof bs) throw new zr(Wr.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field \"' + a.field + '\" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');\n\n            if (null === s) {\n              var u = a.field.canonicalString();\n              throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a document for which the field '\" + u + \"' (used as the orderBy) does not exist.\");\n            }\n\n            r.push(s);\n          }\n        }\n\n        return new eh(r, n);\n      }, md.prototype.boundFromFields = function (t, e, n) {\n        var r = this._query.explicitOrderBy;\n        if (e.length > r.length) throw new zr(Wr.INVALID_ARGUMENT, \"Too many arguments provided to \" + t + \"(). The number of arguments must be less than or equal to the number of Query.orderBy() clauses\");\n\n        for (var i = [], o = 0; o < e.length; o++) {\n          var a = e[o];\n\n          if (r[o].field.isKeyField()) {\n            if (\"string\" != typeof a) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \" + t + \"(), but got a \" + typeof a);\n            if (!this._query.isCollectionGroupQuery() && -1 !== a.indexOf(\"/\")) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to \" + t + \"() must be a plain document ID, but '\" + a + \"' contains a slash.\");\n\n            var s = this._query.path.child(Bi.fromString(a));\n\n            if (!Wi.isDocumentKey(s)) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to \" + t + \"() must result in a valid document path, but '\" + s + \"' is not because it contains an odd number of segments.\");\n            var u = new Wi(s);\n            i.push(new Cs(this.firestore._databaseId, u));\n          } else {\n            var c = this.firestore._dataConverter.parseQueryValue(t, a);\n\n            i.push(c);\n          }\n        }\n\n        return new eh(i, n);\n      }, md.prototype.onSnapshot = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        ii(\"Query.onSnapshot\", arguments, 1, 4);\n        var n,\n            r = {},\n            i = 0;\n        return \"object\" != typeof t[i] || pp(t[i]) || (mi(\"Query.onSnapshot\", r = t[i], [\"includeMetadataChanges\"]), ui(\"Query.onSnapshot\", \"boolean\", \"includeMetadataChanges\", r.includeMetadataChanges), i++), n = pp(t[i]) ? t[i] : (oi(\"Query.onSnapshot\", \"function\", i, t[i]), ai(\"Query.onSnapshot\", \"function\", i + 1, t[i + 1]), ai(\"Query.onSnapshot\", \"function\", i + 2, t[i + 2]), {\n          next: t[i],\n          error: t[i + 1],\n          complete: t[i + 2]\n        }), this.validateHasExplicitOrderByForLimitToLast(this._query), this.onSnapshotInternal(r, n);\n      }, md.prototype.onSnapshotInternal = function (t, e) {\n        var n = this,\n            r = function (t) {\n          console.error(\"Uncaught Error in onSnapshot:\", t);\n        };\n\n        e.error && (r = e.error.bind(e));\n        var i = new $f({\n          next: function (t) {\n            e.next && e.next(new yd(n.firestore, n._query, t, n._converter));\n          },\n          error: r\n        }),\n            o = this.firestore.ensureClientConfigured(),\n            a = o.listen(this._query, i, t);\n        return function () {\n          i.mute(), o.unlisten(a);\n        };\n      }, md.prototype.validateHasExplicitOrderByForLimitToLast = function (t) {\n        if (t.hasLimitToLast() && 0 === t.explicitOrderBy.length) throw new zr(Wr.UNIMPLEMENTED, \"limitToLast() queries require specifying at least one orderBy() clause\");\n      }, md.prototype.get = function (n) {\n        var r = this;\n        return ii(\"Query.get\", arguments, 0, 1), Ed(\"Query.get\", n), this.validateHasExplicitOrderByForLimitToLast(this._query), new Promise(function (e, t) {\n          n && \"cache\" === n.source ? r.firestore.ensureClientConfigured().getDocumentsFromLocalCache(r._query).then(function (t) {\n            e(new yd(r.firestore, r._query, t, r._converter));\n          }, t) : r.getViaSnapshotListener(e, t, n);\n        });\n      }, md.prototype.getViaSnapshotListener = function (e, n, r) {\n        var i = this.onSnapshotInternal({\n          includeMetadataChanges: !0,\n          waitForSyncWhenOnline: !0\n        }, {\n          next: function (t) {\n            i(), t.metadata.fromCache && r && \"server\" === r.source ? n(new zr(Wr.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to \"server\" to retrieve the cached documents.)')) : e(t);\n          },\n          error: n\n        });\n      }, md.prototype.parseDocumentIdValue = function (t) {\n        if (\"string\" == typeof t) {\n          if (\"\" === t) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.\");\n          if (!this._query.isCollectionGroupQuery() && -1 !== t.indexOf(\"/\")) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but '\" + t + \"' contains a '/' character.\");\n\n          var e = this._query.path.child(Bi.fromString(t));\n\n          if (!Wi.isDocumentKey(e)) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '\" + e + \"' is not because it has an odd number of segments (\" + e.length + \").\");\n          return new Cs(this.firestore._databaseId, new Wi(e));\n        }\n\n        if (t instanceof od) {\n          var n = t;\n          return new Cs(this.firestore._databaseId, n._key);\n        }\n\n        throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: \" + pi(t) + \".\");\n      }, md.prototype.validateDisjunctiveFilterElements = function (t, e) {\n        if (!Array.isArray(t) || 0 === t.length) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid Query. A non-empty array is required for '\" + e.toString() + \"' filters.\");\n        if (10 < t.length) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid Query. '\" + e.toString() + \"' filters support a maximum of 10 elements in the value array.\");\n        if (0 <= t.indexOf(null)) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid Query. '\" + e.toString() + \"' filters cannot contain 'null' in the value array.\");\n        if (0 < t.filter(function (t) {\n          return Number.isNaN(t);\n        }).length) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid Query. '\" + e.toString() + \"' filters cannot contain 'NaN' in the value array.\");\n      }, md.prototype.validateNewFilter = function (t) {\n        if (t instanceof xc) {\n          var e = [Lc.ARRAY_CONTAINS, Lc.ARRAY_CONTAINS_ANY],\n              n = [Lc.IN, Lc.ARRAY_CONTAINS_ANY],\n              r = 0 <= e.indexOf(t.op),\n              i = 0 <= n.indexOf(t.op);\n\n          if (t.isInequality()) {\n            var o = this._query.getInequalityFilterField();\n\n            if (null !== o && !o.isEqual(t.field)) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. All where filters with an inequality (<, <=, >, or >=) must be on the same field. But you have inequality filters on '\" + o.toString() + \"' and '\" + t.field.toString() + \"'\");\n\n            var a = this._query.getFirstOrderByField();\n\n            null !== a && this.validateOrderByAndInequalityMatch(t.field, a);\n          } else if (i || r) {\n            var s = null;\n            if (i && (s = this._query.findFilterOperator(n)), null === s && r && (s = this._query.findFilterOperator(e)), null != s) throw s === t.op ? new zr(Wr.INVALID_ARGUMENT, \"Invalid query. You cannot use more than one '\" + t.op.toString() + \"' filter.\") : new zr(Wr.INVALID_ARGUMENT, \"Invalid query. You cannot use '\" + t.op.toString() + \"' filters with '\" + s.toString() + \"' filters.\");\n          }\n        }\n      }, md.prototype.validateNewOrderBy = function (t) {\n        if (null === this._query.getFirstOrderByField()) {\n          var e = this._query.getInequalityFilterField();\n\n          null !== e && this.validateOrderByAndInequalityMatch(e, t.field);\n        }\n      }, md.prototype.validateOrderByAndInequalityMatch = function (t, e) {\n        if (!e.isEqual(t)) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid query. You have a where filter with an inequality (<, <=, >, or >=) on field '\" + t.toString() + \"' and so you must also use '\" + t.toString() + \"' as your first Query.orderBy(), but your first Query.orderBy() is on field '\" + e.toString() + \"' instead.\");\n      }, md);\n\n      function md(t, e, n) {\n        this._query = t, this.firestore = e, this._converter = n;\n      }\n\n      var yd = (Object.defineProperty(gd.prototype, \"docs\", {\n        get: function () {\n          var e = [];\n          return this.forEach(function (t) {\n            return e.push(t);\n          }), e;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(gd.prototype, \"empty\", {\n        get: function () {\n          return this._snapshot.docs.isEmpty();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(gd.prototype, \"size\", {\n        get: function () {\n          return this._snapshot.docs.size;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), gd.prototype.forEach = function (e, n) {\n        var r = this;\n        ii(\"QuerySnapshot.forEach\", arguments, 1, 2), oi(\"QuerySnapshot.forEach\", \"function\", 1, e), this._snapshot.docs.forEach(function (t) {\n          e.call(n, r.convertToDocumentImpl(t));\n        });\n      }, Object.defineProperty(gd.prototype, \"query\", {\n        get: function () {\n          return new dd(this._originalQuery, this._firestore, this._converter);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), gd.prototype.docChanges = function (t) {\n        t && (mi(\"QuerySnapshot.docChanges\", t, [\"includeMetadataChanges\"]), ui(\"QuerySnapshot.docChanges\", \"boolean\", \"includeMetadataChanges\", t.includeMetadataChanges));\n        var e = !(!t || !t.includeMetadataChanges);\n        if (e && this._snapshot.excludesMetadataChanges) throw new zr(Wr.INVALID_ARGUMENT, \"To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().\");\n        return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function (i, e, o, a) {\n          if (o.oldDocs.isEmpty()) {\n            var n,\n                r = 0;\n            return o.docChanges.map(function (t) {\n              var e = new fd(i, t.doc.key, t.doc, o.fromCache, o.mutatedKeys.has(t.doc.key), a);\n              return Ur(t.type === sl.Added, \"Invalid event type for first snapshot\"), Ur(!n || o.query.docComparator(n, t.doc) < 0, \"Got added events in wrong order\"), n = t.doc, {\n                type: \"added\",\n                doc: e,\n                oldIndex: -1,\n                newIndex: r++\n              };\n            });\n          }\n\n          var s = o.oldDocs;\n          return o.docChanges.filter(function (t) {\n            return e || t.type !== sl.Metadata;\n          }).map(function (t) {\n            var e = new fd(i, t.doc.key, t.doc, o.fromCache, o.mutatedKeys.has(t.doc.key), a),\n                n = -1,\n                r = -1;\n            return t.type !== sl.Added && (Ur(0 <= (n = s.indexOf(t.doc.key)), \"Index for document not found\"), s = s.delete(t.doc.key)), t.type !== sl.Removed && (r = (s = s.add(t.doc)).indexOf(t.doc.key)), {\n              type: function (t) {\n                switch (t) {\n                  case sl.Added:\n                    return \"added\";\n\n                  case sl.Modified:\n                  case sl.Metadata:\n                    return \"modified\";\n\n                  case sl.Removed:\n                    return \"removed\";\n\n                  default:\n                    return Br(\"Unknown change type: \" + t);\n                }\n              }(t.type),\n              doc: e,\n              oldIndex: n,\n              newIndex: r\n            };\n          });\n        }(this._firestore, e, this._snapshot, this._converter), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;\n      }, gd.prototype.isEqual = function (t) {\n        if (!(t instanceof gd)) throw yi(\"isEqual\", \"QuerySnapshot\", 1, t);\n        return this._firestore === t._firestore && this._originalQuery.isEqual(t._originalQuery) && this._snapshot.isEqual(t._snapshot) && this._converter === t._converter;\n      }, gd.prototype.convertToDocumentImpl = function (t) {\n        return new fd(this._firestore, t.key, t, this.metadata.fromCache, this._snapshot.mutatedKeys.has(t.key), this._converter);\n      }, gd);\n\n      function gd(t, e, n, r) {\n        this._firestore = t, this._originalQuery = e, this._snapshot = n, this._converter = r, this._cachedChanges = null, this._cachedChangesIncludeMetadataChanges = null, this.metadata = new sd(n.hasPendingWrites, n.fromCache);\n      }\n\n      a([\"length\", \"forEach\", \"map\"], \"undefined\" != typeof Symbol ? [Symbol.iterator] : []).forEach(function (t) {\n        try {\n          Object.defineProperty(yd.prototype.docChanges, t, {\n            get: function () {\n              return function () {\n                throw new zr(Wr.INVALID_ARGUMENT, 'QuerySnapshot.docChanges has been changed from a property into a method, so usages like \"querySnapshot.docChanges\" should become \"querySnapshot.docChanges()\"');\n              }();\n            }\n          });\n        } catch (t) {}\n      });\n      var vd,\n          bd = (t(wd, vd = dd), Object.defineProperty(wd.prototype, \"id\", {\n        get: function () {\n          return this._query.path.lastSegment();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(wd.prototype, \"parent\", {\n        get: function () {\n          var t = this._query.path.popLast();\n\n          return t.isEmpty() ? null : new od(new Wi(t), this.firestore);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(wd.prototype, \"path\", {\n        get: function () {\n          return this._query.path.canonicalString();\n        },\n        enumerable: !0,\n        configurable: !0\n      }), wd.prototype.doc = function (t) {\n        if (ii(\"CollectionReference.doc\", arguments, 0, 1), 0 === arguments.length && (t = wi.newId()), oi(\"CollectionReference.doc\", \"non-empty string\", 1, t), \"\" === t) throw new zr(Wr.INVALID_ARGUMENT, \"Document path must be a non-empty string\");\n        var e = Bi.fromString(t);\n        return od.forPath(this._query.path.child(e), this.firestore, this._converter);\n      }, wd.prototype.add = function (t) {\n        ni(\"CollectionReference.add\", arguments, 1), oi(\"CollectionReference.add\", \"object\", 1, t);\n        var e = this.doc();\n        return e.set(t).then(function () {\n          return e;\n        });\n      }, wd.prototype.withConverter = function (t) {\n        return new wd(this._path, this.firestore, t);\n      }, wd);\n\n      function wd(t, e, n) {\n        var r = vd.call(this, Rc.atPath(t), e, n) || this;\n        if ((r._path = t).length % 2 != 1) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid collection reference. Collection references must have an odd number of segments, but \" + t.canonicalString() + \" has \" + t.length);\n        return r;\n      }\n\n      function Td(t, e) {\n        if (void 0 === e) return {\n          merge: !1\n        };\n        if (mi(t, e, [\"merge\", \"mergeFields\"]), ui(t, \"boolean\", \"merge\", e.merge), ci(t, \"mergeFields\", \"a string or a FieldPath\", e.mergeFields, function (t) {\n          return \"string\" == typeof t || t instanceof ep;\n        }), void 0 !== e.mergeFields && void 0 !== e.merge) throw new zr(Wr.INVALID_ARGUMENT, \"Invalid options passed to function \" + t + '(): You cannot specify both \"merge\" and \"mergeFields\".');\n        return e;\n      }\n\n      function Sd(t, e) {\n        return void 0 === e ? {} : (mi(t, e, [\"serverTimestamps\"]), hi(t, 0, \"serverTimestamps\", e.serverTimestamps, [\"estimate\", \"previous\", \"none\"]), e);\n      }\n\n      function Ed(t, e) {\n        ai(t, \"object\", 1, e), e && (mi(t, e, [\"source\"]), hi(t, 0, \"source\", e.source, [\"default\", \"server\", \"cache\"]));\n      }\n\n      function Id(t, e, n) {\n        if (e instanceof od) {\n          if (e.firestore !== n) throw new zr(Wr.INVALID_ARGUMENT, \"Provided document reference is from a different Firestore instance.\");\n          return e;\n        }\n\n        throw yi(t, \"DocumentReference\", 1, e);\n      }\n\n      function Cd(t, e, n) {\n        var r;\n        return t ? (r = t.toFirestore(e), n = \"toFirestore() in \" + n) : r = e, [r, n];\n      }\n\n      var Dd = Yr($p, \"Use firebase.firestore() instead.\"),\n          Nd = Yr(ed, \"Use firebase.firestore().runTransaction() instead.\"),\n          Ad = Yr(rd, \"Use firebase.firestore().batch() instead.\"),\n          kd = Yr(od, \"Use firebase.firestore().doc() instead.\"),\n          Rd = Yr(cd),\n          Md = Yr(fd),\n          _d = Yr(dd),\n          Ld = Yr(yd),\n          Od = Yr(bd, \"Use firebase.firestore().collection() instead.\"),\n          Pd = {\n        Firestore: Dd,\n        GeoPoint: Pl,\n        Timestamp: co,\n        Blob: ki,\n        Transaction: Nd,\n        WriteBatch: Ad,\n        DocumentReference: kd,\n        DocumentSnapshot: Rd,\n        Query: _d,\n        QueryDocumentSnapshot: Md,\n        QuerySnapshot: Ld,\n        CollectionReference: Od,\n        FieldPath: ep,\n        FieldValue: Mp,\n        setLogLevel: $p.setLogLevel,\n        CACHE_SIZE_UNLIMITED: Jp\n      };\n\n      function xd(t) {\n        t.INTERNAL.registerComponent(new w(\"firestore\", function (t) {\n          var e = t.getProvider(\"app\").getImmediate();\n          return new $p(e, t.getProvider(\"auth-internal\"));\n        }, \"PUBLIC\").setServiceProps(function (t) {\n          Ur(t && \"object\" == typeof t, \"shallowCopy() expects object parameter.\");\n          var e = {};\n\n          for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n\n          return e;\n        }(Pd)));\n      }\n\n      var Fd = (qd.prototype.addCallback = function (t) {}, qd.prototype.shutdown = function () {}, qd);\n\n      function qd() {}\n\n      var Vd = \"ConnectivityMonitor\",\n          Bd = (Ud.prototype.addCallback = function (t) {\n        this.callbacks.push(t);\n      }, Ud.prototype.shutdown = function () {\n        window.removeEventListener(\"online\", this.networkAvailableListener), window.removeEventListener(\"offline\", this.networkUnavailableListener);\n      }, Ud.prototype.configureNetworkMonitoring = function () {\n        window.addEventListener(\"online\", this.networkAvailableListener), window.addEventListener(\"offline\", this.networkUnavailableListener);\n      }, Ud.prototype.onNetworkAvailable = function () {\n        Fr(Vd, \"Network connectivity changed: AVAILABLE\");\n\n        for (var t = 0, e = this.callbacks; t < e.length; t++) (0, e[t])(0);\n      }, Ud.prototype.onNetworkUnavailable = function () {\n        Fr(Vd, \"Network connectivity changed: UNAVAILABLE\");\n\n        for (var t = 0, e = this.callbacks; t < e.length; t++) (0, e[t])(1);\n      }, Ud.isAvailable = function () {\n        return \"undefined\" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;\n      }, Ud);\n\n      function Ud() {\n        var t = this;\n        this.networkAvailableListener = function () {\n          return t.onNetworkAvailable();\n        }, this.networkUnavailableListener = function () {\n          return t.onNetworkUnavailable();\n        }, this.callbacks = [], this.configureNetworkMonitoring();\n      }\n\n      var Kd = (Qd.prototype.onOpen = function (t) {\n        Ur(!this.wrappedOnOpen, \"Called onOpen on stream twice!\"), this.wrappedOnOpen = t;\n      }, Qd.prototype.onClose = function (t) {\n        Ur(!this.wrappedOnClose, \"Called onClose on stream twice!\"), this.wrappedOnClose = t;\n      }, Qd.prototype.onMessage = function (t) {\n        Ur(!this.wrappedOnMessage, \"Called onMessage on stream twice!\"), this.wrappedOnMessage = t;\n      }, Qd.prototype.close = function () {\n        this.closeFn();\n      }, Qd.prototype.send = function (t) {\n        this.sendFn(t);\n      }, Qd.prototype.callOnOpen = function () {\n        Ur(void 0 !== this.wrappedOnOpen, \"Cannot call onOpen because no callback was set\"), this.wrappedOnOpen();\n      }, Qd.prototype.callOnClose = function (t) {\n        Ur(void 0 !== this.wrappedOnClose, \"Cannot call onClose because no callback was set\"), this.wrappedOnClose(t);\n      }, Qd.prototype.callOnMessage = function (t) {\n        Ur(void 0 !== this.wrappedOnMessage, \"Cannot call onMessage because no callback was set\"), this.wrappedOnMessage(t);\n      }, Qd);\n\n      function Qd(t) {\n        this.sendFn = t.sendFn, this.closeFn = t.closeFn;\n      }\n\n      var jd = \"Connection\",\n          Gd = {\n        BatchGetDocuments: \"batchGet\",\n        Commit: \"commit\"\n      },\n          Wd = \"gl-js/ fire/\" + Lr,\n          zd = (Hd.prototype.modifyHeadersForRequest = function (t, e) {\n        if (e) for (var n in e.authHeaders) e.authHeaders.hasOwnProperty(n) && (t[n] = e.authHeaders[n]);\n        t[\"X-Goog-Api-Client\"] = Wd;\n      }, Hd.prototype.invokeRPC = function (s, r, u) {\n        var c = this,\n            h = this.makeUrl(s);\n        return new Promise(function (i, o) {\n          var a = new _r();\n          a.listenOnce(Rr.COMPLETE, function () {\n            try {\n              switch (a.getLastErrorCode()) {\n                case kr.NO_ERROR:\n                  var t = a.getResponseJson();\n                  Fr(jd, \"XHR received:\", JSON.stringify(t)), i(t);\n                  break;\n\n                case kr.TIMEOUT:\n                  Fr(jd, 'RPC \"' + s + '\" timed out'), o(new zr(Wr.DEADLINE_EXCEEDED, \"Request time out\"));\n                  break;\n\n                case kr.HTTP_ERROR:\n                  var e = a.getStatus();\n\n                  if (Fr(jd, 'RPC \"' + s + '\" failed with status:', e, \"response text:\", a.getResponseText()), 0 < e) {\n                    var n = a.getResponseJson().error;\n\n                    if (n && n.status && n.message) {\n                      var r = function (t) {\n                        var e = t.toLowerCase().replace(\"_\", \"-\");\n                        return 0 <= Object.values(Wr).indexOf(e) ? e : Wr.UNKNOWN;\n                      }(n.status);\n\n                      o(new zr(r, n.message));\n                    } else o(new zr(Wr.UNKNOWN, \"Server responded with status \" + a.getStatus()));\n                  } else Fr(jd, 'RPC \"' + s + '\" failed'), o(new zr(Wr.UNAVAILABLE, \"Connection failed.\"));\n\n                  break;\n\n                default:\n                  Br('RPC \"' + s + '\" failed with unanticipated webchannel error ' + a.getLastErrorCode() + \": \" + a.getLastError() + \", giving up.\");\n              }\n            } finally {\n              Fr(jd, 'RPC \"' + s + '\" completed.');\n            }\n          });\n          var t = l({}, r);\n          delete t.database;\n          var e = JSON.stringify(t);\n          Fr(jd, \"XHR sending: \", h + \" \" + e);\n          var n = {\n            \"Content-Type\": \"text/plain\"\n          };\n          c.modifyHeadersForRequest(n, u), a.send(h, \"POST\", e, n, 15);\n        });\n      }, Hd.prototype.invokeStreamingRPC = function (t, e, n) {\n        return this.invokeRPC(t, e, n);\n      }, Hd.prototype.openStream = function (t, e) {\n        var n = [this.baseUrl, \"/\", \"google.firestore.v1.Firestore\", \"/\", t, \"/channel\"],\n            r = Ar(),\n            i = {\n          backgroundChannelTest: !0,\n          httpSessionIdParam: \"gsessionid\",\n          initMessageHeaders: {},\n          messageUrlParams: {\n            database: \"projects/\" + this.databaseId.projectId + \"/databases/\" + this.databaseId.database\n          },\n          sendRawJson: !0,\n          supportsCrossDomainXhr: !0,\n          internalChannelParams: {\n            forwardChannelRequestTimeoutMs: 6e5\n          },\n          forceLongPolling: this.forceLongPolling\n        };\n        this.modifyHeadersForRequest(i.initMessageHeaders, e), \"object\" == typeof navigator && \"ReactNative\" === navigator.product || (i.httpHeadersOverwriteParam = \"$httpHeaders\");\n        var o = n.join(\"\");\n\n        function a(t, e) {\n          u.listen(t, function (t) {\n            try {\n              e(t);\n            } catch (t) {\n              setTimeout(function () {\n                throw t;\n              }, 0);\n            }\n          });\n        }\n\n        Fr(jd, \"Creating WebChannel: \" + o + \" \" + i);\n        var u = r.createWebChannel(o, i),\n            s = !1,\n            c = !1,\n            h = new Kd({\n          sendFn: function (t) {\n            c ? Fr(jd, \"Not sending because WebChannel is closed:\", t) : (s || (Fr(jd, \"Opening WebChannel transport.\"), u.open(), s = !0), Fr(jd, \"WebChannel sending:\", t), u.send(t));\n          },\n          closeFn: function () {\n            return u.close();\n          }\n        });\n        return a(Mr.EventType.OPEN, function () {\n          c || Fr(jd, \"WebChannel transport opened.\");\n        }), a(Mr.EventType.CLOSE, function () {\n          c || (c = !0, Fr(jd, \"WebChannel transport closed\"), h.callOnClose());\n        }), a(Mr.EventType.ERROR, function (t) {\n          c || (c = !0, Fr(jd, \"WebChannel transport errored:\", t), h.callOnClose(new zr(Wr.UNAVAILABLE, \"The operation could not be completed\")));\n        }), a(Mr.EventType.MESSAGE, function (t) {\n          var e;\n\n          if (!c) {\n            var n = t.data[0];\n            Ur(!!n, \"Got a webchannel message without data.\");\n            var r = n,\n                i = r.error || (null === (e = r[0]) || void 0 === e ? void 0 : e.error);\n\n            if (i) {\n              Fr(jd, \"WebChannel received error:\", i);\n\n              var o = i.status,\n                  a = function (t) {\n                var e = el[t];\n                if (void 0 !== e) return al(e);\n              }(o),\n                  s = i.message;\n\n              void 0 === a && (a = Wr.INTERNAL, s = \"Unknown error status: \" + o + \" with message \" + i.message), c = !0, h.callOnClose(new zr(a, s)), u.close();\n            } else Fr(jd, \"WebChannel received:\", n), h.callOnMessage(n);\n          }\n        }), setTimeout(function () {\n          h.callOnOpen();\n        }, 0), h;\n      }, Hd.prototype.makeUrl = function (t) {\n        var e = Gd[t];\n        return Ur(void 0 !== e, \"Unknown REST mapping for: \" + t), this.baseUrl + \"/v1/projects/\" + this.databaseId.projectId + \"/databases/\" + this.databaseId.database + \"/documents:\" + e;\n      }, Hd);\n\n      function Hd(t) {\n        this.databaseId = t.databaseId;\n        var e = t.ssl ? \"https\" : \"http\";\n        this.baseUrl = e + \"://\" + t.host, this.forceLongPolling = t.forceLongPolling;\n      }\n\n      var Yd = (Object.defineProperty(Jd.prototype, \"document\", {\n        get: function () {\n          return \"undefined\" != typeof document ? document : null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(Jd.prototype, \"window\", {\n        get: function () {\n          return \"undefined\" != typeof window ? window : null;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Jd.prototype.loadConnection = function (t) {\n        return Promise.resolve(new zd(t));\n      }, Jd.prototype.newConnectivityMonitor = function () {\n        return Bd.isAvailable() ? new Bd() : new Fd();\n      }, Jd.prototype.newSerializer = function (t) {\n        return new ef(t, {\n          useProto3Json: !0\n        });\n      }, Jd.prototype.formatJSON = function (t) {\n        return JSON.stringify(t);\n      }, Jd.prototype.atob = function (t) {\n        return atob(t);\n      }, Jd.prototype.btoa = function (t) {\n        return btoa(t);\n      }, Jd);\n\n      function Jd() {\n        this.emptyByteString = \"\", this.base64Available = \"undefined\" != typeof atob;\n      }\n\n      Kr.setPlatform(new Yd());\n      var Xd;\n      xd(Xd = Zd), Xd.registerVersion(\"@firebase/firestore\", \"1.9.1\");\n    }).apply(this, arguments);\n  } catch (t) {\n    throw console.error(t), new Error(\"Cannot instantiate firebase-firestore - be sure to load firebase-app.js first.\");\n  }\n});","map":null,"metadata":{},"sourceType":"script"}